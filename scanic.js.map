{"version":3,"file":"scanic.js","sources":["../src/constants.js","../src/contourDetection.js","../src/cornerDetection.js","../wasm_blur/pkg/wasm_blur.js","../src/edgeDetection.js","../src/index.js"],"sourcesContent":["/**\r\n * Constants used throughout the library\r\n */\r\n\r\nexport const VERSION = '1.0.0';\r\n\r\nexport const DEFAULTS = {\r\n  // Edge detection params\r\n  GAUSSIAN_SIGMA: 1.1,\r\n  LOW_THRESHOLD: 50,\r\n  HIGH_THRESHOLD: 150,\r\n  \r\n  // Contour detection params\r\n  MIN_CONTOUR_AREA: 1000,\r\n  MIN_CONTOUR_POINTS: 10,\r\n  \r\n  // Debug options\r\n  DEBUG_OVERLAY_OPACITY: 0.7\r\n};","/**\r\n * Pure JavaScript implementation of contour detection algorithms\r\n * Based on Suzuki, S. and Abe, K. (1985). Topological structural analysis of digitized binary images by border following.\r\n * Replaces the previous flood-fill based connected components analysis.\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\n\r\n// Constants for different retrieval modes (subset of OpenCV)\r\nconst RETR_EXTERNAL = 0;\r\nconst RETR_LIST = 1;\r\n// Constants for different approximation methods (subset of OpenCV)\r\nconst CHAIN_APPROX_NONE = 1;\r\nconst CHAIN_APPROX_SIMPLE = 2;\r\n\r\n// Deltas for 8-connectivity neighborhood checks (0-7 clockwise from top)\r\n// Corresponds to OpenCV's chain code directions\r\nconst deltas = [\r\n  { dx:  0, dy: -1 }, // 0: Top\r\n  { dx:  1, dy: -1 }, // 1: Top-right\r\n  { dx:  1, dy:  0 }, // 2: Right\r\n  { dx:  1, dy:  1 }, // 3: Bottom-right\r\n  { dx:  0, dy:  1 }, // 4: Bottom\r\n  { dx: -1, dy:  1 }, // 5: Bottom-left\r\n  { dx: -1, dy:  0 }, // 6: Left\r\n  { dx: -1, dy: -1 }  // 7: Top-left\r\n];\r\n\r\n/**\r\n * Detects contours in a binary edge image using Suzuki's border following algorithm.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (pixels > 0 are foreground)\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.width] - Image width (required if not square)\r\n * @param {number} [options.height] - Image height (required if not square)\r\n * @param {number} [options.mode=RETR_LIST] - Contour retrieval mode (RETR_EXTERNAL or RETR_LIST)\r\n * @param {number} [options.method=CHAIN_APPROX_SIMPLE] - Contour approximation method (CHAIN_APPROX_NONE or CHAIN_APPROX_SIMPLE)\r\n * @param {number} [options.minArea=DEFAULTS.MIN_CONTOUR_AREA] - Minimum contour area filter (applied after detection)\r\n * @param {Object} [options.debug] - Optional debug object to store intermediate results\r\n * @returns {Array} Array of contours, each contour is an array of points {x, y}. Sorted by area (largest first).\r\n */\r\nexport function detectDocumentContour(edges, options = {}) {\r\n  const width = options.width || Math.sqrt(edges.length);\r\n  const height = options.height || edges.length / width;\r\n  const mode = options.mode !== undefined ? options.mode : RETR_LIST;\r\n  const method = options.method !== undefined ? options.method : CHAIN_APPROX_SIMPLE;\r\n  const minArea = options.minArea || DEFAULTS.MIN_CONTOUR_AREA;\r\n\r\n  // Create a padded label map to simplify boundary checks.\r\n  // 0: background\r\n  // 1: foreground (unlabeled)\r\n  // >= 2: contour ID (2, 3, ...)\r\n  const paddedWidth = width + 2;\r\n  const paddedHeight = height + 2;\r\n  const labels = new Int32Array(paddedWidth * paddedHeight); // Initialized to 0\r\n\r\n  // Copy edges data to the label map, mapping foreground pixels to 1\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (edges[y * width + x] > 0) {\r\n        labels[(y + 1) * paddedWidth + (x + 1)] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  const contours = [];\r\n  let nextContourId = 2; // Start labeling contours from 2\r\n\r\n  // Raster scan\r\n  for (let y = 1; y <= height; y++) {\r\n    for (let x = 1; x <= width; x++) {\r\n      const currentPixelLabel = labels[y * paddedWidth + x];\r\n      const leftPixelLabel = labels[y * paddedWidth + (x - 1)];\r\n\r\n      let startPoint = null;\r\n      let isOuter = false;\r\n      let initialDirection = -1;\r\n\r\n      if (currentPixelLabel === 1 && leftPixelLabel === 0) {\r\n        // Found the start of an outer contour boundary (NBD = 1 in Suzuki's terms)\r\n        isOuter = true;\r\n        startPoint = { x: x, y: y };\r\n        initialDirection = 2; // Start searching right\r\n        // if (options.debug) console.log(`Outer contour start at (${x-1}, ${y-1})`);\r\n      } else if (currentPixelLabel === 0 && leftPixelLabel >= 1 && leftPixelLabel !== -1) {\r\n         // Found the start of a hole contour boundary (NBD >= 2 in Suzuki's terms)\r\n         // Check if the left pixel is already part of a traced contour border\r\n         // If leftPixelLabel is > 1, it might be already traced. If it's 1, it's an unlabeled foreground pixel.\r\n         // We only start tracing if the left pixel is unlabeled foreground (1).\r\n         if (leftPixelLabel === 1) {\r\n             isOuter = false;\r\n             startPoint = { x: x - 1, y: y };\r\n             initialDirection = 6; // Start searching left\r\n            //  if (options.debug) console.log(`Hole contour start at (${x-1-1}, ${y-1})`);\r\n         }\r\n      }\r\n\r\n\r\n      if (startPoint) {\r\n        // If mode is RETR_EXTERNAL, only process outer contours\r\n        if (mode === RETR_EXTERNAL && !isOuter) {\r\n          // Mark the starting pixel of the hole so we don't process it again\r\n          // Use a special marker (-1) to distinguish from contour IDs\r\n           labels[startPoint.y * paddedWidth + startPoint.x] = -1;\r\n           continue;\r\n        }\r\n\r\n        const contourId = nextContourId++;\r\n        const points = traceContour(labels, paddedWidth, paddedHeight, startPoint, initialDirection, contourId);\r\n\r\n        if (points && points.length > 0) {\r\n            let finalPoints = points;\r\n            if (method === CHAIN_APPROX_SIMPLE) {\r\n                finalPoints = simplifyChainApproxSimple(points);\r\n            }\r\n\r\n            // Adjust points to original image coordinates (remove padding offset)\r\n            const adjustedPoints = finalPoints.map(p => ({ x: p.x - 1, y: p.y - 1 }));\r\n\r\n            if (adjustedPoints.length >= (method === CHAIN_APPROX_SIMPLE ? 4 : DEFAULTS.MIN_CONTOUR_POINTS)) { // Need at least 4 points for a simple polygon approx\r\n                const contour = {\r\n                    id: contourId,\r\n                    points: adjustedPoints,\r\n                    isOuter: isOuter,\r\n                    // Calculate area and bounding box later if needed for filtering/sorting\r\n                };\r\n                contours.push(contour);\r\n            }\r\n        } else {\r\n             // Handle single point contours or errors if necessary\r\n             // Mark the start point if trace failed or resulted in no points\r\n             if (labels[startPoint.y * paddedWidth + startPoint.x] === 1) {\r\n                 labels[startPoint.y * paddedWidth + startPoint.x] = contourId; // Mark as visited\r\n             }\r\n        }\r\n      } else if (currentPixelLabel >= 1 && leftPixelLabel >= 1 && currentPixelLabel !== leftPixelLabel) {\r\n          // Handle merging contours or complex topology if needed (not implemented for RETR_LIST/EXTERNAL)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Calculate area and bounding box for filtering and sorting\r\n  contours.forEach(contour => {\r\n    contour.area = calculateContourArea(contour.points);\r\n    contour.boundingBox = calculateBoundingBox(contour.points);\r\n  });\r\n\r\n  // Filter by minimum area\r\n  const filteredContours = contours.filter(contour => contour.area >= minArea);\r\n\r\n  // Sort contours by area (largest first)\r\n  filteredContours.sort((a, b) => b.area - a.area);\r\n\r\n  // console.log(`Found ${contours.length} contours before filtering, ${filteredContours.length} after filtering.`);\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.labels = labels; // Store the final label map\r\n    options.debug.rawContours = contours; // Store contours before filtering/sorting\r\n    options.debug.finalContours = filteredContours;\r\n    // console.log('Contour detection debug info stored');\r\n  }\r\n  return filteredContours // Return only the points array per contour\r\n}\r\n\r\n/**\r\n * Traces a contour boundary using border following.\r\n * Optimized to minimize object allocations.\r\n * @param {Int32Array} labels - The label map (modified during tracing)\r\n * @param {number} width - Padded width of the label map\r\n * @param {number} height - Padded height of the label map\r\n * @param {Object} startPoint - Starting point {x, y} in padded coordinates\r\n * @param {number} initialDirection - Initial search direction (0-7)\r\n * @param {number} contourId - The ID to label this contour with\r\n * @returns {Array} Array of points {x, y} in padded coordinates, or null if error\r\n */\r\nfunction traceContour(labels, width, height, startPoint, initialDirection, contourId) {\r\n    const points = [];\r\n    // Use Set with numeric keys (y * width + x) - much faster than string keys\r\n    const visited = new Set();\r\n    \r\n    // Avoid object creation in hot loop - use primitive coordinates\r\n    let currentX = startPoint.x;\r\n    let currentY = startPoint.y;\r\n    const startX = currentX;\r\n    const startY = currentY;\r\n    \r\n    let prevDirection = -1; // Store the direction from which we arrived at currentPoint\r\n\r\n    // Mark the starting pixel with the contour ID\r\n    labels[startY * width + startX] = contourId;\r\n\r\n    let count = 0; // Safety break\r\n    const maxSteps = width * height; // Max possible steps\r\n    \r\n    // Pre-extract delta values for faster access in hot loop\r\n    const dx = [0, 1, 1, 1, 0, -1, -1, -1];\r\n    const dy = [-1, -1, 0, 1, 1, 1, 0, -1];\r\n\r\n    while (count++ < maxSteps) {\r\n        // Determine the direction to start searching from (relative to the direction we came from)\r\n        // In Suzuki's paper, this is based on the chain code of the previous step.\r\n        // Simplified: Start searching from the direction after the one that led us here.\r\n        // If we arrived from direction `d`, the next pixel must be in `(d+1)%8` to `(d+7)%8`.\r\n        // Let's adapt OpenCV's logic: search starts from (prevDirection + 2) % 8 clockwise.\r\n        // If it's the first step, prevDirection is unknown, use initialDirection logic.\r\n\r\n        let searchDirection;\r\n        if (prevDirection === -1) {\r\n            // First step: Use initialDirection logic (e.g., start right for outer, left for inner)\r\n            // The initial search should find the *first* pixel of the contour boundary clockwise.\r\n            // Let's refine the initial search based on OpenCV's approach:\r\n            // Find the first non-zero pixel starting from `initialDirection` clockwise.\r\n            let found = false;\r\n            for (let i = 0; i < 8; i++) {\r\n                searchDirection = (initialDirection + i) & 7; // Faster than % 8\r\n                const nextX = currentX + dx[searchDirection];\r\n                const nextY = currentY + dy[searchDirection];\r\n                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && labels[nextY * width + nextX] > 0) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) return null; // Should not happen if startPoint is valid\r\n\r\n        } else {\r\n            // Subsequent steps: Start search from (prevDirection + 2) % 8 clockwise\r\n             searchDirection = (prevDirection + 2) & 7;\r\n        }\r\n\r\n\r\n        let nextX = -1;\r\n        let nextY = -1;\r\n        let nextDirection = -1;\r\n\r\n        // Search clockwise for the next boundary pixel\r\n        for (let i = 0; i < 8; i++) {\r\n            const checkDirection = (searchDirection + i) & 7;\r\n            const checkX = currentX + dx[checkDirection];\r\n            const checkY = currentY + dy[checkDirection];\r\n\r\n            // Check bounds (should be within padded area)\r\n            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {\r\n                if (labels[checkY * width + checkX] > 0) { // Found a foreground pixel (labeled or unlabeled)\r\n                    nextX = checkX;\r\n                    nextY = checkY;\r\n                    // The direction *from* currentPoint *to* nextPoint is checkDirection\r\n                    nextDirection = checkDirection;\r\n                    // The direction *from* which we will arrive *at* nextPoint is (checkDirection + 4) % 8\r\n                    prevDirection = (checkDirection + 4) & 7;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextX === -1) {\r\n            // Should not happen in a well-formed contour, maybe isolated pixel?\r\n             if (points.length === 0) { // If it's just the start point\r\n                 points.push({ x: currentX, y: currentY }); // Add the single point\r\n             }\r\n            console.warn(`Contour tracing stopped unexpectedly at (${currentX-1}, ${currentY-1}) for contour ${contourId}`);\r\n            break;\r\n        }\r\n\r\n        // Add the *current* point to the list before moving\r\n        // Use numeric key for Set (much faster than string concatenation)\r\n        const visitedKey = currentY * width + currentX;\r\n        if (visited.has(visitedKey)) {\r\n            // Duplicate point detected - return to avoid infinite loops\r\n            return points;\r\n        }\r\n        points.push({ x: currentX, y: currentY });\r\n        visited.add(visitedKey);\r\n\r\n        // Mark the next pixel if it's unlabeled\r\n        const nextIdx = nextY * width + nextX;\r\n        if (labels[nextIdx] === 1) {\r\n            labels[nextIdx] = contourId;\r\n        }\r\n\r\n        // Move to the next point\r\n        currentX = nextX;\r\n        currentY = nextY;\r\n\r\n        // Check if we returned to the start point\r\n        if (currentX === startX && currentY === startY) {\r\n            // Check if we came from the same direction as the initial step search ended.\r\n            // This is complex, let's use a simpler check: if we are back at start, we are done.\r\n            // OpenCV has more sophisticated checks involving i4 == i0 && i3 == i1.\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (count >= maxSteps) {\r\n        console.warn(`Contour tracing exceeded max steps for contour ${contourId}`);\r\n        return null; // Indicate potential error\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\n/**\r\n * Simplifies a contour polygon using CHAIN_APPROX_SIMPLE.\r\n * Removes intermediate points that lie on the straight line segment between their neighbors.\r\n * Optimized to avoid modulo operations in hot loop.\r\n * @param {Array} points - Array of contour points {x, y}\r\n * @returns {Array} Simplified array of points\r\n */\r\nfunction simplifyChainApproxSimple(points) {\r\n    const n = points.length;\r\n    if (n <= 2) {\r\n        return points;\r\n    }\r\n\r\n    const simplifiedPoints = [];\r\n    \r\n    // Cache first and last points for wrap-around\r\n    const lastPoint = points[n - 1];\r\n    const firstPoint = points[0];\r\n    \r\n    // Check first point (prev = last, next = second)\r\n    let prevPoint = lastPoint;\r\n    let currentPoint = firstPoint;\r\n    let nextPoint = points[1];\r\n    \r\n    let dx1 = currentPoint.x - prevPoint.x;\r\n    let dy1 = currentPoint.y - prevPoint.y;\r\n    let dx2 = nextPoint.x - currentPoint.x;\r\n    let dy2 = nextPoint.y - currentPoint.y;\r\n    \r\n    if (dx1 * dy2 !== dy1 * dx2) {\r\n        simplifiedPoints.push(currentPoint);\r\n    }\r\n    \r\n    // Middle points (no wrap-around needed)\r\n    for (let i = 1; i < n - 1; i++) {\r\n        prevPoint = points[i - 1];\r\n        currentPoint = points[i];\r\n        nextPoint = points[i + 1];\r\n\r\n        dx1 = currentPoint.x - prevPoint.x;\r\n        dy1 = currentPoint.y - prevPoint.y;\r\n        dx2 = nextPoint.x - currentPoint.x;\r\n        dy2 = nextPoint.y - currentPoint.y;\r\n\r\n        if (dx1 * dy2 !== dy1 * dx2) {\r\n            simplifiedPoints.push(currentPoint);\r\n        }\r\n    }\r\n    \r\n    // Check last point (prev = second-to-last, next = first)\r\n    prevPoint = points[n - 2];\r\n    currentPoint = lastPoint;\r\n    nextPoint = firstPoint;\r\n    \r\n    dx1 = currentPoint.x - prevPoint.x;\r\n    dy1 = currentPoint.y - prevPoint.y;\r\n    dx2 = nextPoint.x - currentPoint.x;\r\n    dy2 = nextPoint.y - currentPoint.y;\r\n    \r\n    if (dx1 * dy2 !== dy1 * dx2) {\r\n        simplifiedPoints.push(currentPoint);\r\n    }\r\n\r\n    // Handle cases where all points are collinear (e.g., straight line)\r\n    if (simplifiedPoints.length === 0) {\r\n         if (n === 1) return [points[0]];\r\n         if (n === 2) return points;\r\n\r\n         // Find the point most distant from the first point\r\n         let maxDistSq = 0;\r\n         let farthestIdx = 1;\r\n         const p0x = firstPoint.x;\r\n         const p0y = firstPoint.y;\r\n         for (let i = 1; i < n; i++) {\r\n             const pi = points[i];\r\n             const dx = pi.x - p0x;\r\n             const dy = pi.y - p0y;\r\n             const distSq = dx * dx + dy * dy;\r\n             if (distSq > maxDistSq) {\r\n                 maxDistSq = distSq;\r\n                 farthestIdx = i;\r\n             }\r\n         }\r\n         return [firstPoint, points[farthestIdx]];\r\n    }\r\n\r\n    return simplifiedPoints;\r\n}\r\n\r\n\r\n// --- Helper functions (keep or adapt from original) ---\r\n\r\n/**\r\n * Calculates the area of a contour using the shoelace formula\r\n * @param {Array} points - Array of point coordinates {x, y}\r\n * @returns {number} Contour area\r\n */\r\nfunction calculateContourArea(points) {\r\n  let area = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 3) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n;\r\n    area += points[i].x * points[j].y;\r\n    area -= points[j].x * points[i].y;\r\n  }\r\n\r\n  return Math.abs(area) / 2;\r\n}\r\n\r\n/**\r\n * Calculates the bounding box of a contour\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {Object} Bounding box with minX, minY, maxX, maxY properties\r\n */\r\nfunction calculateBoundingBox(points) {\r\n  if (points.length === 0) {\r\n      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n  }\r\n  let minX = points[0].x;\r\n  let minY = points[0].y;\r\n  let maxX = points[0].x;\r\n  let maxY = points[0].y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      minX = Math.min(minX, point.x);\r\n      minY = Math.min(minY, point.y);\r\n      maxX = Math.max(maxX, point.x);\r\n      maxY = Math.max(maxY, point.y);\r\n  }\r\n\r\n  return { minX, minY, maxX, maxY };\r\n}\r\n\r\n\r\n// --- Functions below are no longer directly used by detectDocumentContour ---\r\n// --- but might be useful elsewhere or can be removed ---\r\n\r\n/**\r\n * Simplifies a contour using the Ramer-Douglas-Peucker algorithm\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} points - Array of point coordinates\r\n * @param {number} epsilon - Epsilon value for simplification\r\n * @returns {Array} Simplified contour points\r\n */\r\nexport function simplifyContour(points, epsilon = 1.0) {\r\n  // ... (keep existing implementation if needed elsewhere) ...\r\n   if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Find point with the maximum distance\r\n  let maxDistance = 0;\r\n  let index = 0;\r\n\r\n  const firstPoint = points[0];\r\n  const lastPoint = points[points.length - 1];\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\r\n\r\n    if (distance > maxDistance) {\r\n      maxDistance = distance;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  // If max distance is greater than epsilon, recursively simplify\r\n  if (maxDistance > epsilon) {\r\n    // Recursive simplification\r\n    const firstSegment = simplifyContour(points.slice(0, index + 1), epsilon);\r\n    const secondSegment = simplifyContour(points.slice(index), epsilon);\r\n\r\n    // Concatenate the two segments\r\n    return firstSegment.slice(0, -1).concat(secondSegment);\r\n  } else {\r\n    // Return just the endpoints\r\n    return [firstPoint, lastPoint];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the perpendicular distance from a point to a line\r\n * (Helper for RDP simplifyContour, keep if that function is kept)\r\n * @param {Object} point - Point to measure from\r\n * @param {Object} lineStart - Start point of the line\r\n * @param {Object} lineEnd - End point of the line\r\n * @returns {number} Perpendicular distance\r\n */\r\nfunction perpendicularDistance(point, lineStart, lineEnd) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   const dx = lineEnd.x - lineStart.x;\r\n  const dy = lineEnd.y - lineStart.y;\r\n\r\n  // Line length squared\r\n  const lineLengthSq = dx * dx + dy * dy;\r\n\r\n  if (lineLengthSq === 0) {\r\n    // Point to point distance if the line has zero length\r\n    return Math.sqrt(\r\n      Math.pow(point.x - lineStart.x, 2) +\r\n      Math.pow(point.y - lineStart.y, 2)\r\n    );\r\n  }\r\n\r\n   // Calculate the projection parameter t\r\n  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq;\r\n\r\n  let closestPointX, closestPointY;\r\n\r\n  if (t < 0) {\r\n    closestPointX = lineStart.x;\r\n    closestPointY = lineStart.y;\r\n  } else if (t > 1) {\r\n    closestPointX = lineEnd.x;\r\n    closestPointY = lineEnd.y;\r\n  } else {\r\n    closestPointX = lineStart.x + t * dx;\r\n    closestPointY = lineStart.y + t * dy;\r\n  }\r\n\r\n  // Calculate the distance from the point to the closest point on the line segment\r\n  const distDx = point.x - closestPointX;\r\n  const distDy = point.y - closestPointY;\r\n  return Math.sqrt(distDx * distDx + distDy * distDy);\r\n\r\n  /* // Original implementation using area formula (distance to infinite line)\r\n  const lineLength = Math.sqrt(lineLengthSq);\r\n  const area = Math.abs(dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);\r\n  return area / lineLength;\r\n  */\r\n}\r\n\r\n/**\r\n * Creates a polygon approximation of a contour using RDP.\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} contourPoints - Array of points {x, y}\r\n * @param {number} epsilon - Epsilon for polygon approximation (relative to perimeter)\r\n * @returns {Array} Array of polygon points\r\n */\r\nexport function approximatePolygon(contourPoints, epsilon = 0.02) {\r\n  // Calculate contour perimeter\r\n  const perimeter = calculateContourPerimeter(contourPoints);\r\n\r\n  // Calculate epsilon based on perimeter\r\n  const actualEpsilon = epsilon * perimeter;\r\n\r\n  // Simplify the contour using RDP\r\n  const simplifiedPoints = simplifyContour(contourPoints, actualEpsilon);\r\n\r\n  return simplifiedPoints;\r\n}\r\n\r\n/**\r\n * Calculates the perimeter of a contour\r\n * (Helper for RDP approximatePolygon, keep if that function is kept)\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {number} Contour perimeter\r\n */\r\nfunction calculateContourPerimeter(points) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   let perimeter = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 2) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n; // Wrap around for the last segment\r\n    const dx = points[i].x - points[j].x;\r\n    const dy = points[i].y - points[j].y;\r\n    perimeter += Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\n// Flood fill is no longer used for contour detection\r\n/*\r\nfunction floodFill(edges, labels, width, height, startX, startY, label) {\r\n  // ... (original floodFill implementation removed) ...\r\n}\r\n*/","/**\r\n * Pure JavaScript implementation for detecting corners of a document\r\n * Replaces OpenCV's corner detection and point finding logic\r\n */\r\n\r\nimport { approximatePolygon } from './contourDetection.js';\r\n\r\n/**\r\n * Calculate distance between two points\r\n * @param {Object} p1 - First point {x, y}\r\n * @param {Object} p2 - Second point {x, y}\r\n * @returns {number} Distance between points\r\n */\r\nexport function distance(p1, p2) {\r\n  return Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n}\r\n\r\n/**\r\n * Find the center point of a contour\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Center point {x, y}\r\n */\r\nfunction findCenter(points) {\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  \r\n  for (const point of points) {\r\n    sumX += point.x;\r\n    sumY += point.y;\r\n  }\r\n  \r\n  return {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length\r\n  };\r\n}\r\n\r\n/**\r\n * Find the four corners of a document contour\r\n * @param {Object} contour - Contour object with points property\r\n * @param {Object} options - Configuration options\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nexport function findCornerPoints(contour, options = {}) {\r\n  if (!contour || !contour.points || contour.points.length < 4) {\r\n    console.warn('Contour does not have enough points for corner detection');\r\n    return null;\r\n  }\r\n  \r\n  // Try to find a quadrilateral approximation of the contour\r\n  const epsilon = options.epsilon || 0.02;\r\n  const approximation = approximatePolygon(contour, epsilon);\r\n  \r\n  let corners;\r\n  \r\n  // If we get exactly 4 points, we can use them as corners\r\n  if (approximation && approximation.length === 4) {\r\n    // console.log('Found 4-point approximation, using as corners');\r\n    corners = orderCornerPoints(approximation);\r\n  } else {\r\n    // console.log(`Polygon approximation gave ${approximation ? approximation.length : 'null'} points, using coordinate extremes method`);\r\n    // Fallback: Use the coordinate extremes method on the original contour points\r\n    corners = findCornersByCoordinateExtremes(contour.points); \r\n  }\r\n  \r\n  // Ensure all corners were found\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n      console.warn('Failed to find all four corners.', corners);\r\n      // Return null or partial corners? Returning null might be safer downstream.\r\n      return null; \r\n  }\r\n\r\n  return corners;\r\n}\r\n\r\n/**\r\n * Find corners by finding points with min/max coordinate sums/differences.\r\n * This is an alternative heuristic for finding corners.\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nfunction findCornersByCoordinateExtremes(points) {\r\n  if (!points || points.length === 0) return null;\r\n\r\n  let topLeft = points[0];      // Min sum x + y\r\n  let topRight = points[0];     // Max diff x - y\r\n  let bottomRight = points[0];  // Max sum x + y\r\n  let bottomLeft = points[0];   // Min diff x - y\r\n\r\n  let minSum = topLeft.x + topLeft.y;\r\n  let maxDiff = topRight.x - topRight.y;\r\n  let maxSum = bottomRight.x + bottomRight.y;\r\n  let minDiff = bottomLeft.x - bottomLeft.y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    const point = points[i];\r\n    const sum = point.x + point.y;\r\n    const diff = point.x - point.y;\r\n\r\n    // Top-Left (min sum)\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      topLeft = point;\r\n    }\r\n    // Bottom-Right (max sum)\r\n    if (sum > maxSum) {\r\n      maxSum = sum;\r\n      bottomRight = point;\r\n    }\r\n    // Top-Right (max diff)\r\n    if (diff > maxDiff) {\r\n      maxDiff = diff;\r\n      topRight = point;\r\n    }\r\n    // Bottom-Left (min diff)\r\n    if (diff < minDiff) {\r\n      minDiff = diff;\r\n      bottomLeft = point;\r\n    }\r\n  }\r\n\r\n  return {\r\n    topLeft,\r\n    topRight,\r\n    bottomRight,\r\n    bottomLeft\r\n  };\r\n}\r\n\r\n/**\r\n * Orders 4 points in clockwise order starting from top-left\r\n * @param {Array} points - Array of 4 points to order\r\n * @returns {Object} Object with ordered points\r\n */\r\nfunction orderCornerPoints(points) {\r\n  if (points.length !== 4) {\r\n    console.warn(`Expected 4 points, got ${points.length}`);\r\n    return null;\r\n  }\r\n  \r\n  // Calculate centroid\r\n  const center = findCenter(points);\r\n  \r\n  // Sort the points by their angles relative to the center\r\n  const sortedPoints = [...points].sort((a, b) => {\r\n    const angleA = Math.atan2(a.y - center.y, a.x - center.x);\r\n    const angleB = Math.atan2(b.y - center.y, b.x - center.x);\r\n    return angleA - angleB;\r\n  });\r\n  \r\n  // Now find the top-left point (minimum sum of x and y)\r\n  let minSum = Infinity;\r\n  let minIndex = 0;\r\n  \r\n  for (let i = 0; i < 4; i++) {\r\n    const sum = sortedPoints[i].x + sortedPoints[i].y;\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      minIndex = i;\r\n    }\r\n  }\r\n  \r\n  // Reorder array to start with the top-left point\r\n  const orderedPoints = [\r\n    sortedPoints[minIndex],\r\n    sortedPoints[(minIndex + 1) % 4],\r\n    sortedPoints[(minIndex + 2) % 4],\r\n    sortedPoints[(minIndex + 3) % 4]\r\n  ];\r\n  \r\n  // Return as named corners\r\n  return {\r\n    topLeft: orderedPoints[0],\r\n    topRight: orderedPoints[1],\r\n    bottomRight: orderedPoints[2],\r\n    bottomLeft: orderedPoints[3]\r\n  };\r\n}","let wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function blur(grayscale, width, height, kernel_size, sigma) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.blur(ptr0, len0, width, height, kernel_size, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Creates a binary edge image from the hysteresis edge map\n * SIMD-optimized version for converting edge map to binary\n *\n * # Arguments\n * * `edge_map` - Edge map from hysteresis thresholding (0, 1, 2 values)\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Uint8Array} edge_map\n * @returns {Uint8Array}\n */\nexport function edge_map_to_binary(edge_map) {\n    const ptr0 = passArray8ToWasm0(edge_map, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_map_to_binary(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Applies double thresholding and hysteresis using a stack-based approach.\n * Optimized version with SIMD for threshold comparisons and better memory access patterns.\n * Follows OpenCV's logic more closely.\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Edge map as Vec<u8> (0: weak edge/potential, 1: non-edge, 2: strong edge)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined hysteresis thresholding and binary conversion\n * This is a convenience function that combines both steps for efficiency\n * Optimized to avoid intermediate allocations where possible\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding_binary(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding_binary(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedInt16ArrayMemory0 = null;\n\nfunction getInt16ArrayMemory0() {\n    if (cachedInt16ArrayMemory0 === null || cachedInt16ArrayMemory0.byteLength === 0) {\n        cachedInt16ArrayMemory0 = new Int16Array(wasm.memory.buffer);\n    }\n    return cachedInt16ArrayMemory0;\n}\n\nfunction getArrayI16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n/**\n * @param {Uint8Array} blurred\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function calculate_gradients(blurred, width, height) {\n    const ptr0 = passArray8ToWasm0(blurred, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_gradients(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @returns {Uint8Array}\n */\nexport function dilate(edges, width, height, kernel_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate(ptr0, len0, width, height, kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint16ArrayMemory0 = null;\n\nfunction getUint16ArrayMemory0() {\n    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {\n        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16ArrayMemory0;\n}\n\nfunction passArray16ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 2, 2) >>> 0;\n    getUint16ArrayMemory0().set(arg, ptr / 2);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * @param {Int16Array} dx\n * @param {Int16Array} dy\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_gradient\n * @returns {Float32Array}\n */\nexport function non_maximum_suppression(dx, dy, width, height, l2_gradient) {\n    const ptr0 = passArray16ToWasm0(dx, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(dy, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.non_maximum_suppression(ptr0, len0, ptr1, len1, width, height, l2_gradient);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @param {number} kernel_size\n * @param {number} sigma\n * @param {boolean} l2_gradient\n * @param {boolean} apply_dilation\n * @param {number} dilation_kernel_size\n * @returns {Uint8Array}\n */\nexport function canny_edge_detector_full(grayscale, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.canny_edge_detector_full(ptr0, len0, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat32ArrayMemory0 = null;\n    cachedInt16ArrayMemory0 = null;\n    cachedUint16ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('wasm_blur_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","/**\r\n * Pure JavaScript implementation of edge detection algorithms\r\n * Inspired by OpenCV's Canny edge detector\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport init, { \r\n  blur as wasmBlur, \r\n  calculate_gradients as wasmGradients, \r\n  dilate as wasmDilate, \r\n  non_maximum_suppression as wasmMaximumSuppression, \r\n  canny_edge_detector_full as wasmFullCanny,\r\n  hysteresis_thresholding as wasmHysteresis,\r\n  hysteresis_thresholding_binary as wasmHysteresisBinary\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize the wasm module\r\nlet wasmReadyPromise = null;\r\n\r\n/**\r\n * Initializes the WASM module if not already initialized\r\n * @returns {Promise}\r\n */\r\nexport function initializeWasm() {\r\n  if (!wasmReadyPromise) {\r\n    wasmReadyPromise = init();\r\n  }\r\n  return wasmReadyPromise;\r\n}\r\n\r\n/**\r\n * Converts ImageData to grayscale (separate from blur for consistency with jscanify)\r\n * @param {ImageData} imageData - Original image data\r\n * @returns {Uint8ClampedArray} Grayscale image data (1 channel)\r\n */\r\nexport function convertToGrayscale(imageData) {\r\n  const { width, height, data } = imageData;\r\n  const grayscale = new Uint8ClampedArray(width * height);\r\n  \r\n  // Convert to grayscale with integer math (faster than floating point)\r\n  // Use bit shifting for multiplication (>>8 is equivalent to /256)\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    // 54 (~0.2126*256), 183 (~0.7152*256), 19 (~0.0722*256)\r\n    grayscale[j] = (data[i] * 54 + data[i+1] * 183 + data[i+2] * 19) >> 8;\r\n  }\r\n  \r\n  return grayscale;\r\n}\r\n\r\n/**\r\n * Applies Gaussian blur to a grayscale image (matching jscanify's approach)\r\n * @param {Uint8ClampedArray} grayscale - Grayscale image data\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (should be 5 to match jscanify)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data\r\n */\r\nexport function gaussianBlurGrayscale(grayscale, width, height, kernelSize = 5, sigma = 0) {\r\n  // If sigma is 0, calculate it from kernel size (OpenCV default)\r\n  if (sigma === 0) {\r\n    sigma = 0.3 * ((kernelSize - 1) * 0.5 - 1) + 0.8;\r\n  }\r\n  \r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  \r\n  // Create and normalize Gaussian kernel once\r\n  const kernel = createGaussianKernel(kernelSize, sigma);\r\n  \r\n  // Preallocate arrays\r\n  const tempArray = new Uint8ClampedArray(width * height);\r\n  const blurred = new Uint8ClampedArray(width * height);\r\n  \r\n  // Horizontal pass - process rows in a single loop to improve cache locality\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel horizontally with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const xOffset = Math.min(width - 1, Math.max(0, x + k));\r\n        sum += grayscale[rowOffset + xOffset] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      tempArray[rowOffset + x] = sum;\r\n    }\r\n  }\r\n  \r\n  // Vertical pass - process columns with better memory access pattern\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel vertically with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const yOffset = Math.min(height - 1, Math.max(0, y + k));\r\n        sum += tempArray[yOffset * width + x] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      blurred[y * width + x] = Math.round(sum);\r\n    }\r\n  }\r\n  \r\n  return blurred;\r\n}\r\n\r\n/**\r\n * Legacy wrapper for backwards compatibility\r\n * @param {ImageData} imageData - Original image data\r\n * @param {number} sigma - Gaussian sigma parameter (standard deviation)\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data (1 channel)\r\n */\r\nexport function gaussianBlur(imageData, sigma = DEFAULTS.GAUSSIAN_SIGMA, forcedKernelSize = null) {\r\n  const grayscale = convertToGrayscale(imageData);\r\n  const kernelSize = forcedKernelSize || 5; // Default to 5 like jscanify\r\n  return gaussianBlurGrayscale(grayscale, imageData.width, imageData.height, kernelSize, sigma);\r\n}\r\n\r\n/**\r\n * Creates a 1D Gaussian kernel\r\n * @param {number} size - Kernel size (odd number)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Float32Array} Gaussian kernel\r\n */\r\nfunction createGaussianKernel(size, sigma) {\r\n  const kernel = new Float32Array(size);\r\n  const halfSize = Math.floor(size / 2);\r\n  \r\n  let sum = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const x = i - halfSize;\r\n    // Gaussian function: (1/(sigma*sqrt(2*PI))) * e^(-(x^2)/(2*sigma^2))\r\n    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));\r\n    sum += kernel[i];\r\n  }\r\n  \r\n  // Normalize kernel\r\n  for (let i = 0; i < size; i++) {\r\n    kernel[i] /= sum;\r\n  }\r\n  \r\n  return kernel;\r\n}\r\n\r\n/**\r\n * Calculates the gradients (dx, dy) using Sobel operators\r\n * @param {Uint8ClampedArray} blurred - Blurred grayscale image\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @returns {{dx: Int16Array, dy: Int16Array}} Object containing gradient arrays\r\n */\r\nfunction calculateGradients(blurred, width, height) {\r\n  // Use Int16Array to store gradients, allowing negative values\r\n  const dx = new Int16Array(width * height);\r\n  const dy = new Int16Array(width * height);\r\n  \r\n  // Find gradients by unrolling the Sobel operator loops\r\n  for (let y = 1; y < height - 1; y++) {\r\n    const rowOffset = y * width;\r\n    const prevRowOffset = (y - 1) * width;\r\n    const nextRowOffset = (y + 1) * width;\r\n\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const currentIdx = rowOffset + x;\r\n\r\n      // Get neighborhood pixels\r\n      const p0 = blurred[prevRowOffset + x - 1];\r\n      const p1 = blurred[prevRowOffset + x];\r\n      const p2 = blurred[prevRowOffset + x + 1];\r\n      const p3 = blurred[rowOffset + x - 1];\r\n      const p5 = blurred[rowOffset + x + 1];\r\n      const p6 = blurred[nextRowOffset + x - 1];\r\n      const p7 = blurred[nextRowOffset + x];\r\n      const p8 = blurred[nextRowOffset + x + 1];\r\n      \r\n      // Calculate Sobel gradients\r\n      const gx = (p2 - p0) + 2 * (p5 - p3) + (p8 - p6);\r\n      const gy = (p6 + 2 * p7 + p8) - (p0 + 2 * p1 + p2);\r\n      \r\n      dx[currentIdx] = gx;\r\n      dy[currentIdx] = gy;\r\n    }\r\n  }\r\n  \r\n  return { dx, dy };\r\n}\r\n\r\n\r\n/**\r\n * Applies non-maximum suppression to the gradient magnitude\r\n * @param {Int16Array} dx - Gradient in x-direction\r\n * @param {Int16Array} dy - Gradient in y-direction\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {boolean} L2gradient - Whether to use L2 norm for magnitude\r\n * @returns {Float32Array} Suppressed magnitude (using Float32 for precision)\r\n */\r\nfunction nonMaximumSuppression(dx, dy, width, height, L2gradient) {\r\n  // Use Float32Array for magnitude to preserve precision before thresholding\r\n  const magnitude = new Float32Array(width * height);\r\n  const suppressed = new Float32Array(width * height);\r\n  \r\n  // Calculate magnitude for all pixels first\r\n  for (let i = 0; i < dx.length; i++) {\r\n    const gx = dx[i];\r\n    const gy = dy[i];\r\n    if (L2gradient) {\r\n      magnitude[i] = Math.sqrt(gx * gx + gy * gy);\r\n    } else {\r\n      magnitude[i] = Math.abs(gx) + Math.abs(gy); // L1 norm\r\n    }\r\n  }\r\n  \r\n  // Perform non-maximum suppression\r\n  for (let y = 1; y < height - 1; y++) {\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = magnitude[idx];\r\n      \r\n      // Skip pixels with zero magnitude\r\n      if (mag === 0) {\r\n        suppressed[idx] = 0;\r\n        continue;\r\n      }\r\n      \r\n      const gx = dx[idx];\r\n      const gy = dy[idx];\r\n      \r\n      let neighbor1 = 0, neighbor2 = 0;\r\n      \r\n      // Determine neighbors based on gradient direction\r\n      // Use absolute values to determine dominant direction\r\n      const absGx = Math.abs(gx);\r\n      const absGy = Math.abs(gy);\r\n      \r\n      if (absGy > absGx * 2.4142) { // Vertical edge (angle near 90 or 270)\r\n        neighbor1 = magnitude[idx - width]; // top\r\n        neighbor2 = magnitude[idx + width]; // bottom\r\n      } else if (absGx > absGy * 2.4142) { // Horizontal edge (angle near 0 or 180)\r\n        neighbor1 = magnitude[idx - 1]; // left\r\n        neighbor2 = magnitude[idx + 1]; // right\r\n      } else { // Diagonal edge\r\n        // Determine diagonal direction based on signs of gx and gy\r\n        const s = (gx ^ gy) < 0 ? -1 : 1; // Check if signs are different\r\n        if (gy > 0) { // Gradient points down\r\n          neighbor1 = magnitude[(y - 1) * width + (x - s)]; // top-left/right\r\n          neighbor2 = magnitude[(y + 1) * width + (x + s)]; // bottom-right/left\r\n        } else { // Gradient points up\r\n          neighbor1 = magnitude[(y + 1) * width + (x - s)]; // bottom-left/right\r\n          neighbor2 = magnitude[(y - 1) * width + (x + s)]; // top-right/left\r\n        }\r\n        // Refined diagonal check (approximating OpenCV's logic)\r\n        // Check 45 degrees (top-right / bottom-left)\r\n        if ((gx > 0 && gy > 0) || (gx < 0 && gy < 0)) { // Quadrants 1 & 3\r\n             neighbor1 = magnitude[(y - 1) * width + (x + 1)]; // top-right\r\n             neighbor2 = magnitude[(y + 1) * width + (x - 1)]; // bottom-left\r\n        } else { // Quadrants 2 & 4 (135 degrees)\r\n             neighbor1 = magnitude[(y - 1) * width + (x - 1)]; // top-left\r\n             neighbor2 = magnitude[(y + 1) * width + (x + 1)]; // bottom-right\r\n        }\r\n      }\r\n      \r\n      // If the pixel's magnitude is greater than or equal to its neighbors\r\n      // along the gradient direction, keep it. Otherwise, suppress it.\r\n      if (mag >= neighbor1 && mag >= neighbor2) {\r\n        suppressed[idx] = mag;\r\n      } else {\r\n        suppressed[idx] = 0;\r\n      }\r\n    }\r\n  }\r\n  return suppressed;\r\n}\r\n\r\n\r\n/**\r\n * Applies double thresholding and hysteresis using a stack-based approach.\r\n * Follows OpenCV's logic more closely.\r\n * @param {Float32Array} suppressed - Suppressed magnitude (Float32Array)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} lowThreshold - Low threshold value\r\n * @param {number} highThreshold - High threshold value\r\n * @returns {Uint8Array} Edge map (0: non-edge, 2: edge pixel)\r\n */\r\nfunction hysteresisThresholding(suppressed, width, height, lowThreshold, highThreshold) {\r\n  // Map values: 0 = weak edge (potential), 1 = non-edge, 2 = strong edge\r\n  const edgeMap = new Uint8Array(width * height);\r\n  const stack = [];\r\n  \r\n  // First pass: Identify strong edges and potential weak edges\r\n  for (let y = 1; y < height - 1; y++) { // Iterate excluding borders\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = suppressed[idx];\r\n      \r\n      if (mag >= highThreshold) {\r\n        // Strong edge pixel\r\n        edgeMap[idx] = 2;\r\n        stack.push({ x, y });\r\n      } else if (mag >= lowThreshold) {\r\n        // Weak edge pixel (potential edge)\r\n        edgeMap[idx] = 0; // Mark as potential\r\n      } else {\r\n        // Non-edge pixel\r\n        edgeMap[idx] = 1; // Mark as non-edge\r\n      }\r\n    }\r\n  }\r\n  // Initialize borders as non-edge (value 1)\r\n   for (let x = 0; x < width; x++) {\r\n       edgeMap[x] = 1; // Top row\r\n       edgeMap[(height - 1) * width + x] = 1; // Bottom row\r\n   }\r\n   for (let y = 1; y < height - 1; y++) {\r\n       edgeMap[y * width] = 1; // Left column\r\n       edgeMap[y * width + width - 1] = 1; // Right column\r\n   }\r\n\r\n\r\n  // Second pass: Hysteresis - connect weak edges to strong edges\r\n  const dxNeighbors = [-1, 0, 1, -1, 1, -1, 0, 1];\r\n  const dyNeighbors = [-1, -1, -1, 0, 0, 1, 1, 1];\r\n  \r\n  while (stack.length > 0) {\r\n    const { x, y } = stack.pop();\r\n    \r\n    // Check all 8 neighbors\r\n    for (let i = 0; i < 8; i++) {\r\n      const nx = x + dxNeighbors[i];\r\n      const ny = y + dyNeighbors[i];\r\n      const nidx = ny * width + nx;\r\n      \r\n      // Check bounds (already handled by border initialization)\r\n      // If neighbor is a weak edge (value 0), promote it to strong (value 2) and add to stack\r\n      if (edgeMap[nidx] === 0) {\r\n        edgeMap[nidx] = 2; // Promote to strong edge\r\n        stack.push({ x: nx, y: ny });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Note: Pixels that were initially weak (0) but not connected remain 0.\r\n  // Pixels below lowThreshold remain 1. Only pixels marked 2 are considered final edges.\r\n  \r\n  return edgeMap; // Return the map with 0, 1, 2 values\r\n}\r\n\r\n/**\r\n * Applies morphological dilation to binary image using a separable (two-pass) approach.\r\n * This is much faster than a 2D kernel for square structuring elements.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (0 or 255)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (default 5 to match jscanify)\r\n * @returns {Uint8ClampedArray} Dilated edge image\r\n */\r\nexport function dilateEdges(edges, width, height, kernelSize = 5) {\r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  const temp = new Uint8ClampedArray(width * height);\r\n  const dilated = new Uint8ClampedArray(width * height);\r\n\r\n  // Horizontal pass\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    for (let x = 0; x < width; x++) {\r\n      let maxVal = 0;\r\n      // Find max in horizontal neighborhood\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const nx = x + k;\r\n        if (nx >= 0 && nx < width) {\r\n          const val = edges[rowOffset + nx];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      temp[rowOffset + x] = maxVal;\r\n    }\r\n  }\r\n\r\n  // Vertical pass\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let maxVal = 0;\r\n      // Find max in vertical neighborhood from temp array\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const ny = y + k;\r\n        if (ny >= 0 && ny < height) {\r\n          const val = temp[ny * width + x];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      dilated[y * width + x] = maxVal;\r\n    }\r\n  }\r\n  \r\n  return dilated;\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation matching jscanify's approach\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.lowThreshold=75] - Low threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.highThreshold=200] - High threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.sigma=0] - Gaussian blur sigma (0 means auto-calculate from kernel size)\r\n * @param {number} [options.kernelSize=5] - Gaussian kernel size (matching jscanify)\r\n * @param {boolean} [options.L2gradient=false] - Use L2 norm for gradient magnitude (like OpenCV default)\r\n * @param {boolean} [options.applyDilation=true] - Apply dilation after Canny (matching jscanify)\r\n * @param {number} [options.dilationKernelSize=5] - Dilation kernel size\r\n * @param {boolean} [options.useWasmBlur=false] - Use WASM for Gaussian blur\r\n * @param {boolean} [options.useWasmGradients=false] - Use WASM for gradient calculation\r\n * @param {boolean} [options.useWasmDilation=false] - Use WASM for dilation\r\n * @param {boolean} [options.useWasmNMS=false] - Use WASM for non-maximum suppression\r\n * @param {boolean} [options.useWasmHysteresis=false] - Use WASM for hysteresis thresholding\r\n * @param {boolean} [options.useWasmFullCanny=false] - Use the full WASM Canny implementation\r\n * @param {object} [options.debug={}] - Object to store intermediate results if provided\r\n * @param {boolean} [options.skipGrayscale=false] - Skip grayscale conversion (input is already grayscale Uint8ClampedArray)\r\n * @param {number} [options.width] - Image width (required if skipGrayscale is true)\r\n * @param {number} [options.height] - Image height (required if skipGrayscale is true)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetector(input, options = {}) {\r\n  // Timing table setup\r\n  const timings = [];\r\n  const tStart = performance.now();\r\n\r\n  // Handle both ImageData and pre-computed grayscale Uint8ClampedArray\r\n  const skipGrayscale = options.skipGrayscale || false;\r\n  let width, height, grayscale;\r\n  \r\n  if (skipGrayscale) {\r\n    // Input is already grayscale Uint8ClampedArray\r\n    width = options.width;\r\n    height = options.height;\r\n    grayscale = input;\r\n    if (options.debug) options.debug.grayscale = grayscale;\r\n  } else {\r\n    // Input is ImageData - extract dimensions and convert to grayscale\r\n    width = input.width;\r\n    height = input.height;\r\n    \r\n    let t0 = performance.now();\r\n    grayscale = convertToGrayscale(input);\r\n    let t1 = performance.now();\r\n    timings.push({ step: 'Grayscale', ms: (t1 - t0).toFixed(2) });\r\n    if (options.debug) options.debug.grayscale = grayscale;\r\n  }\r\n\r\n  let lowThreshold = options.lowThreshold !== undefined ? options.lowThreshold : 75;\r\n  let highThreshold = options.highThreshold !== undefined ? options.highThreshold : 200;\r\n  const kernelSize = options.kernelSize || 5; // Match jscanify's 5x5 kernel\r\n  const sigma = options.sigma || 0; // Let the blur function calculate sigma\r\n  const L2gradient = options.L2gradient === undefined ? false : options.L2gradient;\r\n  const applyDilation = options.applyDilation !== undefined ? options.applyDilation : true;\r\n  const dilationKernelSize = options.dilationKernelSize || 5;\r\n  const useWasmBlur = true;\r\n  const useWasmGradients = false; \r\n  const useWasmDilation = true;\r\n  const useWasmNMS = true;\r\n  const useWasmHysteresis = options.useWasmHysteresis !== undefined ? options.useWasmHysteresis : false;\r\n  const useWasmFullCanny = false;\r\n\r\n  // Ensure high threshold is greater than low threshold\r\n  if (lowThreshold >= highThreshold) {\r\n      console.warn(`Canny Edge Detector: lowThreshold (${lowThreshold}) should be lower than highThreshold (${highThreshold}). Swapping them.`);\r\n      [lowThreshold, highThreshold] = [highThreshold, lowThreshold];\r\n  }\r\n\r\n  // Timing variables\r\n  let t0, t1;\r\n\r\n  // Step 2: Apply Gaussian blur (JS or WASM)\r\n  let blurred;\r\n  t0 = performance.now();\r\n  if (useWasmBlur) {\r\n    try {\r\n      await initializeWasm(); // Ensure wasm is initialized\r\n      blurred = wasmBlur(grayscale, width, height, kernelSize, sigma);\r\n    } catch (e) {\r\n      blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n    }\r\n  } else {\r\n    blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gaussian Blur', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) {\r\n    options.debug.blurred = blurred;\r\n  }\r\n\r\n  // Step 3: Compute gradients (dx, dy)\r\n  t0 = performance.now();\r\n  let dx, dy;\r\n  if (useWasmGradients) {\r\n    try {\r\n      await initializeWasm(); // Ensure wasm is initialized\r\n      const gradientResult = wasmGradients(blurred, width, height);\r\n      dx = new Int16Array(gradientResult.gx);\r\n      dy = new Int16Array(gradientResult.gy);\r\n    } catch (e) {\r\n      const gradients = calculateGradients(blurred, width, height);\r\n      dx = gradients.dx;\r\n      dy = gradients.dy;\r\n    }\r\n  } else {\r\n    const gradients = calculateGradients(blurred, width, height);\r\n    dx = gradients.dx;\r\n    dy = gradients.dy;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gradients', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 4: Apply non-maximum suppression\r\n  t0 = performance.now();\r\n  let suppressed;\r\n  if (useWasmNMS) {\r\n    try {\r\n      await initializeWasm();\r\n      suppressed = await wasmMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    } catch (e) {\r\n      suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    }\r\n  } else {\r\n    suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Non-Max Suppression', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 5: Apply double thresholding and hysteresis\r\n  t0 = performance.now();\r\n  const finalLowThreshold = L2gradient ? lowThreshold * lowThreshold : lowThreshold;\r\n  const finalHighThreshold = L2gradient ? highThreshold * highThreshold : highThreshold;\r\n  \r\n  let edgeMap;\r\n  if (useWasmHysteresis) {\r\n    try {\r\n      await initializeWasm();\r\n      edgeMap = wasmHysteresis(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    } catch (e) {\r\n      console.warn(\"WASM hysteresis failed, falling back to JS:\", e);\r\n      edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    }\r\n  } else {\r\n    edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n  }\r\n  \r\n  t1 = performance.now();\r\n  timings.push({ step: 'Hysteresis', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 6: Create binary image (0 or 255)\r\n  t0 = performance.now();\r\n  const cannyEdges = new Uint8ClampedArray(width * height);\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    cannyEdges[i] = edgeMap[i] === 2 ? 255 : 0;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Binary Image', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 7: Apply dilation if requested (matching jscanify)\r\n  t0 = performance.now();\r\n  let finalEdges = cannyEdges;\r\n  if (applyDilation) {\r\n    if (useWasmDilation) {\r\n      try {\r\n        await initializeWasm(); // Ensure wasm is initialized\r\n        finalEdges = wasmDilate(cannyEdges, width, height, dilationKernelSize);\r\n      } catch (e) {\r\n        finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n      }\r\n    } else {\r\n      finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n    }\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Dilation', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.dx = dx; // Int16Array\r\n    options.debug.dy = dy; // Int16Array\r\n    // Calculate magnitude separately for debugging if needed\r\n     const magnitude = new Float32Array(width * height);\r\n     for (let i = 0; i < dx.length; i++) {\r\n         const gx = dx[i]; const gy = dy[i];\r\n         magnitude[i] = L2gradient ? Math.sqrt(gx * gx + gy * gy) : Math.abs(gx) + Math.abs(gy);\r\n     }\r\n     options.debug.magnitude = magnitude; // Float32Array (raw magnitude)\r\n    options.debug.suppressed = suppressed; // Float32Array (after NMS)\r\n    options.debug.edgeMap = edgeMap; // Uint8Array (0, 1, 2 values from hysteresis)\r\n    options.debug.cannyEdges = cannyEdges; // Uint8ClampedArray (0 or 255, before dilation)\r\n    options.debug.finalEdges = finalEdges; // Uint8ClampedArray (0 or 255, after dilation if applied)\r\n  }\r\n  \r\n  // Always store timings in debug object (create minimal one if needed)\r\n  if (options.debug) {\r\n    options.debug.timings = timings;\r\n  } else if (!options.debug) {\r\n    // Create a minimal debug object just for timings if none provided\r\n    options.debug = { timings: timings };\r\n  }\r\n\r\n  const tEnd = performance.now();\r\n  timings.unshift({ step: 'Edge Detection Total', ms: (tEnd - tStart).toFixed(2) });\r\n  // Timings available via options.debug.timings\r\n\r\n  return finalEdges; // Return the final binary edge image\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation using WASM, for comparison or direct use\r\n * This function is intended to match the performance and output of the JS cannyEdgeDetector,\r\n * but runs entirely in WASM for potentially faster execution.\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options (same as cannyEdgeDetector)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetectorWasm(imageData, options = {}) {\r\n  // Directly call the WASM canny_edge_detector_full function\r\n  let result;\r\n  try {\r\n    await initializeWasm(); // Ensure wasm is initialized\r\n    console.log('Using WASM Full Canny');\r\n    result = wasmFullCanny(imageData.data, imageData.width, imageData.height, options.lowThreshold, options.highThreshold, options.sigma, options.kernelSize, options.L2gradient, options.applyDilation, options.dilationKernelSize);\r\n  } catch (e) {\r\n    console.error(\"WASM full Canny failed:\", e);\r\n    throw e; // Rethrow to let the caller handle the error\r\n  }\r\n  \r\n  // Convert result to Uint8ClampedArray (if not already)\r\n  const edges = new Uint8ClampedArray(result);\r\n  \r\n  return edges;\r\n}","/**\r\n * scanic\r\n * JavaScript document scanner without OpenCV dependency\r\n * MIT License\r\n */\r\n\r\n\r\nimport { detectDocumentContour } from './contourDetection.js';\r\nimport { findCornerPoints } from './cornerDetection.js';\r\nimport { cannyEdgeDetector, initializeWasm } from './edgeDetection.js';\r\n\r\n/**\r\n * Global initialization helper for convenience.\r\n */\r\nexport async function initialize() {\r\n  return await initializeWasm();\r\n}\r\n\r\n/**\r\n * Unified Scanner class for better state and configuration management.\r\n */\r\nexport class Scanner {\r\n  constructor(options = {}) {\r\n    this.defaultOptions = {\r\n      maxProcessingDimension: 800,\r\n      mode: 'detect',\r\n      output: 'canvas',\r\n      ...options\r\n    };\r\n    this.initialized = false;\r\n  }\r\n\r\n  /**\r\n   * Warm up the scanner (load WASM, etc.)\r\n   */\r\n  async initialize() {\r\n    if (this.initialized) return;\r\n    await initializeWasm();\r\n    this.initialized = true;\r\n  }\r\n\r\n  /**\r\n   * Scan an image for a document.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image \r\n   * @param {Object} options Override default options\r\n   */\r\n  async scan(image, options = {}) {\r\n    if (!this.initialized) await this.initialize();\r\n    const combinedOptions = { ...this.defaultOptions, ...options };\r\n    return await scanDocument(image, combinedOptions);\r\n  }\r\n\r\n  /**\r\n   * Extract a document from an image using manual corners.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image \r\n   * @param {Object} corners \r\n   * @param {Object} options \r\n   */\r\n  async extract(image, corners, options = {}) {\r\n    if (!this.initialized) await this.initialize();\r\n    const combinedOptions = { ...this.defaultOptions, ...options };\r\n    return await extractDocument(image, corners, combinedOptions);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Prepares image, downscales, and converts to grayscale in a single operation.\r\n * Uses OffscreenCanvas and CSS filters for maximum performance.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image - Input image\r\n * @param {number} maxDimension - Maximum dimension for processing (default 800)\r\n * @returns {Promise<Object>} { grayscaleData, scaleFactor, originalDimensions, scaledDimensions }\r\n */\r\nasync function prepareScaleAndGrayscale(image, maxDimension = 800) {\r\n  let originalWidth, originalHeight;\r\n  \r\n  // Robust check for ImageData without relying on global ImageData class\r\n  const isImageData = image && typeof image.width === 'number' && typeof image.height === 'number' && image.data;\r\n\r\n  // Get original dimensions\r\n  if (isImageData) {\r\n    originalWidth = image.width;\r\n    originalHeight = image.height;\r\n  } else if (image) {\r\n    originalWidth = image.width || image.naturalWidth;\r\n    originalHeight = image.height || image.naturalHeight;\r\n  } else {\r\n    throw new Error('No image provided');\r\n  }\r\n  \r\n  const maxCurrentDimension = Math.max(originalWidth, originalHeight);\r\n  \r\n  // Calculate target dimensions\r\n  let targetWidth, targetHeight, scaleFactor;\r\n  \r\n  if (maxCurrentDimension <= maxDimension) {\r\n    targetWidth = originalWidth;\r\n    targetHeight = originalHeight;\r\n    scaleFactor = 1;\r\n  } else {\r\n    const scale = maxDimension / maxCurrentDimension;\r\n    targetWidth = Math.round(originalWidth * scale);\r\n    targetHeight = Math.round(originalHeight * scale);\r\n    scaleFactor = 1 / scale;\r\n  }\r\n  \r\n  // Use OffscreenCanvas if available (faster, no DOM interaction)\r\n  const useOffscreen = typeof OffscreenCanvas !== 'undefined';\r\n  const canvas = useOffscreen \r\n    ? new OffscreenCanvas(targetWidth, targetHeight)\r\n    : document.createElement('canvas');\r\n  \r\n  if (!useOffscreen) {\r\n    canvas.width = targetWidth;\r\n    canvas.height = targetHeight;\r\n  }\r\n  \r\n  const ctx = canvas.getContext('2d', { willReadFrequently: true });\r\n  \r\n  // Apply grayscale filter during draw - GPU accelerated!\r\n  ctx.filter = 'grayscale(1)';\r\n  ctx.imageSmoothingEnabled = true;\r\n  ctx.imageSmoothingQuality = 'medium';\r\n  \r\n  if (isImageData) {\r\n    // For ImageData, need to put on temp canvas first\r\n    const tempCanvas = useOffscreen\r\n      ? new OffscreenCanvas(originalWidth, originalHeight)\r\n      : document.createElement('canvas');\r\n    if (!useOffscreen) {\r\n      tempCanvas.width = originalWidth;\r\n      tempCanvas.height = originalHeight;\r\n    }\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    tempCtx.putImageData(image, 0, 0);\r\n    ctx.drawImage(tempCanvas, 0, 0, originalWidth, originalHeight, 0, 0, targetWidth, targetHeight);\r\n  } else {\r\n    // Direct draw with scaling + grayscale filter\r\n    ctx.drawImage(image, 0, 0, originalWidth, originalHeight, 0, 0, targetWidth, targetHeight);\r\n  }\r\n  \r\n  // Get the grayscale image data\r\n  const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);\r\n  \r\n  // Extract single-channel grayscale (R=G=B after filter, so just take R)\r\n  const grayscaleData = new Uint8ClampedArray(targetWidth * targetHeight);\r\n  const data = imageData.data;\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    grayscaleData[j] = data[i]; // R channel (same as G and B after grayscale filter)\r\n  }\r\n  \r\n  return {\r\n    grayscaleData,\r\n    imageData, // Keep full RGBA for debug visualization\r\n    scaleFactor,\r\n    originalDimensions: { width: originalWidth, height: originalHeight },\r\n    scaledDimensions: { width: targetWidth, height: targetHeight }\r\n  };\r\n}\r\n\r\n// Internal function to detect document in image\r\n// Now accepts pre-computed grayscale data (from prepareScaleAndGrayscale)\r\nasync function detectDocumentInternal(grayscaleData, width, height, scaleFactor, options = {}) {\r\n  // Always create a debug object to collect timings (even if not in debug mode)\r\n  const debugInfo = options.debug ? {} : { _timingsOnly: true };\r\n  const timings = [];\r\n  \r\n  if (debugInfo && !debugInfo._timingsOnly) {\r\n    debugInfo.preprocessing = {\r\n      scaledDimensions: { width, height },\r\n      scaleFactor,\r\n      maxProcessingDimension: options.maxProcessingDimension || 800\r\n    };\r\n  }\r\n  \r\n  // Run edge detection on pre-computed grayscale data (skip grayscale conversion)\r\n  const edges = await cannyEdgeDetector(grayscaleData, {\r\n    width,\r\n    height,\r\n    lowThreshold: options.lowThreshold || 75,   // Match OpenCV values\r\n    highThreshold: options.highThreshold || 200, // Match OpenCV values\r\n    dilationKernelSize: options.dilationKernelSize || 3, // Match OpenCV value \r\n    dilationIterations: options.dilationIterations || 1,\r\n    debug: debugInfo,\r\n    skipGrayscale: true, // Skip grayscale - already done in prep\r\n    useWasmBlur: true,\r\n  });\r\n  \r\n  // Extract edge detection timings (skip the 'Total' entry)\r\n  if (debugInfo.timings) {\r\n    debugInfo.timings.forEach(t => {\r\n      if (t.step !== 'Edge Detection Total') timings.push(t);\r\n    });\r\n  }\r\n  \r\n  // Detect contours from edges\r\n  let t0 = performance.now();\r\n  const contours = detectDocumentContour(edges, {\r\n    minArea: (options.minArea || 1000) / (scaleFactor * scaleFactor), // Adjust minArea for scaled image\r\n    debug: debugInfo,\r\n    width: width,     \r\n    height: height    \r\n  });\r\n  timings.push({ step: 'Find Contours', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (!contours || contours.length === 0) {\r\n    console.log('No document detected');\r\n    return {\r\n      success: false,\r\n      message: 'No document detected',\r\n      debug: debugInfo._timingsOnly ? null : debugInfo,\r\n      timings: timings\r\n    };\r\n  }\r\n  \r\n  // Get the largest contour which is likely the document\r\n  const documentContour = contours[0]; \r\n  \r\n  // Find corner points on the scaled image\r\n  t0 = performance.now();\r\n  const cornerPoints = findCornerPoints(documentContour, { \r\n      epsilon: options.epsilon // Pass epsilon for approximation\r\n  });\r\n  timings.push({ step: 'Corner Detection', ms: (performance.now() - t0).toFixed(2) });\r\n  \r\n  // Scale corner points back to original image size\r\n  let finalCorners = cornerPoints;\r\n  if (scaleFactor !== 1) {\r\n    finalCorners = {\r\n      topLeft: { x: cornerPoints.topLeft.x * scaleFactor, y: cornerPoints.topLeft.y * scaleFactor },\r\n      topRight: { x: cornerPoints.topRight.x * scaleFactor, y: cornerPoints.topRight.y * scaleFactor },\r\n      bottomRight: { x: cornerPoints.bottomRight.x * scaleFactor, y: cornerPoints.bottomRight.y * scaleFactor },\r\n      bottomLeft: { x: cornerPoints.bottomLeft.x * scaleFactor, y: cornerPoints.bottomLeft.y * scaleFactor },\r\n    };\r\n  }\r\n  \r\n  // Return the result, scaling the contour points back up as well\r\n  return {\r\n    success: true,\r\n    contour: documentContour,\r\n    corners: finalCorners,\r\n    debug: debugInfo._timingsOnly ? null : debugInfo,\r\n    timings: timings\r\n  };\r\n}\r\n\r\n// --- Perspective transform helpers (internal use only) ---\r\nfunction getPerspectiveTransform(srcPoints, dstPoints) {\r\n  // Helper to build the system of equations\r\n  function buildMatrix(points) {\r\n    const matrix = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      const [x, y] = points[i];\r\n      matrix.push([x, y, 1, 0, 0, 0, -x * dstPoints[i][0], -y * dstPoints[i][0]]);\r\n      matrix.push([0, 0, 0, x, y, 1, -x * dstPoints[i][1], -y * dstPoints[i][1]]);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  const A = buildMatrix(srcPoints);\r\n  const b = [\r\n    dstPoints[0][0], dstPoints[0][1],\r\n    dstPoints[1][0], dstPoints[1][1],\r\n    dstPoints[2][0], dstPoints[2][1],\r\n    dstPoints[3][0], dstPoints[3][1]\r\n  ];\r\n\r\n  // Solve Ah = b for h (h is 8x1, last element is 1)\r\n  // Use Gaussian elimination or Cramer's rule for 8x8\r\n  // For simplicity, use numeric.js if available, else implement basic solver\r\n  function solve(A, b) {\r\n    // Gaussian elimination for 8x8\r\n    const m = A.length;\r\n    const n = A[0].length;\r\n    const M = A.map(row => row.slice());\r\n    const B = b.slice();\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      // Find max row\r\n      let maxRow = i;\r\n      for (let k = i + 1; k < m; k++) {\r\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\r\n      }\r\n      // Swap rows\r\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\r\n      [B[i], B[maxRow]] = [B[maxRow], B[i]];\r\n\r\n      // Eliminate\r\n      for (let k = i + 1; k < m; k++) {\r\n        const c = M[k][i] / M[i][i];\r\n        for (let j = i; j < n; j++) {\r\n          M[k][j] -= c * M[i][j];\r\n        }\r\n        B[k] -= c * B[i];\r\n      }\r\n    }\r\n\r\n    // Back substitution\r\n    const x = new Array(n);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      let sum = B[i];\r\n      for (let j = i + 1; j < n; j++) {\r\n        sum -= M[i][j] * x[j];\r\n      }\r\n      x[i] = sum / M[i][i];\r\n    }\r\n    return x;\r\n  }\r\n\r\n  const h = solve(A, b);\r\n  // h is [h0,h1,h2,h3,h4,h5,h6,h7], h8 = 1\r\n  const matrix = [\r\n    [h[0], h[1], h[2]],\r\n    [h[3], h[4], h[5]],\r\n    [h[6], h[7], 1]\r\n  ];\r\n  return matrix;\r\n}\r\n\r\n\r\n\r\n\r\nfunction unwarpImage(ctx, image, corners) {\r\n  // Get perspective transform matrix\r\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners;\r\n  // Compute output rectangle size\r\n  const widthA = Math.hypot(bottomRight.x - bottomLeft.x, bottomRight.y - bottomLeft.y);\r\n  const widthB = Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\r\n  const maxWidth = Math.round(Math.max(widthA, widthB));\r\n  const heightA = Math.hypot(topRight.x - bottomRight.x, topRight.y - bottomRight.y);\r\n  const heightB = Math.hypot(topLeft.x - bottomLeft.x, topLeft.y - bottomLeft.y);\r\n  const maxHeight = Math.round(Math.max(heightA, heightB));\r\n\r\n  // Set output canvas size\r\n  ctx.canvas.width = maxWidth;\r\n  ctx.canvas.height = maxHeight;\r\n\r\n  const srcPoints = [\r\n    [topLeft.x, topLeft.y],\r\n    [topRight.x, topRight.y],\r\n    [bottomRight.x, bottomRight.y],\r\n    [bottomLeft.x, bottomLeft.y]\r\n  ];\r\n  const dstPoints = [\r\n    [0, 0],\r\n    [maxWidth - 1, 0],\r\n    [maxWidth - 1, maxHeight - 1],\r\n    [0, maxHeight - 1]\r\n  ];\r\n  const perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);\r\n  warpTransform(ctx, image, perspectiveMatrix, maxWidth, maxHeight);\r\n}\r\n\r\nfunction invert3x3(m) {\r\n  // Invert a 3x3 matrix\r\n  const a = m[0][0], b = m[0][1], c = m[0][2];\r\n  const d = m[1][0], e = m[1][1], f = m[1][2];\r\n  const g = m[2][0], h = m[2][1], i = m[2][2];\r\n  const A = e * i - f * h;\r\n  const B = -(d * i - f * g);\r\n  const C = d * h - e * g;\r\n  const D = -(b * i - c * h);\r\n  const E = a * i - c * g;\r\n  const F = -(a * h - b * g);\r\n  const G = b * f - c * e;\r\n  const H = -(a * f - c * d);\r\n  const I = a * e - b * d;\r\n  const det = a * A + b * B + c * C;\r\n  if (det === 0) throw new Error('Singular matrix');\r\n  return [\r\n    [A / det, D / det, G / det],\r\n    [B / det, E / det, H / det],\r\n    [C / det, F / det, I / det]\r\n  ];\r\n}\r\n\r\nfunction warpTransform(ctx, image, matrix, outWidth, outHeight) {\r\n  // Triangle subdivision approach - uses GPU-accelerated affine transforms\r\n  // Split the quad into a grid, then draw each cell as 2 triangles with affine transforms\r\n  \r\n  const srcWidth = image.width || image.naturalWidth;\r\n  const srcHeight = image.height || image.naturalHeight;\r\n  \r\n  // Inverse matrix for mapping output coords to source coords\r\n  const inv = invert3x3(matrix);\r\n  \r\n  // Helper: map output point to source point using perspective transform\r\n  function mapPoint(x, y) {\r\n    const denom = inv[2][0] * x + inv[2][1] * y + inv[2][2];\r\n    return {\r\n      x: (inv[0][0] * x + inv[0][1] * y + inv[0][2]) / denom,\r\n      y: (inv[1][0] * x + inv[1][1] * y + inv[1][2]) / denom\r\n    };\r\n  }\r\n  \r\n  // Grid subdivisions - 64x64 = 8192 triangles\r\n  const gridX = 64;\r\n  const gridY = 64;\r\n  const cellW = outWidth / gridX;\r\n  const cellH = outHeight / gridY;\r\n  \r\n  // Build source canvas once\r\n  const srcCanvas = document.createElement('canvas');\r\n  srcCanvas.width = srcWidth;\r\n  srcCanvas.height = srcHeight;\r\n  const srcCtx = srcCanvas.getContext('2d');\r\n  srcCtx.drawImage(image, 0, 0, srcWidth, srcHeight);\r\n  \r\n  // High quality results\r\n  ctx.imageSmoothingEnabled = true;\r\n  ctx.imageSmoothingQuality = 'high';\r\n  \r\n  // Draw each grid cell as 2 triangles\r\n  ctx.save();\r\n  \r\n  for (let gy = 0; gy < gridY; gy++) {\r\n    for (let gx = 0; gx < gridX; gx++) {\r\n      // Destination quad corners (in output space)\r\n      const dx0 = gx * cellW;\r\n      const dy0 = gy * cellH;\r\n      const dx1 = (gx + 1) * cellW;\r\n      const dy1 = (gy + 1) * cellH;\r\n      \r\n      // Map to source quad corners\r\n      const s00 = mapPoint(dx0, dy0);\r\n      const s10 = mapPoint(dx1, dy0);\r\n      const s01 = mapPoint(dx0, dy1);\r\n      const s11 = mapPoint(dx1, dy1);\r\n      \r\n      // Draw 2 triangles per cell\r\n      // Triangle 1: top-left, top-right, bottom-left\r\n      drawTexturedTriangle(ctx, srcCanvas,\r\n        s00.x, s00.y, s10.x, s10.y, s01.x, s01.y,  // source triangle\r\n        dx0, dy0, dx1, dy0, dx0, dy1               // dest triangle\r\n      );\r\n      \r\n      // Triangle 2: top-right, bottom-right, bottom-left\r\n      drawTexturedTriangle(ctx, srcCanvas,\r\n        s10.x, s10.y, s11.x, s11.y, s01.x, s01.y,  // source triangle\r\n        dx1, dy0, dx1, dy1, dx0, dy1               // dest triangle\r\n      );\r\n    }\r\n  }\r\n  \r\n  ctx.restore();\r\n}\r\n\r\n// Draw a textured triangle using affine transform + clipping\r\nfunction drawTexturedTriangle(ctx, img,\r\n  sx0, sy0, sx1, sy1, sx2, sy2,  // source triangle coords\r\n  dx0, dy0, dx1, dy1, dx2, dy2   // dest triangle coords\r\n) {\r\n  // Compute affine transform that maps source triangle to dest triangle\r\n  const denom = (sx0 - sx2) * (sy1 - sy2) - (sx1 - sx2) * (sy0 - sy2);\r\n  if (Math.abs(denom) < 1e-10) return; \r\n  \r\n  const invDenom = 1 / denom;\r\n  const a = ((dx0 - dx2) * (sy1 - sy2) - (dx1 - dx2) * (sy0 - sy2)) * invDenom;\r\n  const b = ((dx1 - dx2) * (sx0 - sx2) - (dx0 - dx2) * (sx1 - sx2)) * invDenom;\r\n  const c = dx0 - a * sx0 - b * sy0;\r\n  \r\n  const d = ((dy0 - dy2) * (sy1 - sy2) - (dy1 - dy2) * (sy0 - sy2)) * invDenom;\r\n  const e = ((dy1 - dy2) * (sx0 - sx2) - (dy0 - dy2) * (sx1 - sx2)) * invDenom;\r\n  const f = dy0 - d * sx0 - e * sy0;\r\n  \r\n  ctx.save();\r\n  \r\n  // SEAM FIX: Robust Centroid-based Expansion\r\n  // We expand the clipping path by 1px in the direction of the triangle's center to ensure overlap.\r\n  const expand = 1.0; \r\n  const centerX = (dx0 + dx1 + dx2) / 3;\r\n  const centerY = (dy0 + dy1 + dy2) / 3;\r\n  \r\n  const grow = (x, y) => {\r\n    const vx = x - centerX;\r\n    const vy = y - centerY;\r\n    const len = Math.sqrt(vx * vx + vy * vy);\r\n    if (len < 1e-6) return { x, y };\r\n    return {\r\n      x: x + (vx / len) * expand,\r\n      y: y + (vy / len) * expand\r\n    };\r\n  };\r\n\r\n  const p0 = grow(dx0, dy0);\r\n  const p1 = grow(dx1, dy1);\r\n  const p2 = grow(dx2, dy2);\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(p0.x, p0.y);\r\n  ctx.lineTo(p1.x, p1.y);\r\n  ctx.lineTo(p2.x, p2.y);\r\n  ctx.closePath();\r\n  ctx.clip();\r\n  \r\n  ctx.setTransform(a, d, b, e, c, f);\r\n  ctx.drawImage(img, 0, 0);\r\n  ctx.restore();\r\n}\r\n\r\n\r\n/**\r\n * Extract document with manual corner points (no detection).\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} corners - Corner points object with topLeft, topRight, bottomRight, bottomLeft\r\n * @param {Object} options\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n * @returns {Promise<{output, corners, success, message}>}\r\n */\r\nexport async function extractDocument(image, corners, options = {}) {\r\n  const outputType = options.output || 'canvas';\r\n\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      success: false,\r\n      message: 'Invalid corner points provided'\r\n    };\r\n  }\r\n\r\n  try {\r\n    // Create result canvas and extract document\r\n    const resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, corners);\r\n\r\n    let output;\r\n    // Prepare output in requested format\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n\r\n    return {\r\n      output,\r\n      corners,\r\n      success: true,\r\n      message: 'Document extracted successfully'\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      output: null,\r\n      corners,\r\n      success: false,\r\n      message: `Extraction failed: ${error.message}`\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Main entry point for document scanning.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} options\r\n *   - mode: 'detect' | 'extract' (default: 'detect')\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n *   - debug: boolean\r\n *   - ...other detection options\r\n * @returns {Promise<{output, corners, contour, debug, success, message, timings}>}\r\n */\r\nexport async function scanDocument(image, options = {}) {\r\n  const timings = [];\r\n  const totalStart = performance.now();\r\n  \r\n  const mode = options.mode || 'detect';\r\n  const outputType = options.output || 'canvas';\r\n  const debug = !!options.debug;\r\n  const maxProcessingDimension = options.maxProcessingDimension || 800;\r\n\r\n  // Combined image preparation + downscaling + grayscale (OffscreenCanvas + CSS filter)\r\n  let t0 = performance.now();\r\n  const { grayscaleData, imageData, scaleFactor, originalDimensions, scaledDimensions } = \r\n    await prepareScaleAndGrayscale(image, maxProcessingDimension);\r\n  timings.push({ step: 'Image Prep + Scale + Gray', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  // Detect document (pass pre-computed grayscale data)\r\n  const detection = await detectDocumentInternal(\r\n    grayscaleData, \r\n    scaledDimensions.width, \r\n    scaledDimensions.height, \r\n    scaleFactor, \r\n    options\r\n  );\r\n  \r\n  // Merge detailed detection timings\r\n  if (detection.timings) {\r\n    detection.timings.forEach(t => timings.push(t));\r\n  }\r\n  \r\n  if (!detection.success) {\r\n    const totalEnd = performance.now();\r\n    timings.unshift({ step: 'Total', ms: (totalEnd - totalStart).toFixed(2) });\r\n    console.table(timings);\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      contour: null,\r\n      debug: detection.debug,\r\n      success: false,\r\n      message: detection.message || 'No document detected',\r\n      timings\r\n    };\r\n  }\r\n\r\n  let resultCanvas;\r\n  let output;\r\n\r\n  if (mode === 'detect') {\r\n    // Just return detection info, no image processing\r\n    output = null;\r\n  } else if (mode === 'extract') {\r\n    // Return only the cropped/warped document\r\n    t0 = performance.now();\r\n    resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, detection.corners);\r\n    timings.push({ step: 'Perspective Transform', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  // Prepare output in requested format (only if not detect mode)\r\n  if (mode !== 'detect' && resultCanvas) {\r\n    t0 = performance.now();\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n    timings.push({ step: 'Output Conversion', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  const totalEnd = performance.now();\r\n  timings.unshift({ step: 'Total', ms: (totalEnd - totalStart).toFixed(2) });\r\n  console.table(timings);\r\n\r\n  return {\r\n    output,\r\n    corners: detection.corners,\r\n    contour: detection.contour,\r\n    debug: detection.debug,\r\n    success: true,\r\n    message: 'Document detected',\r\n    timings\r\n  };\r\n}"],"names":["nextX","nextY","init","t0","t1","wasmBlur","wasmMaximumSuppression","wasmHysteresis","wasmDilate","matrix","A","b","totalEnd"],"mappings":"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"}