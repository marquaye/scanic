<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scanic - Debug Comparison</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
    .top-row {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .panel {
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .upload-panel {
      flex: 0 0 300px;
    }
    .results-panel {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .result-box h3 {
      margin: 0 0 10px 0;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    .result-box h3.scanic { color: #2196F3; }
    .result-box h3.opencv { color: #FF9800; }
    button {
      padding: 12px 20px;
      border-radius: 4px;
      border: none;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      width: 100%;
      margin-top: 10px;
    }
    button:hover { background-color: #45a049; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
    #dropZone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 30px 15px;
      text-align: center;
      cursor: pointer;
      background-color: #f9f9f9;
      transition: all 0.2s;
    }
    #dropZone:hover {
      border-color: #999;
      background-color: #f0f0f0;
    }
    #dropZone.dragover {
      border-color: #4CAF50;
      background-color: #e8f5e9;
    }
    .sample-images {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 15px;
    }
    .sample-image {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
      cursor: pointer;
      border: 2px solid #ddd;
      border-radius: 4px;
      transition: all 0.2s;
    }
    .sample-image:hover {
      border-color: #4CAF50;
      transform: scale(1.05);
    }
    .canvas-container {
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fafafa;
      border-radius: 4px;
      border: 1px solid #eee;
    }
    .canvas-container canvas {
      max-width: 100%;
      max-height: 400px;
    }
    .timing-table {
      width: 100%;
      border-collapse: collapse;
      font-family: monospace;
      font-size: 12px;
      margin-top: 10px;
    }
    .timing-table th, .timing-table td {
      padding: 6px 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }
    .timing-table th {
      background: #f5f5f5;
      font-weight: 600;
    }
    .timing-table tr:first-child td {
      font-weight: bold;
      background: #e3f2fd;
    }
    .timing-table .slow { color: #f44336; }
    .timing-table .fast { color: #4CAF50; }
    .status {
      padding: 8px;
      border-radius: 4px;
      text-align: center;
      font-size: 13px;
      margin-bottom: 10px;
    }
    .status.processing { background: #fff3e0; color: #ef6c00; }
    .status.success { background: #e8f5e9; color: #2e7d32; }
    .status.error { background: #ffebee; color: #c62828; }
    .status.waiting { background: #f5f5f5; color: #757575; }
    /* Debug steps */
    .debug-section {
      margin-top: 20px;
    }
    .debug-section h3 {
      margin-bottom: 15px;
    }
    .debug-steps {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
    }
    .debug-step {
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .debug-step h4 {
      margin: 0;
      padding: 8px 12px;
      background: #f0f0f0;
      font-size: 13px;
      font-weight: 500;
    }
    .debug-step canvas {
      width: 100%;
      height: auto;
      display: block;
    }
    .mode-toggle {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
    }
    .mode-toggle button {
      flex: 1;
      margin: 0;
      padding: 8px;
      font-size: 12px;
    }
    .mode-toggle button.active {
      background: #2196F3;
    }
    .sliders-section {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #eee;
    }
    .sliders-section label {
      display: block;
      font-size: 12px;
      margin: 8px 0 2px 0;
      color: #555;
    }
    .sliders-section input[type="range"] {
      width: 100%;
      margin: 0;
    }
    .sliders-section span {
      font-weight: bold;
      color: #2196F3;
    }
  </style>
</head>
<body>
  <h1>Scanic vs OpenCV Comparison</h1>
  
  <!-- Define onOpenCvReady BEFORE loading OpenCV to avoid race condition -->
  <script>
    window.cvReady = false;
    window.onOpenCvReady = function() {
      if (typeof cv !== 'undefined') {
        cv['onRuntimeInitialized'] = () => {
          console.log("OpenCV.js ready");
          window.cvReady = true;
          window.dispatchEvent(new Event('opencv-ready'));
        };
      }
    };
  </script>
  
  <!-- Load OpenCV.js -->
  <script src="https://docs.opencv.org/4.7.0/opencv.js" async onload="onOpenCvReady();"></script>
  
  <div class="top-row">
    <!-- Upload Panel -->
    <div class="panel upload-panel">
      <div id="dropZone">
        <p style="margin:0">üìÅ Drop image here<br><small>or click to browse</small></p>
        <input type="file" id="fileInput" accept="image/*" style="display: none">
      </div>
      
      <div class="mode-toggle">
        <button id="modeDetect" class="active">Detect Only</button>
        <button id="modeExtract">Extract</button>
      </div>
      
      <button id="processButton" disabled>Process Image</button>
      
      <!-- Parameter Sliders -->
      <div class="sliders-section">
        <h4 style="margin: 15px 0 10px 0;">‚öôÔ∏è Parameters</h4>
        
        <label>Low Threshold: <span id="lowThresholdVal">75</span></label>
        <input type="range" id="lowThreshold" min="10" max="150" value="75">
        
        <label>High Threshold: <span id="highThresholdVal">200</span></label>
        <input type="range" id="highThreshold" min="50" max="300" value="200">
        
        <label>Dilation Size: <span id="dilationSizeVal">3</span></label>
        <input type="range" id="dilationSize" min="1" max="7" step="2" value="3">
        
        <label>Dilation Iterations: <span id="dilationIterVal">1</span></label>
        <input type="range" id="dilationIter" min="1" max="5" value="1">
        
        <label>Min Area: <span id="minAreaVal">1000</span></label>
        <input type="range" id="minArea" min="100" max="10000" step="100" value="1000">
        
        <label>Epsilon: <span id="epsilonVal">0.02</span></label>
        <input type="range" id="epsilon" min="0.005" max="0.1" step="0.005" value="0.02">
      </div>
      
      <h4 style="margin: 20px 0 10px 0;">Sample Images</h4>
      <div class="sample-images" id="sampleImagesContainer"></div>
    </div>
    
    <!-- Results Panel -->
    <div class="panel results-panel">
      <!-- Scanic Result -->
      <div class="result-box">
        <h3 class="scanic">üöÄ Scanic (Pure JS + WASM)</h3>
        <div id="statusScanic" class="status waiting">Waiting for image...</div>
        <div id="canvasContainerScanic" class="canvas-container">
          <span style="color:#999">No result yet</span>
        </div>
        <table class="timing-table" id="timingTableScanic" style="display:none">
          <thead><tr><th>Step</th><th>Time (ms)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      
      <!-- OpenCV Result -->
      <div class="result-box">
        <h3 class="opencv">üì¶ jscanify (OpenCV.js)</h3>
        <div id="statusOpenCV" class="status waiting">Loading OpenCV...</div>
        <div id="canvasContainerOpenCV" class="canvas-container">
          <span style="color:#999">No result yet</span>
        </div>
        <table class="timing-table" id="timingTableOpenCV" style="display:none">
          <thead><tr><th>Step</th><th>Time (ms)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
  
  <!-- Debug Steps -->
  <div id="debugSectionScanic" class="panel debug-section" style="display:none">
    <h3>üîç Scanic Processing Steps</h3>
    <div class="debug-steps" id="stepsGridScanic"></div>
  </div>
  
  <div id="debugSectionOpenCV" class="panel debug-section" style="display:none">
    <h3>üîç OpenCV Processing Steps</h3>
    <div class="debug-steps" id="stepsGridOpenCV"></div>
  </div>

  <!-- Import original jscanify - add cache buster -->
  <script src="../src/jscanify.js?v=3"></script>
  
  <script type="module">
    import * as scanic from '../src/index.js?v=3';
    
    // State
    let cvReady = false;
    let originalScanner = null;
    let currentImage = null;
    let mode = 'detect'; // 'detect' or 'extract'
    
    // DOM Elements
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const processButton = document.getElementById('processButton');
    const modeDetect = document.getElementById('modeDetect');
    const modeExtract = document.getElementById('modeExtract');
    const sampleImagesContainer = document.getElementById('sampleImagesContainer');
    
    const statusScanic = document.getElementById('statusScanic');
    const statusOpenCV = document.getElementById('statusOpenCV');
    const canvasContainerScanic = document.getElementById('canvasContainerScanic');
    const canvasContainerOpenCV = document.getElementById('canvasContainerOpenCV');
    const timingTableScanic = document.getElementById('timingTableScanic');
    const timingTableOpenCV = document.getElementById('timingTableOpenCV');
    const debugSectionScanic = document.getElementById('debugSectionScanic');
    const debugSectionOpenCV = document.getElementById('debugSectionOpenCV');
    
    // Slider elements
    const sliders = {
      lowThreshold: document.getElementById('lowThreshold'),
      highThreshold: document.getElementById('highThreshold'),
      dilationSize: document.getElementById('dilationSize'),
      dilationIter: document.getElementById('dilationIter'),
      minArea: document.getElementById('minArea'),
      epsilon: document.getElementById('epsilon')
    };
    
    // Update slider value displays and auto-process
    Object.keys(sliders).forEach(key => {
      const slider = sliders[key];
      const valSpan = document.getElementById(key + 'Val');
      slider.oninput = () => {
        valSpan.textContent = slider.value;
      };
      slider.onchange = () => {
        if (currentImage && cvReady) processImage();
      };
    });
    const stepsGridScanic = document.getElementById('stepsGridScanic');
    const stepsGridOpenCV = document.getElementById('stepsGridOpenCV');

    // OpenCV Ready - listen for event from the global script
    function initOpenCV() {
      console.log("OpenCV.js ready");
      cvReady = true;
      originalScanner = new jscanify();
      statusOpenCV.textContent = 'Ready';
      statusOpenCV.className = 'status waiting';
      if (currentImage) processButton.disabled = false;
    }
    
    // Check if already ready, otherwise wait for event
    if (window.cvReady) {
      initOpenCV();
    } else {
      window.addEventListener('opencv-ready', initOpenCV);
    }
    
    // File handling
    function handleFile(file) {
      if (!file?.type.startsWith('image/')) return;
      const reader = new FileReader();
      reader.onload = e => loadImage(e.target.result);
      reader.readAsDataURL(file);
    }
    
    function loadImage(src) {
      const img = new Image();
      img.onload = () => {
        currentImage = img;
        processButton.disabled = !cvReady;
        statusScanic.textContent = `Image loaded: ${img.width}√ó${img.height}`;
        statusScanic.className = 'status success';
        statusOpenCV.textContent = cvReady ? 'Ready to process' : 'Loading OpenCV...';
        // Auto-process
        if (cvReady) processImage();
      };
      img.src = src;
    }
    
    // Mode toggle
    modeDetect.onclick = () => {
      mode = 'detect';
      modeDetect.classList.add('active');
      modeExtract.classList.remove('active');
      if (currentImage && cvReady) processImage();
    };
    modeExtract.onclick = () => {
      mode = 'extract';
      modeExtract.classList.add('active');
      modeDetect.classList.remove('active');
      if (currentImage && cvReady) processImage();
    };
    
    // Process image
    async function processImage() {
      if (!currentImage || !cvReady) return;
      
      // Reset UI
      statusScanic.textContent = 'Processing...';
      statusScanic.className = 'status processing';
      statusOpenCV.textContent = 'Processing...';
      statusOpenCV.className = 'status processing';
      canvasContainerScanic.innerHTML = '<span style="color:#999">Processing...</span>';
      canvasContainerOpenCV.innerHTML = '<span style="color:#999">Processing...</span>';
      timingTableScanic.style.display = 'none';
      timingTableOpenCV.style.display = 'none';
      stepsGridScanic.innerHTML = '';
      stepsGridOpenCV.innerHTML = '';
      
      // Small delay to let UI update
      await new Promise(r => setTimeout(r, 10));
      
      // Process with Scanic
      await processWithScanic();
      
      // Process with OpenCV
      processWithOpenCV();
    }
    
    async function processWithScanic() {
      try {
        const result = await scanic.scanDocument(currentImage, {
          mode: mode,
          output: 'canvas',
          debug: true,
          // Pass slider values
          lowThreshold: parseInt(sliders.lowThreshold.value),
          highThreshold: parseInt(sliders.highThreshold.value),
          dilationKernelSize: parseInt(sliders.dilationSize.value),
          dilationIterations: parseInt(sliders.dilationIter.value),
          minArea: parseInt(sliders.minArea.value),
          epsilon: parseFloat(sliders.epsilon.value)
        });
        
        if (result.success) {
          statusScanic.textContent = 'Success!';
          statusScanic.className = 'status success';
          
          canvasContainerScanic.innerHTML = '';
          if (mode === 'extract' && result.output) {
            canvasContainerScanic.appendChild(result.output);
          } else {
            // Draw detection overlay
            const canvas = drawDetectionOverlay(currentImage, result.corners);
            canvasContainerScanic.appendChild(canvas);
          }
          
          // Show timings
          if (result.timings) {
            displayTimings(timingTableScanic, result.timings);
          }
          
          // Show debug steps
          if (result.debug) {
            displayScanicDebugSteps(result.debug, currentImage);
          }
        } else {
          statusScanic.textContent = result.message || 'No document found';
          statusScanic.className = 'status error';
          canvasContainerScanic.innerHTML = '<span style="color:#c62828">Detection failed</span>';
          
          // Still show timings if available
          if (result.timings) {
            displayTimings(timingTableScanic, result.timings);
          }
        }
      } catch (err) {
        console.error('Scanic error:', err);
        statusScanic.textContent = 'Error: ' + err.message;
        statusScanic.className = 'status error';
      }
    }
    
    function processWithOpenCV() {
      try {
        const startTime = performance.now();
        const debugInfo = {};
        
        if (mode === 'extract') {
          // Use extractPaper for fair comparison
          const resultCanvas = originalScanner.extractPaper(currentImage, 800, 600);
          const endTime = performance.now();
          
          if (resultCanvas) {
            statusOpenCV.textContent = 'Success!';
            statusOpenCV.className = 'status success';
            canvasContainerOpenCV.innerHTML = '';
            canvasContainerOpenCV.appendChild(resultCanvas);
            displayTimings(timingTableOpenCV, [
              { step: 'Total', ms: (endTime - startTime).toFixed(2) }
            ]);
          } else {
            statusOpenCV.textContent = 'No document found';
            statusOpenCV.className = 'status error';
            canvasContainerOpenCV.innerHTML = '<span style="color:#c62828">Detection failed</span>';
          }
        } else {
          // Detection with overlay
          const resultCanvas = originalScanner.highlightPaper(currentImage, { debug: debugInfo });
          const endTime = performance.now();
          
          statusOpenCV.textContent = 'Success!';
          statusOpenCV.className = 'status success';
          canvasContainerOpenCV.innerHTML = '';
          canvasContainerOpenCV.appendChild(resultCanvas);
          
          // Show timings from debug info
          if (debugInfo.timings) {
            displayTimings(timingTableOpenCV, debugInfo.timings);
          } else {
            displayTimings(timingTableOpenCV, [
              { step: 'Total', ms: (endTime - startTime).toFixed(2) }
            ]);
          }
          
          // Show debug steps
          if (resultCanvas.debugInfo) {
            displayOpenCVDebugSteps(resultCanvas.debugInfo);
          }
        }
      } catch (err) {
        console.error('OpenCV error:', err);
        statusOpenCV.textContent = 'Error: ' + err.message;
        statusOpenCV.className = 'status error';
      }
    }
    
    function drawDetectionOverlay(image, corners) {
      const canvas = document.createElement('canvas');
      canvas.width = image.width || image.naturalWidth;
      canvas.height = image.height || image.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0);
      
      if (corners) {
        ctx.strokeStyle = '#00FF00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(corners.topLeft.x, corners.topLeft.y);
        ctx.lineTo(corners.topRight.x, corners.topRight.y);
        ctx.lineTo(corners.bottomRight.x, corners.bottomRight.y);
        ctx.lineTo(corners.bottomLeft.x, corners.bottomLeft.y);
        ctx.closePath();
        ctx.stroke();
        
        // Corner dots
        ctx.fillStyle = '#00FF00';
        [corners.topLeft, corners.topRight, corners.bottomRight, corners.bottomLeft].forEach(c => {
          ctx.beginPath();
          ctx.arc(c.x, c.y, 6, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      return canvas;
    }
    
    function displayTimings(table, timings) {
      const tbody = table.querySelector('tbody');
      tbody.innerHTML = '';
      
      timings.forEach((t, i) => {
        const tr = document.createElement('tr');
        const ms = parseFloat(t.ms);
        const colorClass = ms > 100 ? 'slow' : (ms < 20 ? 'fast' : '');
        tr.innerHTML = `<td>${t.step}</td><td class="${colorClass}">${t.ms} ms</td>`;
        tbody.appendChild(tr);
      });
      
      table.style.display = 'table';
    }
    
    function displayScanicDebugSteps(debug, image) {
      stepsGridScanic.innerHTML = '';
      debugSectionScanic.style.display = 'block';
      
      const dims = debug.preprocessing?.scaledDimensions || { width: image.width, height: image.height };
      
      // Original
      addDebugStep(stepsGridScanic, 'Original', (canvas) => {
        const ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      }, dims.width, dims.height);
      
      // Grayscale/Blurred
      if (debug.blurred) {
        addDebugStep(stepsGridScanic, 'Blurred', (canvas) => {
          drawGrayscaleArray(canvas, debug.blurred, dims.width, dims.height);
        }, dims.width, dims.height);
      }
      
      // Magnitude
      if (debug.magnitude) {
        addDebugStep(stepsGridScanic, 'Gradient Magnitude', (canvas) => {
          drawFloatArray(canvas, debug.magnitude, dims.width, dims.height);
        }, dims.width, dims.height);
      }
      
      // Suppressed
      if (debug.suppressed) {
        addDebugStep(stepsGridScanic, 'Non-Max Suppression', (canvas) => {
          drawFloatArray(canvas, debug.suppressed, dims.width, dims.height);
        }, dims.width, dims.height);
      }
      
      // Final edges
      if (debug.finalEdges) {
        addDebugStep(stepsGridScanic, 'Final Edges', (canvas) => {
          drawGrayscaleArray(canvas, debug.finalEdges, dims.width, dims.height);
        }, dims.width, dims.height);
      }
    }
    
    function displayOpenCVDebugSteps(debugInfo) {
      stepsGridOpenCV.innerHTML = '';
      debugSectionOpenCV.style.display = 'block';
      
      const addCvStep = (title, mat) => {
        if (!mat) return;
        addDebugStep(stepsGridOpenCV, title, (canvas) => {
          cv.imshow(canvas, mat);
        }, mat.cols, mat.rows);
      };
      
      addCvStep('Blurred', debugInfo.blurred);
      addCvStep('Canny Edges', debugInfo.canny);
      addCvStep('Dilated', debugInfo.dilated);
      addCvStep('Contours', debugInfo.contoursMat);
      
      // Cleanup mats
      setTimeout(() => {
        for (const key in debugInfo) {
          if (debugInfo[key]?.delete) {
            try { debugInfo[key].delete(); } catch(e) {}
          }
        }
      }, 100);
    }
    
    function addDebugStep(container, title, drawFn, width, height) {
      const div = document.createElement('div');
      div.className = 'debug-step';
      div.innerHTML = `<h4>${title}</h4>`;
      
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      div.appendChild(canvas);
      container.appendChild(div);
      
      drawFn(canvas);
    }
    
    function drawGrayscaleArray(canvas, arr, width, height) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.createImageData(width, height);
      for (let i = 0; i < arr.length; i++) {
        const v = arr[i];
        imageData.data[i * 4] = v;
        imageData.data[i * 4 + 1] = v;
        imageData.data[i * 4 + 2] = v;
        imageData.data[i * 4 + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }
    
    function drawFloatArray(canvas, arr, width, height) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.createImageData(width, height);
      // Find max for normalization
      let max = 0;
      for (let i = 0; i < arr.length; i++) if (arr[i] > max) max = arr[i];
      const scale = max > 0 ? 255 / max : 1;
      
      for (let i = 0; i < arr.length; i++) {
        const v = Math.round(arr[i] * scale);
        imageData.data[i * 4] = v;
        imageData.data[i * 4 + 1] = v;
        imageData.data[i * 4 + 2] = v;
        imageData.data[i * 4 + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }
    
    // Sample images
    function loadSampleImages() {
      const paths = [
        '../testImages/test.png',
        // '../testImages/test2.jpg', 
        '../testImages/test3.jpg',
        '../testImages/test4.jpg',
        '../testImages/test5.jpg',
        '../testImages/test6.jpg'
      ];
      
      paths.forEach(path => {
        const img = document.createElement('img');
        img.src = path;
        img.className = 'sample-image';
        img.onclick = () => loadImage(path);
        img.onerror = () => img.remove();
        sampleImagesContainer.appendChild(img);
      });
    }
    
    // Event listeners
    fileInput.onchange = () => handleFile(fileInput.files[0]);
    dropZone.onclick = () => fileInput.click();
    dropZone.ondragover = e => { e.preventDefault(); dropZone.classList.add('dragover'); };
    dropZone.ondragleave = () => dropZone.classList.remove('dragover');
    dropZone.ondrop = e => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFile(e.dataTransfer.files[0]); };
    processButton.onclick = processImage;
    
    // Init
    loadSampleImages();
    console.log('Scanic Debug UI initialized');
  </script>
</body>
</html>
