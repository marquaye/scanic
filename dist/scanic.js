const p = {
  // Contour detection params
  MIN_CONTOUR_AREA: 1e3,
  MIN_CONTOUR_POINTS: 10
}, O = 0, z = 1, x = 2, Y = [
  { dx: 0, dy: -1 },
  // 0: Top
  { dx: 1, dy: -1 },
  // 1: Top-right
  { dx: 1, dy: 0 },
  // 2: Right
  { dx: 1, dy: 1 },
  // 3: Bottom-right
  { dx: 0, dy: 1 },
  // 4: Bottom
  { dx: -1, dy: 1 },
  // 5: Bottom-left
  { dx: -1, dy: 0 },
  // 6: Left
  { dx: -1, dy: -1 }
  // 7: Top-left
];
function V(I, A = {}) {
  const g = A.width || Math.sqrt(I.length), C = A.height || I.length / g, E = A.mode !== void 0 ? A.mode : z, B = A.method !== void 0 ? A.method : x, Q = A.minArea || p.MIN_CONTOUR_AREA, i = g + 2, s = C + 2, t = new Int32Array(i * s);
  for (let n = 0; n < C; n++)
    for (let D = 0; D < g; D++)
      I[n * g + D] > 0 && (t[(n + 1) * i + (D + 1)] = 1);
  const o = [];
  let e = 2;
  for (let n = 1; n <= C; n++)
    for (let D = 1; D <= g; D++) {
      const h = t[n * i + D], y = t[n * i + (D - 1)];
      let c = null, r = !1, w = -1;
      if (h === 1 && y === 0 ? (r = !0, c = { x: D, y: n }, w = 2) : h === 0 && y >= 1 && y !== -1 && y === 1 && (r = !1, c = { x: D - 1, y: n }, w = 6), c) {
        if (E === O && !r) {
          t[c.y * i + c.x] = -1;
          continue;
        }
        const F = e++, R = _(t, i, s, c, w, F);
        if (R && R.length > 0) {
          let d = R;
          B === x && (d = $(R));
          const S = d.map((G) => ({ x: G.x - 1, y: G.y - 1 }));
          if (S.length >= (B === x ? 4 : p.MIN_CONTOUR_POINTS)) {
            const G = {
              id: F,
              points: S,
              isOuter: r
              // Calculate area and bounding box later if needed for filtering/sorting
            };
            o.push(G);
          }
        } else
          t[c.y * i + c.x] === 1 && (t[c.y * i + c.x] = F);
      }
    }
  o.forEach((n) => {
    n.area = AA(n.points), n.boundingBox = IA(n.points);
  });
  const a = o.filter((n) => n.area >= Q);
  return a.sort((n, D) => D.area - n.area), A.debug && (A.debug.labels = t, A.debug.rawContours = o, A.debug.finalContours = a), a;
}
function _(I, A, g, C, E, B) {
  const Q = [], i = /* @__PURE__ */ new Set();
  let s = { ...C }, t = -1;
  I[C.y * A + C.x] = B;
  let o = 0;
  const e = A * g;
  for (; o++ < e; ) {
    let a;
    if (t === -1) {
      let h = !1;
      for (let y = 0; y < 8; y++) {
        a = (E + y) % 8;
        const c = s.x + Y[a].dx, r = s.y + Y[a].dy;
        if (c >= 0 && c < A && r >= 0 && r < g && I[r * A + c] > 0) {
          h = !0;
          break;
        }
      }
      if (!h) return null;
    } else
      a = (t + 2) % 8;
    let n = null;
    for (let h = 0; h < 8; h++) {
      const y = (a + h) % 8, c = s.x + Y[y].dx, r = s.y + Y[y].dy;
      if (c >= 0 && c < A && r >= 0 && r < g && I[r * A + c] > 0) {
        n = { x: c, y: r }, t = (y + 4) % 8;
        break;
      }
    }
    if (!n) {
      Q.length === 0 && Q.push({ ...s }), console.warn(`Contour tracing stopped unexpectedly at (${s.x - 1}, ${s.y - 1}) for contour ${B}`);
      break;
    }
    const D = `${s.x},${s.y}`;
    if (i.has(D))
      return Q;
    if (Q.push({ ...s }), i.add(D), I[n.y * A + n.x] === 1 && (I[n.y * A + n.x] = B), s = n, s.x === C.x && s.y === C.y)
      break;
  }
  return o >= e ? (console.warn(`Contour tracing exceeded max steps for contour ${B}`), null) : Q;
}
function $(I) {
  if (I.length <= 2)
    return I;
  const A = [], g = I.length;
  for (let C = 0; C < g; C++) {
    const E = I[(C + g - 1) % g], B = I[C], Q = I[(C + 1) % g], i = B.x - E.x, s = B.y - E.y, t = Q.x - B.x, o = Q.y - B.y;
    i * o !== s * t && A.push(B);
  }
  if (A.length === 0 && g > 0) {
    if (g === 1) return [I[0]];
    if (g === 2) return I;
    let C = 0, E = 1;
    const B = I[0];
    for (let Q = 1; Q < g; Q++) {
      const i = I[Q], s = (i.x - B.x) ** 2 + (i.y - B.y) ** 2;
      s > C && (C = s, E = Q);
    }
    return [I[0], I[E]];
  }
  return A;
}
function AA(I) {
  let A = 0;
  const g = I.length;
  if (g < 3) return 0;
  for (let C = 0; C < g; C++) {
    const E = (C + 1) % g;
    A += I[C].x * I[E].y, A -= I[E].x * I[C].y;
  }
  return Math.abs(A) / 2;
}
function IA(I) {
  if (I.length === 0)
    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
  let A = I[0].x, g = I[0].y, C = I[0].x, E = I[0].y;
  for (let B = 1; B < I.length; B++) {
    const Q = I[B];
    A = Math.min(A, Q.x), g = Math.min(g, Q.y), C = Math.max(C, Q.x), E = Math.max(E, Q.y);
  }
  return { minX: A, minY: g, maxX: C, maxY: E };
}
function q(I, A = 1) {
  if (I.length <= 2)
    return I;
  let g = 0, C = 0;
  const E = I[0], B = I[I.length - 1];
  for (let Q = 1; Q < I.length - 1; Q++) {
    const i = gA(I[Q], E, B);
    i > g && (g = i, C = Q);
  }
  if (g > A) {
    const Q = q(I.slice(0, C + 1), A), i = q(I.slice(C), A);
    return Q.slice(0, -1).concat(i);
  } else
    return [E, B];
}
function gA(I, A, g) {
  const C = g.x - A.x, E = g.y - A.y, B = C * C + E * E;
  if (B === 0)
    return Math.sqrt(
      Math.pow(I.x - A.x, 2) + Math.pow(I.y - A.y, 2)
    );
  const Q = ((I.x - A.x) * C + (I.y - A.y) * E) / B;
  let i, s;
  Q < 0 ? (i = A.x, s = A.y) : Q > 1 ? (i = g.x, s = g.y) : (i = A.x + Q * C, s = A.y + Q * E);
  const t = I.x - i, o = I.y - s;
  return Math.sqrt(t * t + o * o);
}
function BA(I, A = 0.02) {
  const g = QA(I), C = A * g;
  return q(I, C);
}
function QA(I) {
  let A = 0;
  const g = I.length;
  if (g < 2) return 0;
  for (let C = 0; C < g; C++) {
    const E = (C + 1) % g, B = I[C].x - I[E].x, Q = I[C].y - I[E].y;
    A += Math.sqrt(B * B + Q * Q);
  }
  return A;
}
function CA(I) {
  let A = 0, g = 0;
  for (const C of I)
    A += C.x, g += C.y;
  return {
    x: A / I.length,
    y: g / I.length
  };
}
function EA(I, A = {}) {
  if (!I || !I.points || I.points.length < 4)
    return console.warn("Contour does not have enough points for corner detection"), null;
  const g = A.epsilon || 0.02, C = BA(I, g);
  let E;
  return C && C.length === 4 ? E = tA(C) : E = iA(I.points), !E || !E.topLeft || !E.topRight || !E.bottomRight || !E.bottomLeft ? (console.warn("Failed to find all four corners.", E), null) : (console.log("Corner points:", E), E);
}
function iA(I) {
  if (!I || I.length === 0) return null;
  let A = I[0], g = I[0], C = I[0], E = I[0], B = A.x + A.y, Q = g.x - g.y, i = C.x + C.y, s = E.x - E.y;
  for (let t = 1; t < I.length; t++) {
    const o = I[t], e = o.x + o.y, a = o.x - o.y;
    e < B && (B = e, A = o), e > i && (i = e, C = o), a > Q && (Q = a, g = o), a < s && (s = a, E = o);
  }
  return {
    topLeft: A,
    topRight: g,
    bottomRight: C,
    bottomLeft: E
  };
}
function tA(I) {
  if (I.length !== 4)
    return console.warn(`Expected 4 points, got ${I.length}`), null;
  const A = CA(I), g = [...I].sort((Q, i) => {
    const s = Math.atan2(Q.y - A.y, Q.x - A.x), t = Math.atan2(i.y - A.y, i.x - A.x);
    return s - t;
  });
  let C = 1 / 0, E = 0;
  for (let Q = 0; Q < 4; Q++) {
    const i = g[Q].x + g[Q].y;
    i < C && (C = i, E = Q);
  }
  const B = [
    g[E],
    g[(E + 1) % 4],
    g[(E + 2) % 4],
    g[(E + 3) % 4]
  ];
  return {
    topLeft: B[0],
    topRight: B[1],
    bottomRight: B[2],
    bottomLeft: B[3]
  };
}
let N, M = null;
function T() {
  return (M === null || M.byteLength === 0) && (M = new Uint8Array(N.memory.buffer)), M;
}
let k = 0;
function Z(I, A) {
  const g = A(I.length * 1, 1) >>> 0;
  return T().set(I, g / 1), k = I.length, g;
}
function b(I, A) {
  return I = I >>> 0, T().subarray(I / 1, I / 1 + A);
}
function sA(I, A, g, C) {
  const E = Z(I, N.__wbindgen_malloc), B = k, Q = N.dilate(E, B, A, g, C);
  var i = b(Q[0], Q[1]).slice();
  return N.__wbindgen_free(Q[0], Q[1] * 1, 1), i;
}
let L = null;
function P() {
  return (L === null || L.byteLength === 0) && (L = new Float32Array(N.memory.buffer)), L;
}
function oA(I, A) {
  const g = A(I.length * 4, 4) >>> 0;
  return P().set(I, g / 4), k = I.length, g;
}
function eA(I, A, g, C, E) {
  const B = oA(I, N.__wbindgen_malloc), Q = k, i = N.hysteresis_thresholding(B, Q, A, g, C, E);
  var s = b(i[0], i[1]).slice();
  return N.__wbindgen_free(i[0], i[1] * 1, 1), s;
}
function aA(I, A, g, C, E) {
  const B = Z(I, N.__wbindgen_malloc), Q = k, i = N.blur(B, Q, A, g, C, E);
  var s = b(i[0], i[1]).slice();
  return N.__wbindgen_free(i[0], i[1] * 1, 1), s;
}
let m = null;
function nA() {
  return (m === null || m.byteLength === 0) && (m = new Uint16Array(N.memory.buffer)), m;
}
function v(I, A) {
  const g = A(I.length * 2, 2) >>> 0;
  return nA().set(I, g / 2), k = I.length, g;
}
function DA(I, A) {
  return I = I >>> 0, P().subarray(I / 4, I / 4 + A);
}
function cA(I, A, g, C, E) {
  const B = v(I, N.__wbindgen_malloc), Q = k, i = v(A, N.__wbindgen_malloc), s = k, t = N.non_maximum_suppression(B, Q, i, s, g, C, E);
  var o = DA(t[0], t[1]).slice();
  return N.__wbindgen_free(t[0], t[1] * 4, 4), o;
}
async function hA(I, A) {
  if (typeof Response == "function" && I instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(I, A);
      } catch (C) {
        if (I.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", C);
        else
          throw C;
      }
    const g = await I.arrayBuffer();
    return await WebAssembly.instantiate(g, A);
  } else {
    const g = await WebAssembly.instantiate(I, A);
    return g instanceof WebAssembly.Instance ? { instance: g, module: I } : g;
  }
}
function yA() {
  const I = {};
  return I.wbg = {}, I.wbg.__wbindgen_init_externref_table = function() {
    const A = N.__wbindgen_export_0, g = A.grow(4);
    A.set(0, void 0), A.set(g + 0, void 0), A.set(g + 1, null), A.set(g + 2, !0), A.set(g + 3, !1);
  }, I;
}
function rA(I, A) {
  return N = I.exports, X.__wbindgen_wasm_module = A, L = null, m = null, M = null, N.__wbindgen_start(), N;
}
async function X(I) {
  if (N !== void 0) return N;
  typeof I < "u" && (Object.getPrototypeOf(I) === Object.prototype ? { module_or_path: I } = I : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof I > "u" && (I = new URL("data:application/wasm;base64,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QQhqIAIQKQALaAIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIMIANBuJbAADYCCCADQgI3AhQgA0KAgICAICIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQKQALaAIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIMIANB7JbAADYCCCADQgI3AhQgA0KAgICAICIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQKQALZQAjAEEwayIAJABBxJfAAC0AAARAIABBAjYCDCAAQbCSwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIAghDcDICAAIABBIGo2AhAgAEEIakHQksAAECkACyAAQTBqJAALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAPIAAoAgghAwsgACgCBCADaiABIAIQCxogACACIANqNgIIQQALTQECf0HFl8AALQAAGiABKAIEIQIgASgCACEDQQhBBBAzIgFFBEBBBEEIED0ACyABIAI2AgQgASADNgIAIABB8JLAADYCBCAAIAE2AgALQQEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQKQALrhIBEn8jAEEQayIXJAAgCCEMIwBB0ABrIgskACALQQhqIAAiCCABIhkgAiIRIAMgBiAHEAQgC0EUaiALKAIMIhwgCygCECACIAMQByACIANsIgBBAXQhBgJAAkACQCAAQQBIIAZB/v///wdLckUEQCAGRQ0BQcWXwAAtAAAaQQIhDSAGQQIQMyIBDQILIA0gBhAvAAtBACEGIAtBADYCKCALQoCAgIAgNwIgIAtBADYCNCALQoCAgIAgNwIsQQIhAUEBIRhBAiECDAELIAtBADYCKCALIAE2AiQgCyAANgIgQcWXwAAtAAAaAkACQAJAIAZBAhAzIgIEQEEAIQYgC0EANgI0IAsgAjYCMCALIAA2AiwgAEUEQEEBIRhBACENDAULIABFIRggCygCGCEBIAsoAhwhEiAAIQIDQCAGIBJPDQMgAS8BACENIAsoAigiECALKAIgRgRAIAtBIGoQEgsgCygCJCAQQQF0aiANOwEA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QQRqEBALIAYoAgggEEEDdGoiASACNgIEIAEgDDYCACAGIBBBAWo2AgwMAQsgBCAbX0UNACAMIBJqQQA6AAALIABBBGohACAMQQFqIQEgCyAMSw0ACyAJIBFqIREgByASaiESIgIgGUcNAAsMAQsgA0ECayEAIAdBAWohAiAHQQF0QQFrIQFBACEDA0AgASADaiIPIAIgA2pJDQYgDyATSw0EIAggD0kNAiADIAdqIQMgAEEBayIADQALCyAGKAIMIgJFDQcgB0EBaiEMQQEgB2shESAHQX9zIQ8gB0UNBgNAIAYgAkEBayICNgIMAkAgBigCCCACQQN0aiIAKAIEIAdsIAAoAgBqIgkgD2oiASAITw0AIAEgCmoiAC0AAA0AIABBAjoAACABIAEgB24iAiAHbGshASAGKAIMIgMgBigCBEYEQCAGQQRqEBALIAYoAgggA0EDdGoiACACNgIEIAAgATYCACAGIANBAWoiAjYCDAsCQCAJIAdrIgEgCE8NACABIApqIgAtAAANACAAQQI6AAAgASABIAduIgIgB2xrIQEgBigCDCIDIAYoAgRGBEAgBkEEahAQCyAGKAIIIANBA3RqIgAgAjYCBCAAIAE2AgAgBiADQQFqIgI2AgwLAkAgCSARaiIBIAhPDQAgASAKaiIALQAADQAgAEECOgAAIAEgASAHbiICIAdsayEBIAYoAgwiAyAGKAIERgRAIAZBBGoQEAsgBigCCCADQQN0aiIAIAI2AgQgACABNgIAIAYgA0EBaiICNgIMCwJAIAlBAWsiASAITw0AIAEgCmoiAC0AAA0AIABBAjoAACABIAEgB24iAiAHbGshASAGKAIMIgMgBigCBEYEQCAGQQRqEBALIAYoAgggA0EDdGoiACACNgIEIAAgATYCACAGIANBAWoiAjYCDAsCQCAJQQFqIgEgCE8NACABIApqIgAtAAANACAAQQI6AAAgASABIAduIgIgB2xrIQEgBigCDCIDIAYoAgRGBEAgBkEEahAQCyAGKAIIIANBA3RqIgAgAjYCBCAAIAE2AgAgBiADQQFqIgI2AgwLAkAgCSAWaiIBIAhPDQAgASAKaiIALQAADQAgAEECOgAAIAEgASAHbiICIAdsayEBIAYoAgwiAyAGKAIERgRAIAZBBGoQEAsgBigCCCADQQN0aiIAIAI2AgQgACAB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AAAPAAAAEwAAAExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAhAcQACoAAAAvdXNyL2xvY2FsL2NhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMAALgHEABaAAAACAMAABkAAAByZWVudHJhbnQgaW5pdAAAJAgQAA4AAAC4BxAAWgAAAHoCAAANAAAABAAAAAwAAAAEAAAABQAAAAYAAAAHAAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAGQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAABkCBAAKQAAAK4EAAANAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAADAkQABUAAAAhCRAADQAAAHN0ZC9zcmMvYWxsb2MucnNACRAAEAAAAGMBAAAJAAAABAAAAAwAAAAEAAAACAAAAAAAAAAIAAAABAAAAAkAAAAAAAAACAAAAAQAAAAKAAAACwAAAAwAAAANAAAADgAAABAAAAAEAAAADwAAABAAAAARAAAAEgAAAGNhcGFjaXR5IG92ZXJmbG93AAAAuAkQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc9QJEAAUAAAAGAAAAAUAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAA+AkQACAAAAAYChAAEgAAADAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5IG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIHJhbmdlIGVuZCBpbmRleCAAACYLEAAQAAAABAsQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IABICxAAFgAAAF4LEAANAAAAYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAHwLEAAZAAAAAAAAPwAAAL8AQcCXwAALAQEAfAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuODMuMCAoOTBiMzVhNjIzIDIwMjQtMTEtMjYpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuEzAuMi4xMDAgKDI0MDVlYzJiNCkAUg90YXJnZXRfZmVhdHVyZXMFKw9tdXRhYmxlLWdsb2JhbHMrB3NpbWQxMjgrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=", import.meta.url));
  const A = yA();
  (typeof I == "string" || typeof Request == "function" && I instanceof Request || typeof URL == "function" && I instanceof URL) && (I = fetch(I));
  const { instance: g, module: C } = await hA(await I, A);
  return rA(g, C);
}
const u = X();
function wA(I) {
  const { width: A, height: g, data: C } = I, E = new Uint8ClampedArray(A * g);
  for (let B = 0, Q = 0; B < C.length; B += 4, Q++)
    E[Q] = C[B] * 54 + C[B + 1] * 183 + C[B + 2] * 19 >> 8;
  return E;
}
function NA(I, A, g, C = 5, E = 0) {
  E === 0 && (E = 0.3 * ((C - 1) * 0.5 - 1) + 0.8);
  const B = Math.floor(C / 2), Q = FA(C, E), i = new Uint8ClampedArray(A * g), s = new Uint8ClampedArray(A * g);
  for (let t = 0; t < g; t++) {
    const o = t * A;
    for (let e = 0; e < A; e++) {
      let a = 0;
      for (let n = -B; n <= B; n++) {
        const D = Math.min(A - 1, Math.max(0, e + n));
        a += I[o + D] * Q[B + n];
      }
      i[o + e] = a;
    }
  }
  for (let t = 0; t < A; t++)
    for (let o = 0; o < g; o++) {
      let e = 0;
      for (let a = -B; a <= B; a++) {
        const n = Math.min(g - 1, Math.max(0, o + a));
        e += i[n * A + t] * Q[B + a];
      }
      s[o * A + t] = Math.round(e);
    }
  return s;
}
function FA(I, A) {
  const g = new Float32Array(I), C = Math.floor(I / 2);
  let E = 0;
  for (let B = 0; B < I; B++) {
    const Q = B - C;
    g[B] = Math.exp(-(Q * Q) / (2 * A * A)), E += g[B];
  }
  for (let B = 0; B < I; B++)
    g[B] /= E;
  return g;
}
function RA(I, A, g) {
  const C = new Int16Array(A * g), E = new Int16Array(A * g);
  for (let B = 1; B < g - 1; B++) {
    const Q = B * A, i = (B - 1) * A, s = (B + 1) * A;
    for (let t = 1; t < A - 1; t++) {
      const o = Q + t, e = I[i + t - 1], a = I[i + t], n = I[i + t + 1], D = I[Q + t - 1], h = I[Q + t + 1], y = I[s + t - 1], c = I[s + t], r = I[s + t + 1], w = n - e + 2 * (h - D) + (r - y), F = y + 2 * c + r - (e + 2 * a + n);
      C[o] = w, E[o] = F;
    }
  }
  return { dx: C, dy: E };
}
function lA(I, A, g, C, E) {
  const B = new Float32Array(g * C), Q = new Float32Array(g * C);
  for (let i = 0; i < I.length; i++) {
    const s = I[i], t = A[i];
    E ? B[i] = Math.sqrt(s * s + t * t) : B[i] = Math.abs(s) + Math.abs(t);
  }
  for (let i = 1; i < C - 1; i++)
    for (let s = 1; s < g - 1; s++) {
      const t = i * g + s, o = B[t];
      if (o === 0) {
        Q[t] = 0;
        continue;
      }
      const e = I[t], a = A[t];
      let n = 0, D = 0;
      const h = Math.abs(e), y = Math.abs(a);
      if (y > h * 2.4142)
        n = B[t - g], D = B[t + g];
      else if (h > y * 2.4142)
        n = B[t - 1], D = B[t + 1];
      else {
        const c = (e ^ a) < 0 ? -1 : 1;
        a > 0 ? (n = B[(i - 1) * g + (s - c)], D = B[(i + 1) * g + (s + c)]) : (n = B[(i + 1) * g + (s - c)], D = B[(i - 1) * g + (s + c)]), e > 0 && a > 0 || e < 0 && a < 0 ? (n = B[(i - 1) * g + (s + 1)], D = B[(i + 1) * g + (s - 1)]) : (n = B[(i - 1) * g + (s - 1)], D = B[(i + 1) * g + (s + 1)]);
      }
      o >= n && o >= D ? Q[t] = o : Q[t] = 0;
    }
  return Q;
}
function W(I, A, g, C, E) {
  const B = new Uint8Array(A * g), Q = [];
  for (let t = 1; t < g - 1; t++)
    for (let o = 1; o < A - 1; o++) {
      const e = t * A + o, a = I[e];
      a >= E ? (B[e] = 2, Q.push({ x: o, y: t })) : a >= C ? B[e] = 0 : B[e] = 1;
    }
  for (let t = 0; t < A; t++)
    B[t] = 1, B[(g - 1) * A + t] = 1;
  for (let t = 1; t < g - 1; t++)
    B[t * A] = 1, B[t * A + A - 1] = 1;
  const i = [-1, 0, 1, -1, 1, -1, 0, 1], s = [-1, -1, -1, 0, 0, 1, 1, 1];
  for (; Q.length > 0; ) {
    const { x: t, y: o } = Q.pop();
    for (let e = 0; e < 8; e++) {
      const a = t + i[e], n = o + s[e], D = n * A + a;
      B[D] === 0 && (B[D] = 2, Q.push({ x: a, y: n }));
    }
  }
  return B;
}
function GA(I, A, g, C = 5) {
  const E = Math.floor(C / 2), B = new Uint8ClampedArray(A * g), Q = new Uint8ClampedArray(A * g);
  for (let i = 0; i < g; i++) {
    const s = i * A;
    for (let t = 0; t < A; t++) {
      let o = 0;
      for (let e = -E; e <= E; e++) {
        const a = t + e;
        if (a >= 0 && a < A) {
          const n = I[s + a];
          n > o && (o = n);
        }
      }
      B[s + t] = o;
    }
  }
  for (let i = 0; i < A; i++)
    for (let s = 0; s < g; s++) {
      let t = 0;
      for (let o = -E; o <= E; o++) {
        const e = s + o;
        if (e >= 0 && e < g) {
          const a = B[e * A + i];
          a > t && (t = a);
        }
      }
      Q[s * A + i] = t;
    }
  return Q;
}
async function SA(I, A = {}) {
  const g = [], C = performance.now(), { width: E, height: B } = I;
  let Q = A.lowThreshold !== void 0 ? A.lowThreshold : 75, i = A.highThreshold !== void 0 ? A.highThreshold : 200;
  const s = A.kernelSize || 5, t = A.sigma || 0, o = A.L2gradient === void 0 ? !1 : A.L2gradient, e = A.applyDilation !== void 0 ? A.applyDilation : !0, a = A.dilationKernelSize || 5, n = A.useWasmHysteresis !== void 0 ? A.useWasmHysteresis : !1;
  Q >= i && (console.warn(`Canny Edge Detector: lowThreshold (${Q}) should be lower than highThreshold (${i}). Swapping them.`), [Q, i] = [i, Q]);
  let D = performance.now();
  const h = wA(I);
  let y = performance.now();
  g.push({ step: "Grayscale", ms: (y - D).toFixed(2) }), A.debug && (A.debug.grayscale = h);
  let c;
  D = performance.now();
  try {
    await u, c = aA(h, E, B, s, t);
  } catch {
    c = NA(h, E, B, s, t);
  }
  y = performance.now(), g.push({ step: "Gaussian Blur", ms: (y - D).toFixed(2) }), A.debug && (A.debug.blurred = c), D = performance.now();
  let r, w;
  {
    const l = RA(c, E, B);
    r = l.dx, w = l.dy;
  }
  y = performance.now(), g.push({ step: "Gradients", ms: (y - D).toFixed(2) }), D = performance.now();
  let F;
  try {
    await u, F = await cA(r, w, E, B, o);
  } catch {
    F = lA(r, w, E, B, o);
  }
  y = performance.now(), g.push({ step: "Non-Max Suppression", ms: (y - D).toFixed(2) }), D = performance.now();
  const R = o ? Q * Q : Q, d = o ? i * i : i;
  let S;
  if (n)
    try {
      await u, S = eA(F, E, B, R, d);
    } catch (l) {
      console.warn("WASM hysteresis failed, falling back to JS:", l), S = W(F, E, B, R, d);
    }
  else
    S = W(F, E, B, R, d);
  y = performance.now(), g.push({ step: "Hysteresis", ms: (y - D).toFixed(2) }), D = performance.now();
  const G = new Uint8ClampedArray(E * B);
  for (let l = 0; l < S.length; l++)
    G[l] = S[l] === 2 ? 255 : 0;
  y = performance.now(), g.push({ step: "Binary Image", ms: (y - D).toFixed(2) }), D = performance.now();
  let f = G;
  if (e)
    try {
      await u, f = sA(G, E, B, a);
    } catch {
      f = GA(G, E, B, a);
    }
  if (y = performance.now(), g.push({ step: "Dilation", ms: (y - D).toFixed(2) }), A.debug) {
    A.debug.dx = r, A.debug.dy = w;
    const l = new Float32Array(E * B);
    for (let J = 0; J < r.length; J++) {
      const U = r[J], H = w[J];
      l[J] = o ? Math.sqrt(U * U + H * H) : Math.abs(U) + Math.abs(H);
    }
    A.debug.magnitude = l, A.debug.suppressed = F, A.debug.edgeMap = S, A.debug.cannyEdges = G, A.debug.finalEdges = f, A.debug.timings = g;
  }
  const j = performance.now();
  return g.unshift({ step: "Total", ms: (j - C).toFixed(2) }), console.table(g), f;
}
class dA {
  constructor(A = {}) {
    this.options = {
      targetFPS: A.targetFPS || 10,
      // Limit FPS for performance
      detectionInterval: A.detectionInterval || 150,
      // ms between detections
      confidenceThreshold: A.confidenceThreshold || 0.7,
      stabilizationFrames: A.stabilizationFrames || 3,
      maxProcessingDimension: A.maxProcessingDimension || 500,
      // Lower for live processing
      ...A
    }, this.isRunning = !1, this.stream = null, this.video = null, this.canvas = null, this.ctx = null, this.outputCanvas = null, this.outputCtx = null, this.lastDetectionTime = 0, this.frameCount = 0, this.detectionCount = 0, this.lastFPSUpdate = 0, this.currentFPS = 0, this.lastResult = null, this.stableResults = [], this.currentCorners = null, this.onDetection = null, this.onFPSUpdate = null, this.onError = null;
  }
  /**
   * Initialize webcam access and start live scanning
   * @param {HTMLElement} outputElement - Canvas element to render results to
   * @param {Object} constraints - MediaStream constraints
   */
  async init(A, g = {}) {
    try {
      this.outputCanvas = A, this.outputCtx = this.outputCanvas.getContext("2d"), this.video = document.createElement("video"), this.video.style.display = "none", this.video.autoplay = !0, this.video.muted = !0, this.video.playsInline = !0, document.body.appendChild(this.video), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d");
      const E = { ...{
        video: {
          width: { ideal: 1280, max: 1920 },
          height: { ideal: 720, max: 1080 },
          facingMode: "environment"
          // Use back camera on mobile
        },
        audio: !1
      }, ...g };
      this.stream = await navigator.mediaDevices.getUserMedia(E), this.video.srcObject = this.stream, await new Promise((B) => {
        this.video.addEventListener("loadedmetadata", B, { once: !0 });
      }), this.canvas.width = this.video.videoWidth, this.canvas.height = this.video.videoHeight, this.outputCanvas.width = this.video.videoWidth, this.outputCanvas.height = this.video.videoHeight, console.log(`Live scanner initialized: ${this.video.videoWidth}x${this.video.videoHeight}`);
    } catch (C) {
      throw console.error("Failed to initialize live scanner:", C), this.onError && this.onError(C), C;
    }
  }
  /**
   * Start the live scanning loop
   */
  start() {
    if (this.isRunning || !this.video) {
      console.warn("Scanner already running or not initialized");
      return;
    }
    this.isRunning = !0, this.lastDetectionTime = Date.now(), this.lastFPSUpdate = Date.now(), this.frameCount = 0, this.detectionCount = 0, console.log("Live scanner started"), this.processFrame();
  }
  /**
   * Stop the live scanning
   */
  stop() {
    this.isRunning = !1, this.stream && (this.stream.getTracks().forEach((A) => A.stop()), this.stream = null), this.video && (this.video.remove(), this.video = null), console.log("Live scanner stopped");
  }
  /**
   * Main processing loop - optimized for performance
   */
  async processFrame() {
    if (!this.isRunning) return;
    const A = Date.now();
    this.frameCount++;
    try {
      this.outputCtx.drawImage(this.video, 0, 0, this.outputCanvas.width, this.outputCanvas.height);
      const g = A - this.lastDetectionTime;
      if (g >= this.options.detectionInterval) {
        this.lastDetectionTime = A, this.detectionCount++, this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        const C = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        this.detectDocumentAsync(C).catch((E) => {
          console.error("Detection error:", E), this.onError && this.onError(E);
        });
      }
      this.currentCorners && this.drawDocumentOverlay(this.currentCorners), A - this.lastFPSUpdate >= 1e3 && (this.currentFPS = Math.round(this.frameCount * 1e3 / (A - this.lastFPSUpdate)), this.frameCount = 0, this.lastFPSUpdate = A, this.onFPSUpdate && this.onFPSUpdate({
        renderFPS: this.currentFPS,
        detectionFPS: Math.round(this.detectionCount * 1e3 / 1e3),
        lastDetectionTime: g
      }), this.detectionCount = 0);
    } catch (g) {
      console.error("Frame processing error:", g), this.onError && this.onError(g);
    }
    requestAnimationFrame(() => this.processFrame());
  }
  /**
   * Run document detection asynchronously
   */
  async detectDocumentAsync(A) {
    try {
      const g = await K(A, {
        ...this.options,
        debug: !1
        // Disable debug for performance
      });
      g.success && g.corners ? (this.updateStableCorners(g.corners), this.onDetection && this.onDetection({
        corners: g.corners,
        confidence: this.calculateConfidence(g),
        isStable: this.stableResults.length >= this.options.stabilizationFrames
      })) : this.stableResults.length > 0 && (this.stableResults.pop(), this.stableResults.length === 0 && (this.currentCorners = null));
    } catch (g) {
      throw console.error("Document detection failed:", g), g;
    }
  }
  /**
   * Update stable corner detection with smoothing
   */
  updateStableCorners(A) {
    this.stableResults.push(A), this.stableResults.length > this.options.stabilizationFrames && this.stableResults.shift(), this.stableResults.length >= this.options.stabilizationFrames && (this.currentCorners = this.averageCorners(this.stableResults));
  }
  /**
   * Calculate average corners from multiple detections for smoothing
   */
  averageCorners(A) {
    const g = {
      topLeft: { x: 0, y: 0 },
      topRight: { x: 0, y: 0 },
      bottomRight: { x: 0, y: 0 },
      bottomLeft: { x: 0, y: 0 }
    };
    A.forEach((E) => {
      Object.keys(g).forEach((B) => {
        g[B].x += E[B].x, g[B].y += E[B].y;
      });
    });
    const C = A.length;
    return Object.keys(g).forEach((E) => {
      g[E].x = Math.round(g[E].x / C), g[E].y = Math.round(g[E].y / C);
    }), g;
  }
  /**
   * Draw document overlay on output canvas
   */
  drawDocumentOverlay(A, g = null, C = 1, E = 1) {
    const B = g || this.outputCtx;
    B.save();
    const Q = {
      topLeft: { x: A.topLeft.x * C, y: A.topLeft.y * E },
      topRight: { x: A.topRight.x * C, y: A.topRight.y * E },
      bottomRight: { x: A.bottomRight.x * C, y: A.bottomRight.y * E },
      bottomLeft: { x: A.bottomLeft.x * C, y: A.bottomLeft.y * E }
    };
    B.strokeStyle = "#00FF00", B.lineWidth = 3, B.setLineDash([5, 5]), B.beginPath(), B.moveTo(Q.topLeft.x, Q.topLeft.y), B.lineTo(Q.topRight.x, Q.topRight.y), B.lineTo(Q.bottomRight.x, Q.bottomRight.y), B.lineTo(Q.bottomLeft.x, Q.bottomLeft.y), B.closePath(), B.stroke(), B.fillStyle = "#00FF00", B.setLineDash([]);
    const i = 8 * Math.max(C, E);
    Object.values(Q).forEach((s) => {
      B.beginPath(), B.arc(s.x, s.y, i, 0, 2 * Math.PI), B.fill();
    }), B.restore();
  }
  /**
   * Calculate detection confidence (placeholder - can be enhanced)
   */
  calculateConfidence(A) {
    return 0.8;
  }
  /**
   * Capture current frame as document with perspective transform
   */
  async captureDocument() {
    if (!this.currentCorners || !this.video)
      throw new Error("No stable document detected");
    const { extractDocument: A } = await Promise.resolve().then(() => uA), g = document.createElement("canvas");
    g.width = this.video.videoWidth, g.height = this.video.videoHeight, g.getContext("2d").drawImage(this.video, 0, 0);
    const E = this.video.videoWidth / this.outputCanvas.width, B = this.video.videoHeight / this.outputCanvas.height, Q = {
      topLeft: {
        x: this.currentCorners.topLeft.x * E,
        y: this.currentCorners.topLeft.y * B
      },
      topRight: {
        x: this.currentCorners.topRight.x * E,
        y: this.currentCorners.topRight.y * B
      },
      bottomRight: {
        x: this.currentCorners.bottomRight.x * E,
        y: this.currentCorners.bottomRight.y * B
      },
      bottomLeft: {
        x: this.currentCorners.bottomLeft.x * E,
        y: this.currentCorners.bottomLeft.y * B
      }
    };
    return A(g, Q);
  }
  /**
   * Get current scanner statistics
   */
  getStats() {
    return {
      isRunning: this.isRunning,
      currentFPS: this.currentFPS,
      videoResolution: this.video ? `${this.video.videoWidth}x${this.video.videoHeight}` : null,
      hasStableDetection: this.currentCorners !== null,
      stabilizationProgress: `${this.stableResults.length}/${this.options.stabilizationFrames}`
    };
  }
}
async function kA() {
  try {
    const A = (await navigator.mediaDevices.enumerateDevices()).filter((g) => g.kind === "videoinput");
    return {
      available: A.length > 0,
      deviceCount: A.length,
      devices: A
    };
  } catch (I) {
    return console.error("Error checking webcam availability:", I), { available: !1, error: I.message };
  }
}
function fA(I, A = 800) {
  const { width: g, height: C } = I, E = Math.max(g, C);
  if (E <= A)
    return {
      scaledImageData: I,
      scaleFactor: 1,
      originalDimensions: { width: g, height: C },
      scaledDimensions: { width: g, height: C }
    };
  const B = A / E, Q = Math.round(g * B), i = Math.round(C * B);
  console.log(`Smart downscale: ${g}x${C} -> ${Q}x${i} (factor: ${B.toFixed(3)})`);
  const s = document.createElement("canvas");
  s.width = g, s.height = C, s.getContext("2d").putImageData(I, 0, 0);
  const o = document.createElement("canvas");
  o.width = Q, o.height = i;
  const e = o.getContext("2d");
  return e.imageSmoothingEnabled = !0, e.imageSmoothingQuality = "high", e.drawImage(s, 0, 0, g, C, 0, 0, Q, i), {
    scaledImageData: e.getImageData(0, 0, Q, i),
    scaleFactor: 1 / B,
    // Return inverse for compatibility with existing code
    originalDimensions: { width: g, height: C },
    scaledDimensions: { width: Q, height: i }
  };
}
async function K(I, A = {}) {
  const g = A.debug ? {} : null, C = A.maxProcessingDimension || 800, { scaledImageData: E, scaleFactor: B, originalDimensions: Q, scaledDimensions: i } = fA(I, C);
  g && (g.preprocessing = {
    originalDimensions: Q,
    scaledDimensions: i,
    scaleFactor: B,
    maxProcessingDimension: C
  });
  const { width: s, height: t } = E, o = await SA(E, {
    lowThreshold: A.lowThreshold || 75,
    // Match OpenCV values
    highThreshold: A.highThreshold || 200,
    // Match OpenCV values
    dilationKernelSize: A.dilationKernelSize || 3,
    // Match OpenCV value 
    dilationIterations: A.dilationIterations || 1,
    debug: g
  }), e = V(o, {
    minArea: (A.minArea || 1e3) / (B * B),
    // Adjust minArea for scaled image
    debug: g,
    width: s,
    height: t
  });
  if (!e || e.length === 0)
    return console.log("No document detected"), {
      success: !1,
      message: "No document detected",
      debug: g
    };
  const a = e[0], n = EA(a, {
    epsilon: A.epsilon
    // Pass epsilon for approximation
  });
  let D = n;
  return B !== 1 && (D = {
    topLeft: { x: n.topLeft.x * B, y: n.topLeft.y * B },
    topRight: { x: n.topRight.x * B, y: n.topRight.y * B },
    bottomRight: { x: n.bottomRight.x * B, y: n.bottomRight.y * B },
    bottomLeft: { x: n.bottomLeft.x * B, y: n.bottomLeft.y * B }
  }), {
    success: !0,
    contour: a,
    corners: D,
    debug: g
  };
}
function JA(I, A) {
  function g(s) {
    const t = [];
    for (let o = 0; o < 4; o++) {
      const [e, a] = s[o];
      t.push([e, a, 1, 0, 0, 0, -e * A[o][0], -a * A[o][0]]), t.push([0, 0, 0, e, a, 1, -e * A[o][1], -a * A[o][1]]);
    }
    return t;
  }
  const C = g(I), E = [
    A[0][0],
    A[0][1],
    A[1][0],
    A[1][1],
    A[2][0],
    A[2][1],
    A[3][0],
    A[3][1]
  ];
  function B(s, t) {
    const o = s.length, e = s[0].length, a = s.map((h) => h.slice()), n = t.slice();
    for (let h = 0; h < e; h++) {
      let y = h;
      for (let c = h + 1; c < o; c++)
        Math.abs(a[c][h]) > Math.abs(a[y][h]) && (y = c);
      [a[h], a[y]] = [a[y], a[h]], [n[h], n[y]] = [n[y], n[h]];
      for (let c = h + 1; c < o; c++) {
        const r = a[c][h] / a[h][h];
        for (let w = h; w < e; w++)
          a[c][w] -= r * a[h][w];
        n[c] -= r * n[h];
      }
    }
    const D = new Array(e);
    for (let h = e - 1; h >= 0; h--) {
      let y = n[h];
      for (let c = h + 1; c < e; c++)
        y -= a[h][c] * D[c];
      D[h] = y / a[h][h];
    }
    return D;
  }
  const Q = B(C, E);
  return [
    [Q[0], Q[1], Q[2]],
    [Q[3], Q[4], Q[5]],
    [Q[6], Q[7], 1]
  ];
}
function MA(I, A, g) {
  const { topLeft: C, topRight: E, bottomRight: B, bottomLeft: Q } = g, i = Math.hypot(B.x - Q.x, B.y - Q.y), s = Math.hypot(E.x - C.x, E.y - C.y), t = Math.round(Math.max(i, s)), o = Math.hypot(E.x - B.x, E.y - B.y), e = Math.hypot(C.x - Q.x, C.y - Q.y), a = Math.round(Math.max(o, e));
  I.canvas.width = t, I.canvas.height = a;
  const n = [
    [C.x, C.y],
    [E.x, E.y],
    [B.x, B.y],
    [Q.x, Q.y]
  ], D = [
    [0, 0],
    [t - 1, 0],
    [t - 1, a - 1],
    [0, a - 1]
  ], h = JA(n, D);
  mA(I, A, h, t, a);
}
function LA(I) {
  const A = I[0][0], g = I[0][1], C = I[0][2], E = I[1][0], B = I[1][1], Q = I[1][2], i = I[2][0], s = I[2][1], t = I[2][2], o = B * t - Q * s, e = -(E * t - Q * i), a = E * s - B * i, n = -(g * t - C * s), D = A * t - C * i, h = -(A * s - g * i), y = g * Q - C * B, c = -(A * Q - C * E), r = A * B - g * E, w = A * o + g * e + C * a;
  if (w === 0) throw new Error("Singular matrix");
  return [
    [o / w, n / w, y / w],
    [e / w, D / w, c / w],
    [a / w, h / w, r / w]
  ];
}
function mA(I, A, g, C, E) {
  const B = LA(g), Q = document.createElement("canvas");
  Q.width = A.width || A.naturalWidth, Q.height = A.height || A.naturalHeight;
  const i = Q.getContext("2d");
  i.drawImage(A, 0, 0, Q.width, Q.height);
  const s = i.getImageData(0, 0, Q.width, Q.height), t = I.createImageData(C, E);
  for (let o = 0; o < E; o++)
    for (let e = 0; e < C; e++) {
      const a = B[2][0] * e + B[2][1] * o + B[2][2], n = (B[0][0] * e + B[0][1] * o + B[0][2]) / a, D = (B[1][0] * e + B[1][1] * o + B[1][2]) / a, h = Math.max(0, Math.min(Q.width - 2, n)), y = Math.max(0, Math.min(Q.height - 2, D)), c = Math.floor(h), r = Math.floor(y), w = h - c, F = y - r;
      for (let R = 0; R < 4; R++) {
        const d = s.data[(r * Q.width + c) * 4 + R], S = s.data[(r * Q.width + (c + 1)) * 4 + R], G = s.data[((r + 1) * Q.width + c) * 4 + R], f = s.data[((r + 1) * Q.width + (c + 1)) * 4 + R];
        t.data[(o * C + e) * 4 + R] = (1 - w) * (1 - F) * d + w * (1 - F) * S + (1 - w) * F * G + w * F * f;
      }
    }
  I.putImageData(t, 0, 0);
}
async function YA(I, A = {}) {
  const g = A.mode || "highlight", C = A.output || "canvas";
  A.debug;
  let E, B, Q;
  if (I instanceof ImageData)
    E = I, B = I.width, Q = I.height;
  else {
    const o = document.createElement("canvas");
    o.width = I.width || I.naturalWidth, o.height = I.height || I.naturalHeight;
    const e = o.getContext("2d");
    e.drawImage(I, 0, 0, o.width, o.height), E = e.getImageData(0, 0, o.width, o.height), B = o.width, Q = o.height;
  }
  const i = await K(E, A);
  if (!i.success)
    return {
      output: null,
      corners: null,
      contour: null,
      debug: i.debug,
      success: !1,
      message: i.message || "No document detected"
    };
  let s;
  if (g === "extract") {
    s = document.createElement("canvas");
    const o = s.getContext("2d");
    MA(o, I, i.corners);
  } else
    s = document.createElement("canvas"), s.width = B, s.height = Q, s.getContext("2d").drawImage(I, 0, 0, B, Q);
  let t;
  return C === "canvas" ? t = s : C === "imagedata" ? t = s.getContext("2d").getImageData(0, 0, s.width, s.height) : C === "dataurl" ? t = s.toDataURL() : t = s, {
    output: t,
    corners: i.corners,
    contour: i.contour,
    debug: i.debug,
    success: !0,
    message: "Document detected"
  };
}
const uA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LiveScanner: dA,
  checkWebcamAvailability: kA,
  detectDocument: K,
  scanDocument: YA
}, Symbol.toStringTag, { value: "Module" }));
export {
  dA as LiveScanner,
  kA as checkWebcamAvailability,
  K as detectDocument,
  YA as scanDocument
};
//# sourceMappingURL=scanic.js.map
