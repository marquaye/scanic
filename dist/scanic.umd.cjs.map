{"version":3,"file":"scanic.umd.cjs","sources":["../src/constants.js","../src/contourDetection.js","../src/cornerDetection.js","../wasm_blur/pkg/wasm_blur.js","../src/edgeDetection.js","../src/liveScanner.js","../src/index.js"],"sourcesContent":["/**\r\n * Constants used throughout the library\r\n */\r\n\r\nexport const VERSION = '1.0.0';\r\n\r\nexport const DEFAULTS = {\r\n  // Edge detection params\r\n  GAUSSIAN_SIGMA: 1.1,\r\n  LOW_THRESHOLD: 50,\r\n  HIGH_THRESHOLD: 150,\r\n  \r\n  // Contour detection params\r\n  MIN_CONTOUR_AREA: 1000,\r\n  MIN_CONTOUR_POINTS: 10,\r\n  \r\n  // Debug options\r\n  DEBUG_OVERLAY_OPACITY: 0.7\r\n};","/**\r\n * Pure JavaScript implementation of contour detection algorithms\r\n * Based on Suzuki, S. and Abe, K. (1985). Topological structural analysis of digitized binary images by border following.\r\n * Replaces the previous flood-fill based connected components analysis.\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\n\r\n// Constants for different retrieval modes (subset of OpenCV)\r\nconst RETR_EXTERNAL = 0;\r\nconst RETR_LIST = 1;\r\n// Constants for different approximation methods (subset of OpenCV)\r\nconst CHAIN_APPROX_NONE = 1;\r\nconst CHAIN_APPROX_SIMPLE = 2;\r\n\r\n// Deltas for 8-connectivity neighborhood checks (0-7 clockwise from top)\r\n// Corresponds to OpenCV's chain code directions\r\nconst deltas = [\r\n  { dx:  0, dy: -1 }, // 0: Top\r\n  { dx:  1, dy: -1 }, // 1: Top-right\r\n  { dx:  1, dy:  0 }, // 2: Right\r\n  { dx:  1, dy:  1 }, // 3: Bottom-right\r\n  { dx:  0, dy:  1 }, // 4: Bottom\r\n  { dx: -1, dy:  1 }, // 5: Bottom-left\r\n  { dx: -1, dy:  0 }, // 6: Left\r\n  { dx: -1, dy: -1 }  // 7: Top-left\r\n];\r\n\r\n/**\r\n * Detects contours in a binary edge image using Suzuki's border following algorithm.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (pixels > 0 are foreground)\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.width] - Image width (required if not square)\r\n * @param {number} [options.height] - Image height (required if not square)\r\n * @param {number} [options.mode=RETR_LIST] - Contour retrieval mode (RETR_EXTERNAL or RETR_LIST)\r\n * @param {number} [options.method=CHAIN_APPROX_SIMPLE] - Contour approximation method (CHAIN_APPROX_NONE or CHAIN_APPROX_SIMPLE)\r\n * @param {number} [options.minArea=DEFAULTS.MIN_CONTOUR_AREA] - Minimum contour area filter (applied after detection)\r\n * @param {Object} [options.debug] - Optional debug object to store intermediate results\r\n * @returns {Array} Array of contours, each contour is an array of points {x, y}. Sorted by area (largest first).\r\n */\r\nexport function detectDocumentContour(edges, options = {}) {\r\n  const width = options.width || Math.sqrt(edges.length);\r\n  const height = options.height || edges.length / width;\r\n  const mode = options.mode !== undefined ? options.mode : RETR_LIST;\r\n  const method = options.method !== undefined ? options.method : CHAIN_APPROX_SIMPLE;\r\n  const minArea = options.minArea || DEFAULTS.MIN_CONTOUR_AREA;\r\n\r\n  // Create a padded label map to simplify boundary checks.\r\n  // 0: background\r\n  // 1: foreground (unlabeled)\r\n  // >= 2: contour ID (2, 3, ...)\r\n  const paddedWidth = width + 2;\r\n  const paddedHeight = height + 2;\r\n  const labels = new Int32Array(paddedWidth * paddedHeight); // Initialized to 0\r\n\r\n  // Copy edges data to the label map, mapping foreground pixels to 1\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (edges[y * width + x] > 0) {\r\n        labels[(y + 1) * paddedWidth + (x + 1)] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  const contours = [];\r\n  let nextContourId = 2; // Start labeling contours from 2\r\n\r\n  // Raster scan\r\n  for (let y = 1; y <= height; y++) {\r\n    for (let x = 1; x <= width; x++) {\r\n      const currentPixelLabel = labels[y * paddedWidth + x];\r\n      const leftPixelLabel = labels[y * paddedWidth + (x - 1)];\r\n\r\n      let startPoint = null;\r\n      let isOuter = false;\r\n      let initialDirection = -1;\r\n\r\n      if (currentPixelLabel === 1 && leftPixelLabel === 0) {\r\n        // Found the start of an outer contour boundary (NBD = 1 in Suzuki's terms)\r\n        isOuter = true;\r\n        startPoint = { x: x, y: y };\r\n        initialDirection = 2; // Start searching right\r\n        // if (options.debug) console.log(`Outer contour start at (${x-1}, ${y-1})`);\r\n      } else if (currentPixelLabel === 0 && leftPixelLabel >= 1 && leftPixelLabel !== -1) {\r\n         // Found the start of a hole contour boundary (NBD >= 2 in Suzuki's terms)\r\n         // Check if the left pixel is already part of a traced contour border\r\n         // If leftPixelLabel is > 1, it might be already traced. If it's 1, it's an unlabeled foreground pixel.\r\n         // We only start tracing if the left pixel is unlabeled foreground (1).\r\n         if (leftPixelLabel === 1) {\r\n             isOuter = false;\r\n             startPoint = { x: x - 1, y: y };\r\n             initialDirection = 6; // Start searching left\r\n            //  if (options.debug) console.log(`Hole contour start at (${x-1-1}, ${y-1})`);\r\n         }\r\n      }\r\n\r\n\r\n      if (startPoint) {\r\n        // If mode is RETR_EXTERNAL, only process outer contours\r\n        if (mode === RETR_EXTERNAL && !isOuter) {\r\n          // Mark the starting pixel of the hole so we don't process it again\r\n          // Use a special marker (-1) to distinguish from contour IDs\r\n           labels[startPoint.y * paddedWidth + startPoint.x] = -1;\r\n           continue;\r\n        }\r\n\r\n        const contourId = nextContourId++;\r\n        const points = traceContour(labels, paddedWidth, paddedHeight, startPoint, initialDirection, contourId);\r\n\r\n        if (points && points.length > 0) {\r\n            let finalPoints = points;\r\n            if (method === CHAIN_APPROX_SIMPLE) {\r\n                finalPoints = simplifyChainApproxSimple(points);\r\n            }\r\n\r\n            // Adjust points to original image coordinates (remove padding offset)\r\n            const adjustedPoints = finalPoints.map(p => ({ x: p.x - 1, y: p.y - 1 }));\r\n\r\n            if (adjustedPoints.length >= (method === CHAIN_APPROX_SIMPLE ? 4 : DEFAULTS.MIN_CONTOUR_POINTS)) { // Need at least 4 points for a simple polygon approx\r\n                const contour = {\r\n                    id: contourId,\r\n                    points: adjustedPoints,\r\n                    isOuter: isOuter,\r\n                    // Calculate area and bounding box later if needed for filtering/sorting\r\n                };\r\n                contours.push(contour);\r\n            }\r\n        } else {\r\n             // Handle single point contours or errors if necessary\r\n             // Mark the start point if trace failed or resulted in no points\r\n             if (labels[startPoint.y * paddedWidth + startPoint.x] === 1) {\r\n                 labels[startPoint.y * paddedWidth + startPoint.x] = contourId; // Mark as visited\r\n             }\r\n        }\r\n      } else if (currentPixelLabel >= 1 && leftPixelLabel >= 1 && currentPixelLabel !== leftPixelLabel) {\r\n          // Handle merging contours or complex topology if needed (not implemented for RETR_LIST/EXTERNAL)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Calculate area and bounding box for filtering and sorting\r\n  contours.forEach(contour => {\r\n    contour.area = calculateContourArea(contour.points);\r\n    contour.boundingBox = calculateBoundingBox(contour.points);\r\n  });\r\n\r\n  // Filter by minimum area\r\n  const filteredContours = contours.filter(contour => contour.area >= minArea);\r\n\r\n  // Sort contours by area (largest first)\r\n  filteredContours.sort((a, b) => b.area - a.area);\r\n\r\n  // console.log(`Found ${contours.length} contours before filtering, ${filteredContours.length} after filtering.`);\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.labels = labels; // Store the final label map\r\n    options.debug.rawContours = contours; // Store contours before filtering/sorting\r\n    options.debug.finalContours = filteredContours;\r\n    // console.log('Contour detection debug info stored');\r\n  }\r\n  return filteredContours // Return only the points array per contour\r\n}\r\n\r\n/**\r\n * Traces a contour boundary using border following.\r\n * @param {Int32Array} labels - The label map (modified during tracing)\r\n * @param {number} width - Padded width of the label map\r\n * @param {number} height - Padded height of the label map\r\n * @param {Object} startPoint - Starting point {x, y} in padded coordinates\r\n * @param {number} initialDirection - Initial search direction (0-7)\r\n * @param {number} contourId - The ID to label this contour with\r\n * @returns {Array} Array of points {x, y} in padded coordinates, or null if error\r\n */\r\nfunction traceContour(labels, width, height, startPoint, initialDirection, contourId) {\r\n    const points = [];\r\n    const visitedPoints = new Set(); // Use a Set for efficient duplicate checking\r\n    let currentPoint = { ...startPoint };\r\n    let prevDirection = -1; // Store the direction from which we arrived at currentPoint\r\n\r\n    // Mark the starting pixel with the contour ID\r\n    labels[startPoint.y * width + startPoint.x] = contourId;\r\n\r\n    let count = 0; // Safety break\r\n    const maxSteps = width * height; // Max possible steps\r\n\r\n    while (count++ < maxSteps) {\r\n        // Determine the direction to start searching from (relative to the direction we came from)\r\n        // In Suzuki's paper, this is based on the chain code of the previous step.\r\n        // Simplified: Start searching from the direction after the one that led us here.\r\n        // If we arrived from direction `d`, the next pixel must be in `(d+1)%8` to `(d+7)%8`.\r\n        // Let's adapt OpenCV's logic: search starts from (prevDirection + 2) % 8 clockwise.\r\n        // If it's the first step, prevDirection is unknown, use initialDirection logic.\r\n\r\n        let searchDirection;\r\n        if (prevDirection === -1) {\r\n            // First step: Use initialDirection logic (e.g., start right for outer, left for inner)\r\n            // The initial search should find the *first* pixel of the contour boundary clockwise.\r\n            // Let's refine the initial search based on OpenCV's approach:\r\n            // Find the first non-zero pixel starting from `initialDirection` clockwise.\r\n            let found = false;\r\n            for (let i = 0; i < 8; i++) {\r\n                searchDirection = (initialDirection + i) % 8;\r\n                const nextX = currentPoint.x + deltas[searchDirection].dx;\r\n                const nextY = currentPoint.y + deltas[searchDirection].dy;\r\n                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && labels[nextY * width + nextX] > 0) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) return null; // Should not happen if startPoint is valid\r\n\r\n        } else {\r\n            // Subsequent steps: Start search from (prevDirection + 2) % 8 clockwise\r\n             searchDirection = (prevDirection + 2) % 8;\r\n        }\r\n\r\n\r\n        let nextPoint = null;\r\n        let nextDirection = -1;\r\n\r\n        // Search clockwise for the next boundary pixel\r\n        for (let i = 0; i < 8; i++) {\r\n            const checkDirection = (searchDirection + i) % 8;\r\n            const checkX = currentPoint.x + deltas[checkDirection].dx;\r\n            const checkY = currentPoint.y + deltas[checkDirection].dy;\r\n\r\n            // Check bounds (should be within padded area)\r\n            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {\r\n                const pixelLabel = labels[checkY * width + checkX];\r\n                if (pixelLabel > 0) { // Found a foreground pixel (labeled or unlabeled)\r\n                    nextPoint = { x: checkX, y: checkY };\r\n                    // The direction *from* currentPoint *to* nextPoint is checkDirection\r\n                    nextDirection = checkDirection;\r\n                    // The direction *from* which we will arrive *at* nextPoint is (checkDirection + 4) % 8\r\n                    prevDirection = (checkDirection + 4) % 8;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!nextPoint) {\r\n            // Should not happen in a well-formed contour, maybe isolated pixel?\r\n             if (points.length === 0) { // If it's just the start point\r\n                 points.push({ ...currentPoint }); // Add the single point\r\n             }\r\n            console.warn(`Contour tracing stopped unexpectedly at (${currentPoint.x-1}, ${currentPoint.y-1}) for contour ${contourId}`);\r\n            break;\r\n        }\r\n\r\n        // Add the *current* point to the list before moving\r\n        const pointKey = `${currentPoint.x},${currentPoint.y}`;\r\n        if (visitedPoints.has(pointKey)) {\r\n            // console.warn(`Duplicate point detected at (${currentPoint.x}, ${currentPoint.y}) for contour ${contourId}`);\r\n            // console.warn(points)\r\n            // console.warn(filtered)\r\n            return points; // Avoid infinite loops on duplicate points\r\n        }\r\n        points.push({ ...currentPoint });\r\n        visitedPoints.add(pointKey);\r\n        \r\n\r\n        // Mark the next pixel if it's unlabeled\r\n        if (labels[nextPoint.y * width + nextPoint.x] === 1) {\r\n            labels[nextPoint.y * width + nextPoint.x] = contourId;\r\n        }\r\n\r\n        // Move to the next point\r\n        currentPoint = nextPoint;\r\n\r\n        // Check if we returned to the start point\r\n        if (currentPoint.x === startPoint.x && currentPoint.y === startPoint.y) {\r\n            // Check if we came from the same direction as the initial step search ended.\r\n            // This is complex, let's use a simpler check: if we are back at start, we are done.\r\n            // OpenCV has more sophisticated checks involving i4 == i0 && i3 == i1.\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (count >= maxSteps) {\r\n        console.warn(`Contour tracing exceeded max steps for contour ${contourId}`);\r\n        return null; // Indicate potential error\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\n/**\r\n * Simplifies a contour polygon using CHAIN_APPROX_SIMPLE.\r\n * Removes intermediate points that lie on the straight line segment between their neighbors.\r\n * @param {Array} points - Array of contour points {x, y}\r\n * @returns {Array} Simplified array of points\r\n */\r\nfunction simplifyChainApproxSimple(points) {\r\n    if (points.length <= 2) {\r\n        return points;\r\n    }\r\n\r\n    const simplifiedPoints = [];\r\n    const n = points.length;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        const prevPoint = points[(i + n - 1) % n]; // Handle wrap around\r\n        const currentPoint = points[i];\r\n        const nextPoint = points[(i + 1) % n]; // Handle wrap around\r\n\r\n        // Check for collinearity: (y2-y1)*(x3-x2) == (y3-y2)*(x2-x1)\r\n        const dx1 = currentPoint.x - prevPoint.x;\r\n        const dy1 = currentPoint.y - prevPoint.y;\r\n        const dx2 = nextPoint.x - currentPoint.x;\r\n        const dy2 = nextPoint.y - currentPoint.y;\r\n\r\n        // If points are not collinear, keep the current point\r\n        if (dx1 * dy2 !== dy1 * dx2) {\r\n            simplifiedPoints.push(currentPoint);\r\n        }\r\n    }\r\n\r\n    // Handle cases where all points are collinear (e.g., straight line)\r\n    // In this case, the above loop might remove all points. Keep first and last?\r\n    // OpenCV keeps the two endpoints of the line segment.\r\n    if (simplifiedPoints.length === 0 && n > 0) {\r\n         // If all points were collinear, return the start and end points of the original sequence\r\n         // This requires knowing the original start/end, which isn't trivial with wrap-around.\r\n         // Let's return the first and the point furthest from the first.\r\n         if (n === 1) return [points[0]];\r\n         if (n === 2) return points;\r\n\r\n         // Find the point most distant from the first point to represent the line segment\r\n         let maxDistSq = 0;\r\n         let farthestIdx = 1;\r\n         const p0 = points[0];\r\n         for(let i = 1; i < n; i++) {\r\n             const pi = points[i];\r\n             const distSq = (pi.x - p0.x)**2 + (pi.y - p0.y)**2;\r\n             if (distSq > maxDistSq) {\r\n                 maxDistSq = distSq;\r\n                 farthestIdx = i;\r\n             }\r\n         }\r\n         // Ensure order if needed, but for simple approx, just two points is fine.\r\n         return [points[0], points[farthestIdx]];\r\n    }\r\n\r\n\r\n    return simplifiedPoints;\r\n}\r\n\r\n\r\n// --- Helper functions (keep or adapt from original) ---\r\n\r\n/**\r\n * Calculates the area of a contour using the shoelace formula\r\n * @param {Array} points - Array of point coordinates {x, y}\r\n * @returns {number} Contour area\r\n */\r\nfunction calculateContourArea(points) {\r\n  let area = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 3) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n;\r\n    area += points[i].x * points[j].y;\r\n    area -= points[j].x * points[i].y;\r\n  }\r\n\r\n  return Math.abs(area) / 2;\r\n}\r\n\r\n/**\r\n * Calculates the bounding box of a contour\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {Object} Bounding box with minX, minY, maxX, maxY properties\r\n */\r\nfunction calculateBoundingBox(points) {\r\n  if (points.length === 0) {\r\n      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n  }\r\n  let minX = points[0].x;\r\n  let minY = points[0].y;\r\n  let maxX = points[0].x;\r\n  let maxY = points[0].y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      minX = Math.min(minX, point.x);\r\n      minY = Math.min(minY, point.y);\r\n      maxX = Math.max(maxX, point.x);\r\n      maxY = Math.max(maxY, point.y);\r\n  }\r\n\r\n  return { minX, minY, maxX, maxY };\r\n}\r\n\r\n\r\n// --- Functions below are no longer directly used by detectDocumentContour ---\r\n// --- but might be useful elsewhere or can be removed ---\r\n\r\n/**\r\n * Simplifies a contour using the Ramer-Douglas-Peucker algorithm\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} points - Array of point coordinates\r\n * @param {number} epsilon - Epsilon value for simplification\r\n * @returns {Array} Simplified contour points\r\n */\r\nexport function simplifyContour(points, epsilon = 1.0) {\r\n  // ... (keep existing implementation if needed elsewhere) ...\r\n   if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Find point with the maximum distance\r\n  let maxDistance = 0;\r\n  let index = 0;\r\n\r\n  const firstPoint = points[0];\r\n  const lastPoint = points[points.length - 1];\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\r\n\r\n    if (distance > maxDistance) {\r\n      maxDistance = distance;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  // If max distance is greater than epsilon, recursively simplify\r\n  if (maxDistance > epsilon) {\r\n    // Recursive simplification\r\n    const firstSegment = simplifyContour(points.slice(0, index + 1), epsilon);\r\n    const secondSegment = simplifyContour(points.slice(index), epsilon);\r\n\r\n    // Concatenate the two segments\r\n    return firstSegment.slice(0, -1).concat(secondSegment);\r\n  } else {\r\n    // Return just the endpoints\r\n    return [firstPoint, lastPoint];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the perpendicular distance from a point to a line\r\n * (Helper for RDP simplifyContour, keep if that function is kept)\r\n * @param {Object} point - Point to measure from\r\n * @param {Object} lineStart - Start point of the line\r\n * @param {Object} lineEnd - End point of the line\r\n * @returns {number} Perpendicular distance\r\n */\r\nfunction perpendicularDistance(point, lineStart, lineEnd) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   const dx = lineEnd.x - lineStart.x;\r\n  const dy = lineEnd.y - lineStart.y;\r\n\r\n  // Line length squared\r\n  const lineLengthSq = dx * dx + dy * dy;\r\n\r\n  if (lineLengthSq === 0) {\r\n    // Point to point distance if the line has zero length\r\n    return Math.sqrt(\r\n      Math.pow(point.x - lineStart.x, 2) +\r\n      Math.pow(point.y - lineStart.y, 2)\r\n    );\r\n  }\r\n\r\n   // Calculate the projection parameter t\r\n  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq;\r\n\r\n  let closestPointX, closestPointY;\r\n\r\n  if (t < 0) {\r\n    closestPointX = lineStart.x;\r\n    closestPointY = lineStart.y;\r\n  } else if (t > 1) {\r\n    closestPointX = lineEnd.x;\r\n    closestPointY = lineEnd.y;\r\n  } else {\r\n    closestPointX = lineStart.x + t * dx;\r\n    closestPointY = lineStart.y + t * dy;\r\n  }\r\n\r\n  // Calculate the distance from the point to the closest point on the line segment\r\n  const distDx = point.x - closestPointX;\r\n  const distDy = point.y - closestPointY;\r\n  return Math.sqrt(distDx * distDx + distDy * distDy);\r\n\r\n  /* // Original implementation using area formula (distance to infinite line)\r\n  const lineLength = Math.sqrt(lineLengthSq);\r\n  const area = Math.abs(dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);\r\n  return area / lineLength;\r\n  */\r\n}\r\n\r\n/**\r\n * Creates a polygon approximation of a contour using RDP.\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} contourPoints - Array of points {x, y}\r\n * @param {number} epsilon - Epsilon for polygon approximation (relative to perimeter)\r\n * @returns {Array} Array of polygon points\r\n */\r\nexport function approximatePolygon(contourPoints, epsilon = 0.02) {\r\n  // Calculate contour perimeter\r\n  const perimeter = calculateContourPerimeter(contourPoints);\r\n\r\n  // Calculate epsilon based on perimeter\r\n  const actualEpsilon = epsilon * perimeter;\r\n\r\n  // Simplify the contour using RDP\r\n  const simplifiedPoints = simplifyContour(contourPoints, actualEpsilon);\r\n\r\n  return simplifiedPoints;\r\n}\r\n\r\n/**\r\n * Calculates the perimeter of a contour\r\n * (Helper for RDP approximatePolygon, keep if that function is kept)\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {number} Contour perimeter\r\n */\r\nfunction calculateContourPerimeter(points) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   let perimeter = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 2) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n; // Wrap around for the last segment\r\n    const dx = points[i].x - points[j].x;\r\n    const dy = points[i].y - points[j].y;\r\n    perimeter += Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\n// Flood fill is no longer used for contour detection\r\n/*\r\nfunction floodFill(edges, labels, width, height, startX, startY, label) {\r\n  // ... (original floodFill implementation removed) ...\r\n}\r\n*/","/**\r\n * Pure JavaScript implementation for detecting corners of a document\r\n * Replaces OpenCV's corner detection and point finding logic\r\n */\r\n\r\nimport { approximatePolygon } from './contourDetection.js';\r\n\r\n/**\r\n * Calculate distance between two points\r\n * @param {Object} p1 - First point {x, y}\r\n * @param {Object} p2 - Second point {x, y}\r\n * @returns {number} Distance between points\r\n */\r\nexport function distance(p1, p2) {\r\n  return Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n}\r\n\r\n/**\r\n * Find the center point of a contour\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Center point {x, y}\r\n */\r\nfunction findCenter(points) {\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  \r\n  for (const point of points) {\r\n    sumX += point.x;\r\n    sumY += point.y;\r\n  }\r\n  \r\n  return {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length\r\n  };\r\n}\r\n\r\n/**\r\n * Find the four corners of a document contour\r\n * @param {Object} contour - Contour object with points property\r\n * @param {Object} options - Configuration options\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nexport function findCornerPoints(contour, options = {}) {\r\n  if (!contour || !contour.points || contour.points.length < 4) {\r\n    console.warn('Contour does not have enough points for corner detection');\r\n    return null;\r\n  }\r\n  \r\n  // Try to find a quadrilateral approximation of the contour\r\n  const epsilon = options.epsilon || 0.02;\r\n  const approximation = approximatePolygon(contour, epsilon);\r\n  \r\n  let corners;\r\n  \r\n  // If we get exactly 4 points, we can use them as corners\r\n  if (approximation && approximation.length === 4) {\r\n    // console.log('Found 4-point approximation, using as corners');\r\n    corners = orderCornerPoints(approximation);\r\n  } else {\r\n    // console.log(`Polygon approximation gave ${approximation ? approximation.length : 'null'} points, using coordinate extremes method`);\r\n    // Fallback: Use the coordinate extremes method on the original contour points\r\n    corners = findCornersByCoordinateExtremes(contour.points); \r\n  }\r\n  \r\n  // Ensure all corners were found\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n      console.warn('Failed to find all four corners.', corners);\r\n      // Return null or partial corners? Returning null might be safer downstream.\r\n      return null; \r\n  }\r\n\r\n  // Debug info\r\n  console.log('Corner points:', corners);\r\n  return corners;\r\n}\r\n\r\n/**\r\n * Find corners by finding points with min/max coordinate sums/differences.\r\n * This is an alternative heuristic for finding corners.\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nfunction findCornersByCoordinateExtremes(points) {\r\n  if (!points || points.length === 0) return null;\r\n\r\n  let topLeft = points[0];      // Min sum x + y\r\n  let topRight = points[0];     // Max diff x - y\r\n  let bottomRight = points[0];  // Max sum x + y\r\n  let bottomLeft = points[0];   // Min diff x - y\r\n\r\n  let minSum = topLeft.x + topLeft.y;\r\n  let maxDiff = topRight.x - topRight.y;\r\n  let maxSum = bottomRight.x + bottomRight.y;\r\n  let minDiff = bottomLeft.x - bottomLeft.y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    const point = points[i];\r\n    const sum = point.x + point.y;\r\n    const diff = point.x - point.y;\r\n\r\n    // Top-Left (min sum)\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      topLeft = point;\r\n    }\r\n    // Bottom-Right (max sum)\r\n    if (sum > maxSum) {\r\n      maxSum = sum;\r\n      bottomRight = point;\r\n    }\r\n    // Top-Right (max diff)\r\n    if (diff > maxDiff) {\r\n      maxDiff = diff;\r\n      topRight = point;\r\n    }\r\n    // Bottom-Left (min diff)\r\n    if (diff < minDiff) {\r\n      minDiff = diff;\r\n      bottomLeft = point;\r\n    }\r\n  }\r\n\r\n  return {\r\n    topLeft,\r\n    topRight,\r\n    bottomRight,\r\n    bottomLeft\r\n  };\r\n}\r\n\r\n/**\r\n * Orders 4 points in clockwise order starting from top-left\r\n * @param {Array} points - Array of 4 points to order\r\n * @returns {Object} Object with ordered points\r\n */\r\nfunction orderCornerPoints(points) {\r\n  if (points.length !== 4) {\r\n    console.warn(`Expected 4 points, got ${points.length}`);\r\n    return null;\r\n  }\r\n  \r\n  // Calculate centroid\r\n  const center = findCenter(points);\r\n  \r\n  // Sort the points by their angles relative to the center\r\n  const sortedPoints = [...points].sort((a, b) => {\r\n    const angleA = Math.atan2(a.y - center.y, a.x - center.x);\r\n    const angleB = Math.atan2(b.y - center.y, b.x - center.x);\r\n    return angleA - angleB;\r\n  });\r\n  \r\n  // Now find the top-left point (minimum sum of x and y)\r\n  let minSum = Infinity;\r\n  let minIndex = 0;\r\n  \r\n  for (let i = 0; i < 4; i++) {\r\n    const sum = sortedPoints[i].x + sortedPoints[i].y;\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      minIndex = i;\r\n    }\r\n  }\r\n  \r\n  // Reorder array to start with the top-left point\r\n  const orderedPoints = [\r\n    sortedPoints[minIndex],\r\n    sortedPoints[(minIndex + 1) % 4],\r\n    sortedPoints[(minIndex + 2) % 4],\r\n    sortedPoints[(minIndex + 3) % 4]\r\n  ];\r\n  \r\n  // Return as named corners\r\n  return {\r\n    topLeft: orderedPoints[0],\r\n    topRight: orderedPoints[1],\r\n    bottomRight: orderedPoints[2],\r\n    bottomLeft: orderedPoints[3]\r\n  };\r\n}","let wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @returns {Uint8Array}\n */\nexport function dilate(edges, width, height, kernel_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate(ptr0, len0, width, height, kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @param {number} kernel_size\n * @param {number} sigma\n * @param {boolean} l2_gradient\n * @param {boolean} apply_dilation\n * @param {number} dilation_kernel_size\n * @returns {Uint8Array}\n */\nexport function canny_edge_detector_full(grayscale, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.canny_edge_detector_full(ptr0, len0, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Applies double thresholding and hysteresis using a stack-based approach.\n * Optimized version with SIMD for threshold comparisons and better memory access patterns.\n * Follows OpenCV's logic more closely.\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Edge map as Vec<u8> (0: weak edge/potential, 1: non-edge, 2: strong edge)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Creates a binary edge image from the hysteresis edge map\n * SIMD-optimized version for converting edge map to binary\n *\n * # Arguments\n * * `edge_map` - Edge map from hysteresis thresholding (0, 1, 2 values)\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Uint8Array} edge_map\n * @returns {Uint8Array}\n */\nexport function edge_map_to_binary(edge_map) {\n    const ptr0 = passArray8ToWasm0(edge_map, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_map_to_binary(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined hysteresis thresholding and binary conversion\n * This is a convenience function that combines both steps for efficiency\n * Optimized to avoid intermediate allocations where possible\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding_binary(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding_binary(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function blur(grayscale, width, height, kernel_size, sigma) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.blur(ptr0, len0, width, height, kernel_size, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint16ArrayMemory0 = null;\n\nfunction getUint16ArrayMemory0() {\n    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {\n        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16ArrayMemory0;\n}\n\nfunction passArray16ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 2, 2) >>> 0;\n    getUint16ArrayMemory0().set(arg, ptr / 2);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * @param {Int16Array} dx\n * @param {Int16Array} dy\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_gradient\n * @returns {Float32Array}\n */\nexport function non_maximum_suppression(dx, dy, width, height, l2_gradient) {\n    const ptr0 = passArray16ToWasm0(dx, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(dy, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.non_maximum_suppression(ptr0, len0, ptr1, len1, width, height, l2_gradient);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\nlet cachedInt16ArrayMemory0 = null;\n\nfunction getInt16ArrayMemory0() {\n    if (cachedInt16ArrayMemory0 === null || cachedInt16ArrayMemory0.byteLength === 0) {\n        cachedInt16ArrayMemory0 = new Int16Array(wasm.memory.buffer);\n    }\n    return cachedInt16ArrayMemory0;\n}\n\nfunction getArrayI16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n/**\n * @param {Uint8Array} blurred\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function calculate_gradients(blurred, width, height) {\n    const ptr0 = passArray8ToWasm0(blurred, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_gradients(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat32ArrayMemory0 = null;\n    cachedInt16ArrayMemory0 = null;\n    cachedUint16ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('wasm_blur_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","/**\r\n * Pure JavaScript implementation of edge detection algorithms\r\n * Inspired by OpenCV's Canny edge detector\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport init, { \r\n  blur as wasmBlur, \r\n  calculate_gradients as wasmGradients, \r\n  dilate as wasmDilate, \r\n  non_maximum_suppression as wasmMaximumSuppression, \r\n  canny_edge_detector_full as wasmFullCanny,\r\n  hysteresis_thresholding as wasmHysteresis,\r\n  hysteresis_thresholding_binary as wasmHysteresisBinary\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize the wasm module\r\nconst wasmReady = init();\r\n\r\n/**\r\n * Converts ImageData to grayscale (separate from blur for consistency with jscanify)\r\n * @param {ImageData} imageData - Original image data\r\n * @returns {Uint8ClampedArray} Grayscale image data (1 channel)\r\n */\r\nexport function convertToGrayscale(imageData) {\r\n  const { width, height, data } = imageData;\r\n  const grayscale = new Uint8ClampedArray(width * height);\r\n  \r\n  // Convert to grayscale with integer math (faster than floating point)\r\n  // Use bit shifting for multiplication (>>8 is equivalent to /256)\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    // 54 (~0.2126*256), 183 (~0.7152*256), 19 (~0.0722*256)\r\n    grayscale[j] = (data[i] * 54 + data[i+1] * 183 + data[i+2] * 19) >> 8;\r\n  }\r\n  \r\n  return grayscale;\r\n}\r\n\r\n/**\r\n * Applies Gaussian blur to a grayscale image (matching jscanify's approach)\r\n * @param {Uint8ClampedArray} grayscale - Grayscale image data\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (should be 5 to match jscanify)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data\r\n */\r\nexport function gaussianBlurGrayscale(grayscale, width, height, kernelSize = 5, sigma = 0) {\r\n  // If sigma is 0, calculate it from kernel size (OpenCV default)\r\n  if (sigma === 0) {\r\n    sigma = 0.3 * ((kernelSize - 1) * 0.5 - 1) + 0.8;\r\n  }\r\n  \r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  \r\n  // Create and normalize Gaussian kernel once\r\n  const kernel = createGaussianKernel(kernelSize, sigma);\r\n  \r\n  // Preallocate arrays\r\n  const tempArray = new Uint8ClampedArray(width * height);\r\n  const blurred = new Uint8ClampedArray(width * height);\r\n  \r\n  // Horizontal pass - process rows in a single loop to improve cache locality\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel horizontally with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const xOffset = Math.min(width - 1, Math.max(0, x + k));\r\n        sum += grayscale[rowOffset + xOffset] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      tempArray[rowOffset + x] = sum;\r\n    }\r\n  }\r\n  \r\n  // Vertical pass - process columns with better memory access pattern\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel vertically with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const yOffset = Math.min(height - 1, Math.max(0, y + k));\r\n        sum += tempArray[yOffset * width + x] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      blurred[y * width + x] = Math.round(sum);\r\n    }\r\n  }\r\n  \r\n  return blurred;\r\n}\r\n\r\n/**\r\n * Legacy wrapper for backwards compatibility\r\n * @param {ImageData} imageData - Original image data\r\n * @param {number} sigma - Gaussian sigma parameter (standard deviation)\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data (1 channel)\r\n */\r\nexport function gaussianBlur(imageData, sigma = DEFAULTS.GAUSSIAN_SIGMA, forcedKernelSize = null) {\r\n  const grayscale = convertToGrayscale(imageData);\r\n  const kernelSize = forcedKernelSize || 5; // Default to 5 like jscanify\r\n  return gaussianBlurGrayscale(grayscale, imageData.width, imageData.height, kernelSize, sigma);\r\n}\r\n\r\n/**\r\n * Creates a 1D Gaussian kernel\r\n * @param {number} size - Kernel size (odd number)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Float32Array} Gaussian kernel\r\n */\r\nfunction createGaussianKernel(size, sigma) {\r\n  const kernel = new Float32Array(size);\r\n  const halfSize = Math.floor(size / 2);\r\n  \r\n  let sum = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const x = i - halfSize;\r\n    // Gaussian function: (1/(sigma*sqrt(2*PI))) * e^(-(x^2)/(2*sigma^2))\r\n    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));\r\n    sum += kernel[i];\r\n  }\r\n  \r\n  // Normalize kernel\r\n  for (let i = 0; i < size; i++) {\r\n    kernel[i] /= sum;\r\n  }\r\n  \r\n  return kernel;\r\n}\r\n\r\n/**\r\n * Calculates the gradients (dx, dy) using Sobel operators\r\n * @param {Uint8ClampedArray} blurred - Blurred grayscale image\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @returns {{dx: Int16Array, dy: Int16Array}} Object containing gradient arrays\r\n */\r\nfunction calculateGradients(blurred, width, height) {\r\n  // Use Int16Array to store gradients, allowing negative values\r\n  const dx = new Int16Array(width * height);\r\n  const dy = new Int16Array(width * height);\r\n  \r\n  // Find gradients by unrolling the Sobel operator loops\r\n  for (let y = 1; y < height - 1; y++) {\r\n    const rowOffset = y * width;\r\n    const prevRowOffset = (y - 1) * width;\r\n    const nextRowOffset = (y + 1) * width;\r\n\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const currentIdx = rowOffset + x;\r\n\r\n      // Get neighborhood pixels\r\n      const p0 = blurred[prevRowOffset + x - 1];\r\n      const p1 = blurred[prevRowOffset + x];\r\n      const p2 = blurred[prevRowOffset + x + 1];\r\n      const p3 = blurred[rowOffset + x - 1];\r\n      const p5 = blurred[rowOffset + x + 1];\r\n      const p6 = blurred[nextRowOffset + x - 1];\r\n      const p7 = blurred[nextRowOffset + x];\r\n      const p8 = blurred[nextRowOffset + x + 1];\r\n      \r\n      // Calculate Sobel gradients\r\n      const gx = (p2 - p0) + 2 * (p5 - p3) + (p8 - p6);\r\n      const gy = (p6 + 2 * p7 + p8) - (p0 + 2 * p1 + p2);\r\n      \r\n      dx[currentIdx] = gx;\r\n      dy[currentIdx] = gy;\r\n    }\r\n  }\r\n  \r\n  return { dx, dy };\r\n}\r\n\r\n\r\n/**\r\n * Applies non-maximum suppression to the gradient magnitude\r\n * @param {Int16Array} dx - Gradient in x-direction\r\n * @param {Int16Array} dy - Gradient in y-direction\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {boolean} L2gradient - Whether to use L2 norm for magnitude\r\n * @returns {Float32Array} Suppressed magnitude (using Float32 for precision)\r\n */\r\nfunction nonMaximumSuppression(dx, dy, width, height, L2gradient) {\r\n  // Use Float32Array for magnitude to preserve precision before thresholding\r\n  const magnitude = new Float32Array(width * height);\r\n  const suppressed = new Float32Array(width * height);\r\n  \r\n  // Calculate magnitude for all pixels first\r\n  for (let i = 0; i < dx.length; i++) {\r\n    const gx = dx[i];\r\n    const gy = dy[i];\r\n    if (L2gradient) {\r\n      magnitude[i] = Math.sqrt(gx * gx + gy * gy);\r\n    } else {\r\n      magnitude[i] = Math.abs(gx) + Math.abs(gy); // L1 norm\r\n    }\r\n  }\r\n  \r\n  // Perform non-maximum suppression\r\n  for (let y = 1; y < height - 1; y++) {\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = magnitude[idx];\r\n      \r\n      // Skip pixels with zero magnitude\r\n      if (mag === 0) {\r\n        suppressed[idx] = 0;\r\n        continue;\r\n      }\r\n      \r\n      const gx = dx[idx];\r\n      const gy = dy[idx];\r\n      \r\n      let neighbor1 = 0, neighbor2 = 0;\r\n      \r\n      // Determine neighbors based on gradient direction\r\n      // Use absolute values to determine dominant direction\r\n      const absGx = Math.abs(gx);\r\n      const absGy = Math.abs(gy);\r\n      \r\n      if (absGy > absGx * 2.4142) { // Vertical edge (angle near 90 or 270)\r\n        neighbor1 = magnitude[idx - width]; // top\r\n        neighbor2 = magnitude[idx + width]; // bottom\r\n      } else if (absGx > absGy * 2.4142) { // Horizontal edge (angle near 0 or 180)\r\n        neighbor1 = magnitude[idx - 1]; // left\r\n        neighbor2 = magnitude[idx + 1]; // right\r\n      } else { // Diagonal edge\r\n        // Determine diagonal direction based on signs of gx and gy\r\n        const s = (gx ^ gy) < 0 ? -1 : 1; // Check if signs are different\r\n        if (gy > 0) { // Gradient points down\r\n          neighbor1 = magnitude[(y - 1) * width + (x - s)]; // top-left/right\r\n          neighbor2 = magnitude[(y + 1) * width + (x + s)]; // bottom-right/left\r\n        } else { // Gradient points up\r\n          neighbor1 = magnitude[(y + 1) * width + (x - s)]; // bottom-left/right\r\n          neighbor2 = magnitude[(y - 1) * width + (x + s)]; // top-right/left\r\n        }\r\n        // Refined diagonal check (approximating OpenCV's logic)\r\n        // Check 45 degrees (top-right / bottom-left)\r\n        if ((gx > 0 && gy > 0) || (gx < 0 && gy < 0)) { // Quadrants 1 & 3\r\n             neighbor1 = magnitude[(y - 1) * width + (x + 1)]; // top-right\r\n             neighbor2 = magnitude[(y + 1) * width + (x - 1)]; // bottom-left\r\n        } else { // Quadrants 2 & 4 (135 degrees)\r\n             neighbor1 = magnitude[(y - 1) * width + (x - 1)]; // top-left\r\n             neighbor2 = magnitude[(y + 1) * width + (x + 1)]; // bottom-right\r\n        }\r\n      }\r\n      \r\n      // If the pixel's magnitude is greater than or equal to its neighbors\r\n      // along the gradient direction, keep it. Otherwise, suppress it.\r\n      if (mag >= neighbor1 && mag >= neighbor2) {\r\n        suppressed[idx] = mag;\r\n      } else {\r\n        suppressed[idx] = 0;\r\n      }\r\n    }\r\n  }\r\n  return suppressed;\r\n}\r\n\r\n\r\n/**\r\n * Applies double thresholding and hysteresis using a stack-based approach.\r\n * Follows OpenCV's logic more closely.\r\n * @param {Float32Array} suppressed - Suppressed magnitude (Float32Array)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} lowThreshold - Low threshold value\r\n * @param {number} highThreshold - High threshold value\r\n * @returns {Uint8Array} Edge map (0: non-edge, 2: edge pixel)\r\n */\r\nfunction hysteresisThresholding(suppressed, width, height, lowThreshold, highThreshold) {\r\n  // Map values: 0 = weak edge (potential), 1 = non-edge, 2 = strong edge\r\n  const edgeMap = new Uint8Array(width * height);\r\n  const stack = [];\r\n  \r\n  // First pass: Identify strong edges and potential weak edges\r\n  for (let y = 1; y < height - 1; y++) { // Iterate excluding borders\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = suppressed[idx];\r\n      \r\n      if (mag >= highThreshold) {\r\n        // Strong edge pixel\r\n        edgeMap[idx] = 2;\r\n        stack.push({ x, y });\r\n      } else if (mag >= lowThreshold) {\r\n        // Weak edge pixel (potential edge)\r\n        edgeMap[idx] = 0; // Mark as potential\r\n      } else {\r\n        // Non-edge pixel\r\n        edgeMap[idx] = 1; // Mark as non-edge\r\n      }\r\n    }\r\n  }\r\n  // Initialize borders as non-edge (value 1)\r\n   for (let x = 0; x < width; x++) {\r\n       edgeMap[x] = 1; // Top row\r\n       edgeMap[(height - 1) * width + x] = 1; // Bottom row\r\n   }\r\n   for (let y = 1; y < height - 1; y++) {\r\n       edgeMap[y * width] = 1; // Left column\r\n       edgeMap[y * width + width - 1] = 1; // Right column\r\n   }\r\n\r\n\r\n  // Second pass: Hysteresis - connect weak edges to strong edges\r\n  const dxNeighbors = [-1, 0, 1, -1, 1, -1, 0, 1];\r\n  const dyNeighbors = [-1, -1, -1, 0, 0, 1, 1, 1];\r\n  \r\n  while (stack.length > 0) {\r\n    const { x, y } = stack.pop();\r\n    \r\n    // Check all 8 neighbors\r\n    for (let i = 0; i < 8; i++) {\r\n      const nx = x + dxNeighbors[i];\r\n      const ny = y + dyNeighbors[i];\r\n      const nidx = ny * width + nx;\r\n      \r\n      // Check bounds (already handled by border initialization)\r\n      // If neighbor is a weak edge (value 0), promote it to strong (value 2) and add to stack\r\n      if (edgeMap[nidx] === 0) {\r\n        edgeMap[nidx] = 2; // Promote to strong edge\r\n        stack.push({ x: nx, y: ny });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Note: Pixels that were initially weak (0) but not connected remain 0.\r\n  // Pixels below lowThreshold remain 1. Only pixels marked 2 are considered final edges.\r\n  \r\n  return edgeMap; // Return the map with 0, 1, 2 values\r\n}\r\n\r\n/**\r\n * Applies morphological dilation to binary image using a separable (two-pass) approach.\r\n * This is much faster than a 2D kernel for square structuring elements.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (0 or 255)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (default 5 to match jscanify)\r\n * @returns {Uint8ClampedArray} Dilated edge image\r\n */\r\nexport function dilateEdges(edges, width, height, kernelSize = 5) {\r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  const temp = new Uint8ClampedArray(width * height);\r\n  const dilated = new Uint8ClampedArray(width * height);\r\n\r\n  // Horizontal pass\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    for (let x = 0; x < width; x++) {\r\n      let maxVal = 0;\r\n      // Find max in horizontal neighborhood\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const nx = x + k;\r\n        if (nx >= 0 && nx < width) {\r\n          const val = edges[rowOffset + nx];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      temp[rowOffset + x] = maxVal;\r\n    }\r\n  }\r\n\r\n  // Vertical pass\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let maxVal = 0;\r\n      // Find max in vertical neighborhood from temp array\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const ny = y + k;\r\n        if (ny >= 0 && ny < height) {\r\n          const val = temp[ny * width + x];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      dilated[y * width + x] = maxVal;\r\n    }\r\n  }\r\n  \r\n  return dilated;\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation matching jscanify's approach\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.lowThreshold=75] - Low threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.highThreshold=200] - High threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.sigma=0] - Gaussian blur sigma (0 means auto-calculate from kernel size)\r\n * @param {number} [options.kernelSize=5] - Gaussian kernel size (matching jscanify)\r\n * @param {boolean} [options.L2gradient=false] - Use L2 norm for gradient magnitude (like OpenCV default)\r\n * @param {boolean} [options.applyDilation=true] - Apply dilation after Canny (matching jscanify)\r\n * @param {number} [options.dilationKernelSize=5] - Dilation kernel size\r\n * @param {boolean} [options.useWasmBlur=false] - Use WASM for Gaussian blur\r\n * @param {boolean} [options.useWasmGradients=false] - Use WASM for gradient calculation\r\n * @param {boolean} [options.useWasmDilation=false] - Use WASM for dilation\r\n * @param {boolean} [options.useWasmNMS=false] - Use WASM for non-maximum suppression\r\n * @param {boolean} [options.useWasmHysteresis=false] - Use WASM for hysteresis thresholding\r\n * @param {boolean} [options.useWasmFullCanny=false] - Use the full WASM Canny implementation\r\n * @param {object} [options.debug={}] - Object to store intermediate results if provided\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetector(imageData, options = {}) {\r\n  // Timing table setup\r\n  const timings = [];\r\n  const tStart = performance.now();\r\n\r\n  const { width, height } = imageData;\r\n  let lowThreshold = options.lowThreshold !== undefined ? options.lowThreshold : 75;\r\n  let highThreshold = options.highThreshold !== undefined ? options.highThreshold : 200;\r\n  const kernelSize = options.kernelSize || 5; // Match jscanify's 5x5 kernel\r\n  const sigma = options.sigma || 0; // Let the blur function calculate sigma\r\n  const L2gradient = options.L2gradient === undefined ? false : options.L2gradient;\r\n  const applyDilation = options.applyDilation !== undefined ? options.applyDilation : true;\r\n  const dilationKernelSize = options.dilationKernelSize || 5;\r\n  const useWasmBlur = true;\r\n  const useWasmGradients = false; \r\n  const useWasmDilation = true;\r\n  const useWasmNMS = true;\r\n  const useWasmHysteresis = options.useWasmHysteresis !== undefined ? options.useWasmHysteresis : false;\r\n  const useWasmFullCanny = false;\r\n\r\n  // Ensure high threshold is greater than low threshold\r\n  if (lowThreshold >= highThreshold) {\r\n      console.warn(`Canny Edge Detector: lowThreshold (${lowThreshold}) should be lower than highThreshold (${highThreshold}). Swapping them.`);\r\n      [lowThreshold, highThreshold] = [highThreshold, lowThreshold];\r\n  }\r\n\r\n  // Step 1: Convert to grayscale\r\n  let t0 = performance.now();\r\n  const grayscale = convertToGrayscale(imageData);\r\n  let t1 = performance.now();\r\n  timings.push({ step: 'Grayscale', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) options.debug.grayscale = grayscale;\r\n\r\n  // Step 2: Apply Gaussian blur (JS or WASM)\r\n  let blurred;\r\n  t0 = performance.now();\r\n  if (useWasmBlur) {\r\n    try {\r\n      await wasmReady; // Ensure wasm is initialized\r\n      blurred = wasmBlur(grayscale, width, height, kernelSize, sigma);\r\n    } catch (e) {\r\n      blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n    }\r\n  } else {\r\n    blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gaussian Blur', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) {\r\n    options.debug.blurred = blurred;\r\n  }\r\n\r\n  // Step 3: Compute gradients (dx, dy)\r\n  t0 = performance.now();\r\n  let dx, dy;\r\n  if (useWasmGradients) {\r\n    try {\r\n      await wasmReady; // Ensure wasm is initialized\r\n      const gradientResult = wasmGradients(blurred, width, height);\r\n      dx = new Int16Array(gradientResult.gx);\r\n      dy = new Int16Array(gradientResult.gy);\r\n    } catch (e) {\r\n      const gradients = calculateGradients(blurred, width, height);\r\n      dx = gradients.dx;\r\n      dy = gradients.dy;\r\n    }\r\n  } else {\r\n    const gradients = calculateGradients(blurred, width, height);\r\n    dx = gradients.dx;\r\n    dy = gradients.dy;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gradients', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 4: Apply non-maximum suppression\r\n  t0 = performance.now();\r\n  let suppressed;\r\n  if (useWasmNMS) {\r\n    try {\r\n      await wasmReady;\r\n      suppressed = await wasmMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    } catch (e) {\r\n      suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    }\r\n  } else {\r\n    suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Non-Max Suppression', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 5: Apply double thresholding and hysteresis\r\n  t0 = performance.now();\r\n  const finalLowThreshold = L2gradient ? lowThreshold * lowThreshold : lowThreshold;\r\n  const finalHighThreshold = L2gradient ? highThreshold * highThreshold : highThreshold;\r\n  \r\n  let edgeMap;\r\n  if (useWasmHysteresis) {\r\n    try {\r\n      await wasmReady;\r\n      edgeMap = wasmHysteresis(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    } catch (e) {\r\n      console.warn(\"WASM hysteresis failed, falling back to JS:\", e);\r\n      edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    }\r\n  } else {\r\n    edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n  }\r\n  \r\n  t1 = performance.now();\r\n  timings.push({ step: 'Hysteresis', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 6: Create binary image (0 or 255)\r\n  t0 = performance.now();\r\n  const cannyEdges = new Uint8ClampedArray(width * height);\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    cannyEdges[i] = edgeMap[i] === 2 ? 255 : 0;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Binary Image', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 7: Apply dilation if requested (matching jscanify)\r\n  t0 = performance.now();\r\n  let finalEdges = cannyEdges;\r\n  if (applyDilation) {\r\n    if (useWasmDilation) {\r\n      try {\r\n        await wasmReady; // Ensure wasm is initialized\r\n        finalEdges = wasmDilate(cannyEdges, width, height, dilationKernelSize);\r\n      } catch (e) {\r\n        finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n      }\r\n    } else {\r\n      finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n    }\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Dilation', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.dx = dx; // Int16Array\r\n    options.debug.dy = dy; // Int16Array\r\n    // Calculate magnitude separately for debugging if needed\r\n     const magnitude = new Float32Array(width * height);\r\n     for (let i = 0; i < dx.length; i++) {\r\n         const gx = dx[i]; const gy = dy[i];\r\n         magnitude[i] = L2gradient ? Math.sqrt(gx * gx + gy * gy) : Math.abs(gx) + Math.abs(gy);\r\n     }\r\n     options.debug.magnitude = magnitude; // Float32Array (raw magnitude)\r\n    options.debug.suppressed = suppressed; // Float32Array (after NMS)\r\n    options.debug.edgeMap = edgeMap; // Uint8Array (0, 1, 2 values from hysteresis)\r\n    options.debug.cannyEdges = cannyEdges; // Uint8ClampedArray (0 or 255, before dilation)\r\n    options.debug.finalEdges = finalEdges; // Uint8ClampedArray (0 or 255, after dilation if applied)\r\n    options.debug.timings = timings;\r\n  }\r\n\r\n  const tEnd = performance.now();\r\n  timings.unshift({ step: 'Total', ms: (tEnd - tStart).toFixed(2) });\r\n  // Print timing table\r\n  console.table(timings);\r\n\r\n  return finalEdges; // Return the final binary edge image\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation using WASM, for comparison or direct use\r\n * This function is intended to match the performance and output of the JS cannyEdgeDetector,\r\n * but runs entirely in WASM for potentially faster execution.\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options (same as cannyEdgeDetector)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetectorWasm(imageData, options = {}) {\r\n  // Directly call the WASM canny_edge_detector_full function\r\n  let result;\r\n  try {\r\n    await wasmReady; // Ensure wasm is initialized\r\n    console.log('Using WASM Full Canny');\r\n    result = wasmFullCanny(imageData.data, imageData.width, imageData.height, options.lowThreshold, options.highThreshold, options.sigma, options.kernelSize, options.L2gradient, options.applyDilation, options.dilationKernelSize);\r\n  } catch (e) {\r\n    console.error(\"WASM full Canny failed:\", e);\r\n    throw e; // Rethrow to let the caller handle the error\r\n  }\r\n  \r\n  // Convert result to Uint8ClampedArray (if not already)\r\n  const edges = new Uint8ClampedArray(result);\r\n  \r\n  return edges;\r\n}","/**\r\n * Live document scanner for webcam integration\r\n * Provides efficient real-time document detection with frame rate optimization\r\n */\r\n\r\nimport { scanDocument } from './index.js';\r\n\r\nexport class LiveScanner {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      targetFPS: options.targetFPS || 10, // Limit FPS for performance\r\n      detectionInterval: options.detectionInterval || 150, // ms between detections\r\n      confidenceThreshold: options.confidenceThreshold || 0.7,\r\n      stabilizationFrames: options.stabilizationFrames || 3,\r\n      maxProcessingDimension: options.maxProcessingDimension || 500, // Lower for live processing\r\n      ...options\r\n    };\r\n    \r\n    this.isRunning = false;\r\n    this.stream = null;\r\n    this.video = null;\r\n    this.canvas = null;\r\n    this.ctx = null;\r\n    this.outputCanvas = null;\r\n    this.outputCtx = null;\r\n    \r\n    // Performance tracking\r\n    this.lastDetectionTime = 0;\r\n    this.frameCount = 0;\r\n    this.detectionCount = 0;\r\n    this.lastFPSUpdate = 0;\r\n    this.currentFPS = 0;\r\n    \r\n    // Detection state\r\n    this.lastResult = null;\r\n    this.stableResults = [];\r\n    this.currentCorners = null;\r\n    \r\n    // Callbacks\r\n    this.onDetection = null;\r\n    this.onFPSUpdate = null;\r\n    this.onError = null;\r\n  }\r\n  \r\n  /**\r\n   * Initialize webcam access and start live scanning\r\n   * @param {HTMLElement} outputElement - Canvas element to render results to\r\n   * @param {Object} constraints - MediaStream constraints\r\n   */\r\n  async init(outputElement, constraints = {}) {\r\n    try {\r\n      this.outputCanvas = outputElement;\r\n      this.outputCtx = this.outputCanvas.getContext('2d');\r\n      \r\n      // Create hidden video element for webcam stream\r\n      this.video = document.createElement('video');\r\n      this.video.style.display = 'none';\r\n      this.video.autoplay = true;\r\n      this.video.muted = true;\r\n      this.video.playsInline = true;\r\n      document.body.appendChild(this.video);\r\n      \r\n      // Create hidden canvas for processing\r\n      this.canvas = document.createElement('canvas');\r\n      this.ctx = this.canvas.getContext('2d');\r\n      \r\n      // Get webcam stream\r\n      const defaultConstraints = {\r\n        video: {\r\n          width: { ideal: 1280, max: 1920 },\r\n          height: { ideal: 720, max: 1080 },\r\n          facingMode: 'environment' // Use back camera on mobile\r\n        },\r\n        audio: false\r\n      };\r\n      \r\n      const finalConstraints = { ...defaultConstraints, ...constraints };\r\n      this.stream = await navigator.mediaDevices.getUserMedia(finalConstraints);\r\n      this.video.srcObject = this.stream;\r\n      \r\n      // Wait for video to be ready\r\n      await new Promise((resolve) => {\r\n        this.video.addEventListener('loadedmetadata', resolve, { once: true });\r\n      });\r\n      \r\n      // Set canvas sizes\r\n      this.canvas.width = this.video.videoWidth;\r\n      this.canvas.height = this.video.videoHeight;\r\n      this.outputCanvas.width = this.video.videoWidth;\r\n      this.outputCanvas.height = this.video.videoHeight;\r\n      \r\n      console.log(`Live scanner initialized: ${this.video.videoWidth}x${this.video.videoHeight}`);\r\n      \r\n    } catch (error) {\r\n      console.error('Failed to initialize live scanner:', error);\r\n      if (this.onError) this.onError(error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Start the live scanning loop\r\n   */\r\n  start() {\r\n    if (this.isRunning || !this.video) {\r\n      console.warn('Scanner already running or not initialized');\r\n      return;\r\n    }\r\n    \r\n    this.isRunning = true;\r\n    this.lastDetectionTime = Date.now();\r\n    this.lastFPSUpdate = Date.now();\r\n    this.frameCount = 0;\r\n    this.detectionCount = 0;\r\n    \r\n    console.log('Live scanner started');\r\n    this.processFrame();\r\n  }\r\n  \r\n  /**\r\n   * Stop the live scanning\r\n   */\r\n  stop() {\r\n    this.isRunning = false;\r\n    \r\n    if (this.stream) {\r\n      this.stream.getTracks().forEach(track => track.stop());\r\n      this.stream = null;\r\n    }\r\n    \r\n    if (this.video) {\r\n      this.video.remove();\r\n      this.video = null;\r\n    }\r\n    \r\n    console.log('Live scanner stopped');\r\n  }\r\n  \r\n  /**\r\n   * Main processing loop - optimized for performance\r\n   */\r\n  async processFrame() {\r\n    if (!this.isRunning) return;\r\n    \r\n    const now = Date.now();\r\n    this.frameCount++;\r\n    \r\n    try {\r\n      // Draw current video frame to output canvas\r\n      this.outputCtx.drawImage(this.video, 0, 0, this.outputCanvas.width, this.outputCanvas.height);\r\n      \r\n      // Only run detection at specified intervals\r\n      const timeSinceLastDetection = now - this.lastDetectionTime;\r\n      if (timeSinceLastDetection >= this.options.detectionInterval) {\r\n        this.lastDetectionTime = now;\r\n        this.detectionCount++;\r\n        \r\n        // Capture frame for processing\r\n        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);\r\n        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n        \r\n        // Run detection asynchronously to avoid blocking\r\n        this.detectDocumentAsync(imageData).catch(error => {\r\n          console.error('Detection error:', error);\r\n          if (this.onError) this.onError(error);\r\n        });\r\n      }\r\n      \r\n      // Draw current overlay if we have stable corners\r\n      if (this.currentCorners) {\r\n        this.drawDocumentOverlay(this.currentCorners);\r\n      }\r\n      \r\n      // Update FPS counter\r\n      if (now - this.lastFPSUpdate >= 1000) {\r\n        this.currentFPS = Math.round(this.frameCount * 1000 / (now - this.lastFPSUpdate));\r\n        this.frameCount = 0;\r\n        this.lastFPSUpdate = now;\r\n        \r\n        if (this.onFPSUpdate) {\r\n          this.onFPSUpdate({\r\n            renderFPS: this.currentFPS,\r\n            detectionFPS: Math.round(this.detectionCount * 1000 / 1000),\r\n            lastDetectionTime: timeSinceLastDetection\r\n          });\r\n        }\r\n        this.detectionCount = 0;\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('Frame processing error:', error);\r\n      if (this.onError) this.onError(error);\r\n    }\r\n    \r\n    // Schedule next frame\r\n    requestAnimationFrame(() => this.processFrame());\r\n  }\r\n  \r\n  /**\r\n   * Run document detection asynchronously\r\n   */\r\n  async detectDocumentAsync(imageData) {\r\n    try {\r\n      const result = await scanDocument(imageData, {\r\n        ...this.options,\r\n        mode: 'detect', // Only detect, no image processing\r\n        debug: false // Disable debug for performance\r\n      });\r\n      \r\n      if (result.success && result.corners) {\r\n        this.updateStableCorners(result.corners);\r\n        \r\n        if (this.onDetection) {\r\n          this.onDetection({\r\n            corners: result.corners,\r\n            confidence: this.calculateConfidence(result),\r\n            isStable: this.stableResults.length >= this.options.stabilizationFrames\r\n          });\r\n        }\r\n      } else {\r\n        // Gradually fade out corners if no detection\r\n        if (this.stableResults.length > 0) {\r\n          this.stableResults.pop();\r\n          if (this.stableResults.length === 0) {\r\n            this.currentCorners = null;\r\n          }\r\n        }\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('Document detection failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Update stable corner detection with smoothing\r\n   */\r\n  updateStableCorners(newCorners) {\r\n    this.stableResults.push(newCorners);\r\n    \r\n    // Keep only recent results\r\n    if (this.stableResults.length > this.options.stabilizationFrames) {\r\n      this.stableResults.shift();\r\n    }\r\n    \r\n    // Calculate average corners for stability\r\n    if (this.stableResults.length >= this.options.stabilizationFrames) {\r\n      this.currentCorners = this.averageCorners(this.stableResults);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Calculate average corners from multiple detections for smoothing\r\n   */\r\n  averageCorners(cornersList) {\r\n    const avg = {\r\n      topLeft: { x: 0, y: 0 },\r\n      topRight: { x: 0, y: 0 },\r\n      bottomRight: { x: 0, y: 0 },\r\n      bottomLeft: { x: 0, y: 0 }\r\n    };\r\n    \r\n    cornersList.forEach(corners => {\r\n      Object.keys(avg).forEach(key => {\r\n        avg[key].x += corners[key].x;\r\n        avg[key].y += corners[key].y;\r\n      });\r\n    });\r\n    \r\n    const count = cornersList.length;\r\n    Object.keys(avg).forEach(key => {\r\n      avg[key].x = Math.round(avg[key].x / count);\r\n      avg[key].y = Math.round(avg[key].y / count);\r\n    });\r\n    \r\n    return avg;\r\n  }\r\n  \r\n  /**\r\n   * Draw document overlay on output canvas\r\n   */\r\n  drawDocumentOverlay(corners, ctx = null, scaleX = 1, scaleY = 1) {\r\n    const targetCtx = ctx || this.outputCtx;\r\n    \r\n    // Save context\r\n    targetCtx.save();\r\n    \r\n    // Scale corners if needed\r\n    const scaledCorners = {\r\n      topLeft: { x: corners.topLeft.x * scaleX, y: corners.topLeft.y * scaleY },\r\n      topRight: { x: corners.topRight.x * scaleX, y: corners.topRight.y * scaleY },\r\n      bottomRight: { x: corners.bottomRight.x * scaleX, y: corners.bottomRight.y * scaleY },\r\n      bottomLeft: { x: corners.bottomLeft.x * scaleX, y: corners.bottomLeft.y * scaleY }\r\n    };\r\n    \r\n    // Draw document border\r\n    targetCtx.strokeStyle = '#00FF00';\r\n    targetCtx.lineWidth = 3;\r\n    targetCtx.setLineDash([5, 5]);\r\n    \r\n    targetCtx.beginPath();\r\n    targetCtx.moveTo(scaledCorners.topLeft.x, scaledCorners.topLeft.y);\r\n    targetCtx.lineTo(scaledCorners.topRight.x, scaledCorners.topRight.y);\r\n    targetCtx.lineTo(scaledCorners.bottomRight.x, scaledCorners.bottomRight.y);\r\n    targetCtx.lineTo(scaledCorners.bottomLeft.x, scaledCorners.bottomLeft.y);\r\n    targetCtx.closePath();\r\n    targetCtx.stroke();\r\n    \r\n    // Draw corners\r\n    targetCtx.fillStyle = '#00FF00';\r\n    targetCtx.setLineDash([]);\r\n    const cornerSize = 8 * Math.max(scaleX, scaleY); // Scale corner size too\r\n    \r\n    Object.values(scaledCorners).forEach(corner => {\r\n      targetCtx.beginPath();\r\n      targetCtx.arc(corner.x, corner.y, cornerSize, 0, 2 * Math.PI);\r\n      targetCtx.fill();\r\n    });\r\n    \r\n    // Restore context\r\n    targetCtx.restore();\r\n  }\r\n  \r\n  /**\r\n   * Calculate detection confidence (placeholder - can be enhanced)\r\n   */\r\n  calculateConfidence(result) {\r\n    // Simple confidence based on contour area and corner detection\r\n    // This could be enhanced with more sophisticated metrics\r\n    return 0.8; // Placeholder\r\n  }\r\n  \r\n  /**\r\n   * Capture current frame as document with perspective transform\r\n   */\r\n  async captureDocument() {\r\n    if (!this.currentCorners || !this.video) {\r\n      throw new Error('No stable document detected');\r\n    }\r\n    \r\n    // Import extractDocument function dynamically to avoid circular dependency\r\n    const { extractDocument } = await import('./index.js');\r\n    \r\n    // Create a high-quality capture\r\n    const captureCanvas = document.createElement('canvas');\r\n    captureCanvas.width = this.video.videoWidth;\r\n    captureCanvas.height = this.video.videoHeight;\r\n    const captureCtx = captureCanvas.getContext('2d');\r\n    captureCtx.drawImage(this.video, 0, 0);\r\n    \r\n    // Scale corners to match the capture resolution\r\n    const scaleX = this.video.videoWidth / this.outputCanvas.width;\r\n    const scaleY = this.video.videoHeight / this.outputCanvas.height;\r\n    \r\n    const scaledCorners = {\r\n      topLeft: { \r\n        x: this.currentCorners.topLeft.x * scaleX, \r\n        y: this.currentCorners.topLeft.y * scaleY \r\n      },\r\n      topRight: { \r\n        x: this.currentCorners.topRight.x * scaleX, \r\n        y: this.currentCorners.topRight.y * scaleY \r\n      },\r\n      bottomRight: { \r\n        x: this.currentCorners.bottomRight.x * scaleX, \r\n        y: this.currentCorners.bottomRight.y * scaleY \r\n      },\r\n      bottomLeft: { \r\n        x: this.currentCorners.bottomLeft.x * scaleX, \r\n        y: this.currentCorners.bottomLeft.y * scaleY \r\n      }\r\n    };\r\n    \r\n    // Apply perspective transform and return the corrected document\r\n    return extractDocument(captureCanvas, scaledCorners);\r\n  }\r\n  \r\n  /**\r\n   * Get current scanner statistics\r\n   */\r\n  getStats() {\r\n    return {\r\n      isRunning: this.isRunning,\r\n      currentFPS: this.currentFPS,\r\n      videoResolution: this.video ? `${this.video.videoWidth}x${this.video.videoHeight}` : null,\r\n      hasStableDetection: this.currentCorners !== null,\r\n      stabilizationProgress: `${this.stableResults.length}/${this.options.stabilizationFrames}`\r\n    };\r\n  }\r\n}\r\n\r\n// Helper function to check webcam availability\r\nexport async function checkWebcamAvailability() {\r\n  try {\r\n    const devices = await navigator.mediaDevices.enumerateDevices();\r\n    const videoDevices = devices.filter(device => device.kind === 'videoinput');\r\n    return {\r\n      available: videoDevices.length > 0,\r\n      deviceCount: videoDevices.length,\r\n      devices: videoDevices\r\n    };\r\n  } catch (error) {\r\n    console.error('Error checking webcam availability:', error);\r\n    return { available: false, error: error.message };\r\n  }\r\n}\r\n","/**\r\n * scanic\r\n * JavaScript document scanner without OpenCV dependency\r\n * MIT License\r\n */\r\n\r\n\r\nimport { detectDocumentContour } from './contourDetection.js';\r\nimport { findCornerPoints } from './cornerDetection.js';\r\nimport { cannyEdgeDetector } from './edgeDetection.js';\r\n\r\n// Only import LiveScanner and checkWebcamAvailability for export, do not use them internally here\r\nimport { LiveScanner, checkWebcamAvailability } from './liveScanner.js';\r\n\r\n\r\n// Helper function to calculate smart adaptive downscale factor\r\nfunction calculateAdaptiveDownscale(imageData, maxDimension = 800) {\r\n  const { width, height } = imageData;\r\n  const maxCurrentDimension = Math.max(width, height);\r\n  \r\n  // If image is already smaller than target, no scaling needed\r\n  if (maxCurrentDimension <= maxDimension) {\r\n    return {\r\n      scaledImageData: imageData,\r\n      scaleFactor: 1,\r\n      originalDimensions: { width, height },\r\n      scaledDimensions: { width, height }\r\n    };\r\n  }\r\n  \r\n  // Calculate scale factor to fit within maxDimension\r\n  const scaleFactor = maxDimension / maxCurrentDimension;\r\n  const scaledWidth = Math.round(width * scaleFactor);\r\n  const scaledHeight = Math.round(height * scaleFactor);\r\n  \r\n  // Create scaled image data\r\n  const tempCanvas = document.createElement('canvas');\r\n  tempCanvas.width = width;\r\n  tempCanvas.height = height;\r\n  const tempCtx = tempCanvas.getContext('2d');\r\n  tempCtx.putImageData(imageData, 0, 0);\r\n\r\n  const scaledCanvas = document.createElement('canvas');\r\n  scaledCanvas.width = scaledWidth;\r\n  scaledCanvas.height = scaledHeight;\r\n  const scaledCtx = scaledCanvas.getContext('2d');\r\n  \r\n  // Use high-quality scaling\r\n  scaledCtx.imageSmoothingEnabled = true;\r\n  scaledCtx.imageSmoothingQuality = 'high';\r\n  scaledCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, scaledWidth, scaledHeight);\r\n  \r\n  const scaledImageData = scaledCtx.getImageData(0, 0, scaledWidth, scaledHeight);\r\n  \r\n  return {\r\n    scaledImageData,\r\n    scaleFactor: 1 / scaleFactor, // Return inverse for compatibility with existing code\r\n    originalDimensions: { width, height },\r\n    scaledDimensions: { width: scaledWidth, height: scaledHeight }\r\n  };\r\n}\r\n\r\n// Internal function to detect document in image\r\nasync function detectDocumentInternal(imageData, options = {}) {\r\n  const debugInfo = options.debug ? {} : null;\r\n  \r\n  // Smart adaptive downscaling - ensure largest dimension doesn't exceed maxProcessingDimension\r\n  const maxProcessingDimension = options.maxProcessingDimension || 800;\r\n  const { scaledImageData, scaleFactor, originalDimensions, scaledDimensions } = \r\n    calculateAdaptiveDownscale(imageData, maxProcessingDimension);\r\n  \r\n  if (debugInfo) {\r\n    debugInfo.preprocessing = {\r\n      originalDimensions,\r\n      scaledDimensions,\r\n      scaleFactor,\r\n      maxProcessingDimension\r\n    };\r\n  }\r\n  \r\n  const { width, height } = scaledImageData; // Use scaled dimensions\r\n  \r\n  // Run edge detection on the adaptively scaled image\r\n  const edges = await cannyEdgeDetector(scaledImageData, {\r\n    lowThreshold: options.lowThreshold || 75,   // Match OpenCV values\r\n    highThreshold: options.highThreshold || 200, // Match OpenCV values\r\n    dilationKernelSize: options.dilationKernelSize || 3, // Match OpenCV value \r\n    dilationIterations: options.dilationIterations || 1,\r\n    debug: debugInfo,\r\n    skipNMS: false, // options.skipNMS // Optional flag to skip non-max suppression\r\n    useWasmBlur: true, // option to use wasm blur\r\n  });\r\n  \r\n  // Detect contours from edges\r\n  const contours = detectDocumentContour(edges, {\r\n    minArea: (options.minArea || 1000) / (scaleFactor * scaleFactor), // Adjust minArea for scaled image\r\n    debug: debugInfo,\r\n    width: width,     \r\n    height: height    \r\n  });\r\n\r\n  if (!contours || contours.length === 0) {\r\n    console.log('No document detected');\r\n    return {\r\n      success: false,\r\n      message: 'No document detected',\r\n      debug: debugInfo\r\n    };\r\n  }\r\n  \r\n  // Get the largest contour which is likely the document\r\n  const documentContour = contours[0]; \r\n  \r\n  // Find corner points on the scaled image\r\n  const cornerPoints = findCornerPoints(documentContour, { \r\n      epsilon: options.epsilon // Pass epsilon for approximation\r\n  });\r\n  \r\n  // Scale corner points back to original image size\r\n  let finalCorners = cornerPoints;\r\n  if (scaleFactor !== 1) {\r\n    finalCorners = {\r\n      topLeft: { x: cornerPoints.topLeft.x * scaleFactor, y: cornerPoints.topLeft.y * scaleFactor },\r\n      topRight: { x: cornerPoints.topRight.x * scaleFactor, y: cornerPoints.topRight.y * scaleFactor },\r\n      bottomRight: { x: cornerPoints.bottomRight.x * scaleFactor, y: cornerPoints.bottomRight.y * scaleFactor },\r\n      bottomLeft: { x: cornerPoints.bottomLeft.x * scaleFactor, y: cornerPoints.bottomLeft.y * scaleFactor },\r\n    };\r\n  }\r\n  \r\n  // Return the result, scaling the contour points back up as well\r\n  return {\r\n    success: true,\r\n    contour: documentContour,\r\n    corners: finalCorners,\r\n    debug: debugInfo\r\n  };\r\n}\r\n\r\n// --- Perspective transform helpers (internal use only) ---\r\nfunction getPerspectiveTransform(srcPoints, dstPoints) {\r\n  // Helper to build the system of equations\r\n  function buildMatrix(points) {\r\n    const matrix = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      const [x, y] = points[i];\r\n      matrix.push([x, y, 1, 0, 0, 0, -x * dstPoints[i][0], -y * dstPoints[i][0]]);\r\n      matrix.push([0, 0, 0, x, y, 1, -x * dstPoints[i][1], -y * dstPoints[i][1]]);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  const A = buildMatrix(srcPoints);\r\n  const b = [\r\n    dstPoints[0][0], dstPoints[0][1],\r\n    dstPoints[1][0], dstPoints[1][1],\r\n    dstPoints[2][0], dstPoints[2][1],\r\n    dstPoints[3][0], dstPoints[3][1]\r\n  ];\r\n\r\n  // Solve Ah = b for h (h is 8x1, last element is 1)\r\n  // Use Gaussian elimination or Cramer's rule for 8x8\r\n  // For simplicity, use numeric.js if available, else implement basic solver\r\n  function solve(A, b) {\r\n    // Gaussian elimination for 8x8\r\n    const m = A.length;\r\n    const n = A[0].length;\r\n    const M = A.map(row => row.slice());\r\n    const B = b.slice();\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      // Find max row\r\n      let maxRow = i;\r\n      for (let k = i + 1; k < m; k++) {\r\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\r\n      }\r\n      // Swap rows\r\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\r\n      [B[i], B[maxRow]] = [B[maxRow], B[i]];\r\n\r\n      // Eliminate\r\n      for (let k = i + 1; k < m; k++) {\r\n        const c = M[k][i] / M[i][i];\r\n        for (let j = i; j < n; j++) {\r\n          M[k][j] -= c * M[i][j];\r\n        }\r\n        B[k] -= c * B[i];\r\n      }\r\n    }\r\n\r\n    // Back substitution\r\n    const x = new Array(n);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      let sum = B[i];\r\n      for (let j = i + 1; j < n; j++) {\r\n        sum -= M[i][j] * x[j];\r\n      }\r\n      x[i] = sum / M[i][i];\r\n    }\r\n    return x;\r\n  }\r\n\r\n  const h = solve(A, b);\r\n  // h is [h0,h1,h2,h3,h4,h5,h6,h7], h8 = 1\r\n  const matrix = [\r\n    [h[0], h[1], h[2]],\r\n    [h[3], h[4], h[5]],\r\n    [h[6], h[7], 1]\r\n  ];\r\n  return matrix;\r\n}\r\n\r\n\r\n\r\n\r\nfunction unwarpImage(ctx, image, corners) {\r\n  // Get perspective transform matrix\r\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners;\r\n  // Compute output rectangle size\r\n  const widthA = Math.hypot(bottomRight.x - bottomLeft.x, bottomRight.y - bottomLeft.y);\r\n  const widthB = Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\r\n  const maxWidth = Math.round(Math.max(widthA, widthB));\r\n  const heightA = Math.hypot(topRight.x - bottomRight.x, topRight.y - bottomRight.y);\r\n  const heightB = Math.hypot(topLeft.x - bottomLeft.x, topLeft.y - bottomLeft.y);\r\n  const maxHeight = Math.round(Math.max(heightA, heightB));\r\n\r\n  // Set output canvas size\r\n  ctx.canvas.width = maxWidth;\r\n  ctx.canvas.height = maxHeight;\r\n\r\n  const srcPoints = [\r\n    [topLeft.x, topLeft.y],\r\n    [topRight.x, topRight.y],\r\n    [bottomRight.x, bottomRight.y],\r\n    [bottomLeft.x, bottomLeft.y]\r\n  ];\r\n  const dstPoints = [\r\n    [0, 0],\r\n    [maxWidth - 1, 0],\r\n    [maxWidth - 1, maxHeight - 1],\r\n    [0, maxHeight - 1]\r\n  ];\r\n  const perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);\r\n  warpTransform(ctx, image, perspectiveMatrix, maxWidth, maxHeight);\r\n}\r\n\r\nfunction invert3x3(m) {\r\n  // Invert a 3x3 matrix\r\n  const a = m[0][0], b = m[0][1], c = m[0][2];\r\n  const d = m[1][0], e = m[1][1], f = m[1][2];\r\n  const g = m[2][0], h = m[2][1], i = m[2][2];\r\n  const A = e * i - f * h;\r\n  const B = -(d * i - f * g);\r\n  const C = d * h - e * g;\r\n  const D = -(b * i - c * h);\r\n  const E = a * i - c * g;\r\n  const F = -(a * h - b * g);\r\n  const G = b * f - c * e;\r\n  const H = -(a * f - c * d);\r\n  const I = a * e - b * d;\r\n  const det = a * A + b * B + c * C;\r\n  if (det === 0) throw new Error('Singular matrix');\r\n  return [\r\n    [A / det, D / det, G / det],\r\n    [B / det, E / det, H / det],\r\n    [C / det, F / det, I / det]\r\n  ];\r\n}\r\n\r\nfunction warpTransform(ctx, image, matrix, outWidth, outHeight) {\r\n  // Inverse matrix for mapping output to input\r\n  const inv = invert3x3(matrix);\r\n  // Get source image data\r\n  const srcCanvas = document.createElement('canvas');\r\n  srcCanvas.width = image.width || image.naturalWidth;\r\n  srcCanvas.height = image.height || image.naturalHeight;\r\n  const srcCtx = srcCanvas.getContext('2d');\r\n  srcCtx.drawImage(image, 0, 0, srcCanvas.width, srcCanvas.height);\r\n  const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);\r\n  const out = ctx.createImageData(outWidth, outHeight);\r\n  for (let y = 0; y < outHeight; y++) {\r\n    for (let x = 0; x < outWidth; x++) {\r\n      // Map (x, y) in output to (srcX, srcY) in input\r\n      const denom = inv[2][0] * x + inv[2][1] * y + inv[2][2];\r\n      const srcX = (inv[0][0] * x + inv[0][1] * y + inv[0][2]) / denom;\r\n      const srcY = (inv[1][0] * x + inv[1][1] * y + inv[1][2]) / denom;\r\n      // Bilinear sample\r\n      const sx = Math.max(0, Math.min(srcCanvas.width - 2, srcX));\r\n      const sy = Math.max(0, Math.min(srcCanvas.height - 2, srcY));\r\n      const ix = Math.floor(sx), iy = Math.floor(sy);\r\n      const dx = sx - ix, dy = sy - iy;\r\n      for (let c = 0; c < 4; c++) {\r\n        // Bilinear interpolation\r\n        const i00 = srcData.data[(iy * srcCanvas.width + ix) * 4 + c];\r\n        const i10 = srcData.data[(iy * srcCanvas.width + (ix + 1)) * 4 + c];\r\n        const i01 = srcData.data[((iy + 1) * srcCanvas.width + ix) * 4 + c];\r\n        const i11 = srcData.data[((iy + 1) * srcCanvas.width + (ix + 1)) * 4 + c];\r\n        out.data[(y * outWidth + x) * 4 + c] =\r\n          (1 - dx) * (1 - dy) * i00 +\r\n          dx * (1 - dy) * i10 +\r\n          (1 - dx) * dy * i01 +\r\n          dx * dy * i11;\r\n      }\r\n    }\r\n  }\r\n  ctx.putImageData(out, 0, 0);\r\n}\r\n\r\n\r\n/**\r\n * Main entry point for document scanning.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} options\r\n *   - mode: 'detect' | 'highlight' | 'extract' (default: 'detect')\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n *   - debug: boolean\r\n *   - ...other detection options\r\n * @returns {Promise<{output, corners, contour, debug, success, message}>}\r\n */\r\nexport async function scanDocument(image, options = {}) {\r\n  const mode = options.mode || 'detect';\r\n  const outputType = options.output || 'canvas';\r\n  const debug = !!options.debug;\r\n\r\n  // Prepare input image data\r\n  let imageData, width, height;\r\n  if (image instanceof ImageData) {\r\n    imageData = image;\r\n    width = image.width;\r\n    height = image.height;\r\n  } else {\r\n    // HTMLImageElement or HTMLCanvasElement\r\n    const tempCanvas = document.createElement('canvas');\r\n    tempCanvas.width = image.width || image.naturalWidth;\r\n    tempCanvas.height = image.height || image.naturalHeight;\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);\r\n    imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\r\n    width = tempCanvas.width;\r\n    height = tempCanvas.height;\r\n  }\r\n\r\n  // Detect document\r\n  const detection = await detectDocumentInternal(imageData, options);\r\n  if (!detection.success) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      contour: null,\r\n      debug: detection.debug,\r\n      success: false,\r\n      message: detection.message || 'No document detected'\r\n    };\r\n  }\r\n\r\n  let resultCanvas;\r\n  let output;\r\n\r\n  if (mode === 'detect') {\r\n    // Just return detection info, no image processing\r\n    output = null;\r\n  } else if (mode === 'extract') {\r\n    // Return only the cropped/warped document\r\n    resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, detection.corners);\r\n  } else {\r\n    // Default: highlight mode (draw outline on original image)\r\n    resultCanvas = document.createElement('canvas');\r\n    resultCanvas.width = width;\r\n    resultCanvas.height = height;\r\n    const ctx = resultCanvas.getContext('2d');\r\n    ctx.drawImage(image, 0, 0, width, height);\r\n    // Optionally, draw outline here if you want\r\n    // drawSleekDocumentOutline(ctx, detection.corners, width, height, ...);\r\n  }\r\n\r\n  // Prepare output in requested format (only if not detect mode)\r\n  if (mode !== 'detect' && resultCanvas) {\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n  }\r\n\r\n  return {\r\n    output,\r\n    corners: detection.corners,\r\n    contour: detection.contour,\r\n    debug: detection.debug,\r\n    success: true,\r\n    message: 'Document detected'\r\n  };\r\n}\r\n\r\n// Export only the main API and live scanner utilities\r\nexport { LiveScanner, checkWebcamAvailability };"],"names":["DEFAULTS","RETR_EXTERNAL","RETR_LIST","CHAIN_APPROX_SIMPLE","deltas","detectDocumentContour","edges","options","width","height","mode","method","minArea","paddedWidth","paddedHeight","labels","y","x","contours","nextContourId","currentPixelLabel","leftPixelLabel","startPoint","isOuter","initialDirection","contourId","points","traceContour","finalPoints","simplifyChainApproxSimple","adjustedPoints","p","contour","calculateContourArea","calculateBoundingBox","filteredContours","a","b","visitedPoints","currentPoint","prevDirection","count","maxSteps","searchDirection","found","i","nextX","nextY","nextPoint","checkDirection","checkX","checkY","pointKey","simplifiedPoints","n","prevPoint","dx1","dy1","dx2","dy2","maxDistSq","farthestIdx","p0","pi","distSq","area","j","minX","minY","maxX","maxY","point","simplifyContour","epsilon","maxDistance","index","firstPoint","lastPoint","distance","perpendicularDistance","firstSegment","secondSegment","lineStart","lineEnd","dx","dy","lineLengthSq","t","closestPointX","closestPointY","distDx","distDy","approximatePolygon","contourPoints","perimeter","calculateContourPerimeter","actualEpsilon","findCenter","sumX","sumY","findCornerPoints","approximation","corners","orderCornerPoints","findCornersByCoordinateExtremes","topLeft","topRight","bottomRight","bottomLeft","minSum","maxDiff","maxSum","minDiff","sum","diff","center","sortedPoints","angleA","angleB","minIndex","orderedPoints","wasm","cachedUint8ArrayMemory0","getUint8ArrayMemory0","WASM_VECTOR_LEN","passArray8ToWasm0","arg","malloc","ptr","getArrayU8FromWasm0","len","dilate","kernel_size","ptr0","len0","ret","v2","cachedFloat32ArrayMemory0","getFloat32ArrayMemory0","passArrayF32ToWasm0","hysteresis_thresholding","suppressed","low_threshold","high_threshold","blur","grayscale","sigma","cachedUint16ArrayMemory0","getUint16ArrayMemory0","passArray16ToWasm0","getArrayF32FromWasm0","non_maximum_suppression","l2_gradient","ptr1","len1","v3","__wbg_load","module","imports","e","bytes","instance","__wbg_get_imports","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","wasmReady","init","convertToGrayscale","imageData","data","gaussianBlurGrayscale","kernelSize","halfKernel","kernel","createGaussianKernel","tempArray","blurred","rowOffset","k","xOffset","yOffset","size","halfSize","calculateGradients","prevRowOffset","nextRowOffset","currentIdx","p1","p2","p3","p5","p6","p7","p8","gx","gy","nonMaximumSuppression","L2gradient","magnitude","idx","mag","neighbor1","neighbor2","absGx","absGy","s","hysteresisThresholding","lowThreshold","highThreshold","edgeMap","stack","dxNeighbors","dyNeighbors","nx","ny","nidx","dilateEdges","temp","dilated","maxVal","val","cannyEdgeDetector","timings","tStart","applyDilation","dilationKernelSize","useWasmHysteresis","t0","t1","wasmBlur","gradients","wasmMaximumSuppression","finalLowThreshold","finalHighThreshold","wasmHysteresis","cannyEdges","finalEdges","wasmDilate","tEnd","LiveScanner","outputElement","constraints","finalConstraints","resolve","error","track","now","timeSinceLastDetection","result","scanDocument","newCorners","cornersList","avg","key","ctx","scaleX","scaleY","targetCtx","scaledCorners","cornerSize","corner","extractDocument","captureCanvas","checkWebcamAvailability","videoDevices","device","calculateAdaptiveDownscale","maxDimension","maxCurrentDimension","scaleFactor","scaledWidth","scaledHeight","tempCanvas","scaledCanvas","scaledCtx","detectDocumentInternal","debugInfo","maxProcessingDimension","scaledImageData","originalDimensions","scaledDimensions","documentContour","cornerPoints","finalCorners","getPerspectiveTransform","srcPoints","dstPoints","buildMatrix","matrix","A","solve","m","M","row","B","maxRow","c","h","unwarpImage","image","widthA","widthB","maxWidth","heightA","heightB","maxHeight","perspectiveMatrix","warpTransform","invert3x3","d","f","g","C","D","E","F","G","H","I","det","outWidth","outHeight","inv","srcCanvas","srcCtx","srcData","out","denom","srcX","srcY","sx","sy","ix","iy","i00","i10","i01","i11","outputType","tempCtx","detection","resultCanvas","output"],"mappings":"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"}