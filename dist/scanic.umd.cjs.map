{"version":3,"file":"scanic.umd.cjs","sources":["../src/constants.js","../src/contourDetection.js","../src/cornerDetection.js","../wasm_blur/pkg/wasm_blur.js","../src/edgeDetection.js","../src/index.js"],"sourcesContent":["/**\r\n * Constants used throughout the library\r\n */\r\n\r\nexport const VERSION = '1.0.0';\r\n\r\nexport const DEFAULTS = {\r\n  // Edge detection params\r\n  GAUSSIAN_SIGMA: 1.1,\r\n  LOW_THRESHOLD: 50,\r\n  HIGH_THRESHOLD: 150,\r\n  \r\n  // Contour detection params\r\n  MIN_CONTOUR_AREA: 1000,\r\n  MIN_CONTOUR_POINTS: 10,\r\n  \r\n  // Debug options\r\n  DEBUG_OVERLAY_OPACITY: 0.7\r\n};","/**\r\n * Pure JavaScript implementation of contour detection algorithms\r\n * Based on Suzuki, S. and Abe, K. (1985). Topological structural analysis of digitized binary images by border following.\r\n * Replaces the previous flood-fill based connected components analysis.\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\n\r\n// Constants for different retrieval modes (subset of OpenCV)\r\nconst RETR_EXTERNAL = 0;\r\nconst RETR_LIST = 1;\r\n// Constants for different approximation methods (subset of OpenCV)\r\nconst CHAIN_APPROX_NONE = 1;\r\nconst CHAIN_APPROX_SIMPLE = 2;\r\n\r\n// Deltas for 8-connectivity neighborhood checks (0-7 clockwise from top)\r\n// Corresponds to OpenCV's chain code directions\r\nconst deltas = [\r\n  { dx:  0, dy: -1 }, // 0: Top\r\n  { dx:  1, dy: -1 }, // 1: Top-right\r\n  { dx:  1, dy:  0 }, // 2: Right\r\n  { dx:  1, dy:  1 }, // 3: Bottom-right\r\n  { dx:  0, dy:  1 }, // 4: Bottom\r\n  { dx: -1, dy:  1 }, // 5: Bottom-left\r\n  { dx: -1, dy:  0 }, // 6: Left\r\n  { dx: -1, dy: -1 }  // 7: Top-left\r\n];\r\n\r\n/**\r\n * Detects contours in a binary edge image using Suzuki's border following algorithm.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (pixels > 0 are foreground)\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.width] - Image width (required if not square)\r\n * @param {number} [options.height] - Image height (required if not square)\r\n * @param {number} [options.mode=RETR_LIST] - Contour retrieval mode (RETR_EXTERNAL or RETR_LIST)\r\n * @param {number} [options.method=CHAIN_APPROX_SIMPLE] - Contour approximation method (CHAIN_APPROX_NONE or CHAIN_APPROX_SIMPLE)\r\n * @param {number} [options.minArea=DEFAULTS.MIN_CONTOUR_AREA] - Minimum contour area filter (applied after detection)\r\n * @param {Object} [options.debug] - Optional debug object to store intermediate results\r\n * @returns {Array} Array of contours, each contour is an array of points {x, y}. Sorted by area (largest first).\r\n */\r\nexport function detectDocumentContour(edges, options = {}) {\r\n  const width = options.width || Math.sqrt(edges.length);\r\n  const height = options.height || edges.length / width;\r\n  const mode = options.mode !== undefined ? options.mode : RETR_LIST;\r\n  const method = options.method !== undefined ? options.method : CHAIN_APPROX_SIMPLE;\r\n  const minArea = options.minArea || DEFAULTS.MIN_CONTOUR_AREA;\r\n\r\n  // Create a padded label map to simplify boundary checks.\r\n  // 0: background\r\n  // 1: foreground (unlabeled)\r\n  // >= 2: contour ID (2, 3, ...)\r\n  const paddedWidth = width + 2;\r\n  const paddedHeight = height + 2;\r\n  const labels = new Int32Array(paddedWidth * paddedHeight); // Initialized to 0\r\n\r\n  // Copy edges data to the label map, mapping foreground pixels to 1\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (edges[y * width + x] > 0) {\r\n        labels[(y + 1) * paddedWidth + (x + 1)] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  const contours = [];\r\n  let nextContourId = 2; // Start labeling contours from 2\r\n\r\n  // Raster scan\r\n  for (let y = 1; y <= height; y++) {\r\n    for (let x = 1; x <= width; x++) {\r\n      const currentPixelLabel = labels[y * paddedWidth + x];\r\n      const leftPixelLabel = labels[y * paddedWidth + (x - 1)];\r\n\r\n      let startPoint = null;\r\n      let isOuter = false;\r\n      let initialDirection = -1;\r\n\r\n      if (currentPixelLabel === 1 && leftPixelLabel === 0) {\r\n        // Found the start of an outer contour boundary (NBD = 1 in Suzuki's terms)\r\n        isOuter = true;\r\n        startPoint = { x: x, y: y };\r\n        initialDirection = 2; // Start searching right\r\n        // if (options.debug) console.log(`Outer contour start at (${x-1}, ${y-1})`);\r\n      } else if (currentPixelLabel === 0 && leftPixelLabel >= 1 && leftPixelLabel !== -1) {\r\n         // Found the start of a hole contour boundary (NBD >= 2 in Suzuki's terms)\r\n         // Check if the left pixel is already part of a traced contour border\r\n         // If leftPixelLabel is > 1, it might be already traced. If it's 1, it's an unlabeled foreground pixel.\r\n         // We only start tracing if the left pixel is unlabeled foreground (1).\r\n         if (leftPixelLabel === 1) {\r\n             isOuter = false;\r\n             startPoint = { x: x - 1, y: y };\r\n             initialDirection = 6; // Start searching left\r\n            //  if (options.debug) console.log(`Hole contour start at (${x-1-1}, ${y-1})`);\r\n         }\r\n      }\r\n\r\n\r\n      if (startPoint) {\r\n        // If mode is RETR_EXTERNAL, only process outer contours\r\n        if (mode === RETR_EXTERNAL && !isOuter) {\r\n          // Mark the starting pixel of the hole so we don't process it again\r\n          // Use a special marker (-1) to distinguish from contour IDs\r\n           labels[startPoint.y * paddedWidth + startPoint.x] = -1;\r\n           continue;\r\n        }\r\n\r\n        const contourId = nextContourId++;\r\n        const points = traceContour(labels, paddedWidth, paddedHeight, startPoint, initialDirection, contourId);\r\n\r\n        if (points && points.length > 0) {\r\n            let finalPoints = points;\r\n            if (method === CHAIN_APPROX_SIMPLE) {\r\n                finalPoints = simplifyChainApproxSimple(points);\r\n            }\r\n\r\n            // Adjust points to original image coordinates (remove padding offset)\r\n            const adjustedPoints = finalPoints.map(p => ({ x: p.x - 1, y: p.y - 1 }));\r\n\r\n            if (adjustedPoints.length >= (method === CHAIN_APPROX_SIMPLE ? 4 : DEFAULTS.MIN_CONTOUR_POINTS)) { // Need at least 4 points for a simple polygon approx\r\n                const contour = {\r\n                    id: contourId,\r\n                    points: adjustedPoints,\r\n                    isOuter: isOuter,\r\n                    // Calculate area and bounding box later if needed for filtering/sorting\r\n                };\r\n                contours.push(contour);\r\n            }\r\n        } else {\r\n             // Handle single point contours or errors if necessary\r\n             // Mark the start point if trace failed or resulted in no points\r\n             if (labels[startPoint.y * paddedWidth + startPoint.x] === 1) {\r\n                 labels[startPoint.y * paddedWidth + startPoint.x] = contourId; // Mark as visited\r\n             }\r\n        }\r\n      } else if (currentPixelLabel >= 1 && leftPixelLabel >= 1 && currentPixelLabel !== leftPixelLabel) {\r\n          // Handle merging contours or complex topology if needed (not implemented for RETR_LIST/EXTERNAL)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Calculate area and bounding box for filtering and sorting\r\n  contours.forEach(contour => {\r\n    contour.area = calculateContourArea(contour.points);\r\n    contour.boundingBox = calculateBoundingBox(contour.points);\r\n  });\r\n\r\n  // Filter by minimum area\r\n  const filteredContours = contours.filter(contour => contour.area >= minArea);\r\n\r\n  // Sort contours by area (largest first)\r\n  filteredContours.sort((a, b) => b.area - a.area);\r\n\r\n  // console.log(`Found ${contours.length} contours before filtering, ${filteredContours.length} after filtering.`);\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.labels = labels; // Store the final label map\r\n    options.debug.rawContours = contours; // Store contours before filtering/sorting\r\n    options.debug.finalContours = filteredContours;\r\n    // console.log('Contour detection debug info stored');\r\n  }\r\n  return filteredContours // Return only the points array per contour\r\n}\r\n\r\n/**\r\n * Traces a contour boundary using border following.\r\n * Optimized to minimize object allocations.\r\n * @param {Int32Array} labels - The label map (modified during tracing)\r\n * @param {number} width - Padded width of the label map\r\n * @param {number} height - Padded height of the label map\r\n * @param {Object} startPoint - Starting point {x, y} in padded coordinates\r\n * @param {number} initialDirection - Initial search direction (0-7)\r\n * @param {number} contourId - The ID to label this contour with\r\n * @returns {Array} Array of points {x, y} in padded coordinates, or null if error\r\n */\r\nfunction traceContour(labels, width, height, startPoint, initialDirection, contourId) {\r\n    const points = [];\r\n    // Use Set with numeric keys (y * width + x) - much faster than string keys\r\n    const visited = new Set();\r\n    \r\n    // Avoid object creation in hot loop - use primitive coordinates\r\n    let currentX = startPoint.x;\r\n    let currentY = startPoint.y;\r\n    const startX = currentX;\r\n    const startY = currentY;\r\n    \r\n    let prevDirection = -1; // Store the direction from which we arrived at currentPoint\r\n\r\n    // Mark the starting pixel with the contour ID\r\n    labels[startY * width + startX] = contourId;\r\n\r\n    let count = 0; // Safety break\r\n    const maxSteps = width * height; // Max possible steps\r\n    \r\n    // Pre-extract delta values for faster access in hot loop\r\n    const dx = [0, 1, 1, 1, 0, -1, -1, -1];\r\n    const dy = [-1, -1, 0, 1, 1, 1, 0, -1];\r\n\r\n    while (count++ < maxSteps) {\r\n        // Determine the direction to start searching from (relative to the direction we came from)\r\n        // In Suzuki's paper, this is based on the chain code of the previous step.\r\n        // Simplified: Start searching from the direction after the one that led us here.\r\n        // If we arrived from direction `d`, the next pixel must be in `(d+1)%8` to `(d+7)%8`.\r\n        // Let's adapt OpenCV's logic: search starts from (prevDirection + 2) % 8 clockwise.\r\n        // If it's the first step, prevDirection is unknown, use initialDirection logic.\r\n\r\n        let searchDirection;\r\n        if (prevDirection === -1) {\r\n            // First step: Use initialDirection logic (e.g., start right for outer, left for inner)\r\n            // The initial search should find the *first* pixel of the contour boundary clockwise.\r\n            // Let's refine the initial search based on OpenCV's approach:\r\n            // Find the first non-zero pixel starting from `initialDirection` clockwise.\r\n            let found = false;\r\n            for (let i = 0; i < 8; i++) {\r\n                searchDirection = (initialDirection + i) & 7; // Faster than % 8\r\n                const nextX = currentX + dx[searchDirection];\r\n                const nextY = currentY + dy[searchDirection];\r\n                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && labels[nextY * width + nextX] > 0) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) return null; // Should not happen if startPoint is valid\r\n\r\n        } else {\r\n            // Subsequent steps: Start search from (prevDirection + 2) % 8 clockwise\r\n             searchDirection = (prevDirection + 2) & 7;\r\n        }\r\n\r\n\r\n        let nextX = -1;\r\n        let nextY = -1;\r\n        let nextDirection = -1;\r\n\r\n        // Search clockwise for the next boundary pixel\r\n        for (let i = 0; i < 8; i++) {\r\n            const checkDirection = (searchDirection + i) & 7;\r\n            const checkX = currentX + dx[checkDirection];\r\n            const checkY = currentY + dy[checkDirection];\r\n\r\n            // Check bounds (should be within padded area)\r\n            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {\r\n                if (labels[checkY * width + checkX] > 0) { // Found a foreground pixel (labeled or unlabeled)\r\n                    nextX = checkX;\r\n                    nextY = checkY;\r\n                    // The direction *from* currentPoint *to* nextPoint is checkDirection\r\n                    nextDirection = checkDirection;\r\n                    // The direction *from* which we will arrive *at* nextPoint is (checkDirection + 4) % 8\r\n                    prevDirection = (checkDirection + 4) & 7;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextX === -1) {\r\n            // Should not happen in a well-formed contour, maybe isolated pixel?\r\n             if (points.length === 0) { // If it's just the start point\r\n                 points.push({ x: currentX, y: currentY }); // Add the single point\r\n             }\r\n            console.warn(`Contour tracing stopped unexpectedly at (${currentX-1}, ${currentY-1}) for contour ${contourId}`);\r\n            break;\r\n        }\r\n\r\n        // Add the *current* point to the list before moving\r\n        // Use numeric key for Set (much faster than string concatenation)\r\n        const visitedKey = currentY * width + currentX;\r\n        if (visited.has(visitedKey)) {\r\n            // Duplicate point detected - return to avoid infinite loops\r\n            return points;\r\n        }\r\n        points.push({ x: currentX, y: currentY });\r\n        visited.add(visitedKey);\r\n\r\n        // Mark the next pixel if it's unlabeled\r\n        const nextIdx = nextY * width + nextX;\r\n        if (labels[nextIdx] === 1) {\r\n            labels[nextIdx] = contourId;\r\n        }\r\n\r\n        // Move to the next point\r\n        currentX = nextX;\r\n        currentY = nextY;\r\n\r\n        // Check if we returned to the start point\r\n        if (currentX === startX && currentY === startY) {\r\n            // Check if we came from the same direction as the initial step search ended.\r\n            // This is complex, let's use a simpler check: if we are back at start, we are done.\r\n            // OpenCV has more sophisticated checks involving i4 == i0 && i3 == i1.\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (count >= maxSteps) {\r\n        console.warn(`Contour tracing exceeded max steps for contour ${contourId}`);\r\n        return null; // Indicate potential error\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\n/**\r\n * Simplifies a contour polygon using CHAIN_APPROX_SIMPLE.\r\n * Removes intermediate points that lie on the straight line segment between their neighbors.\r\n * Optimized to avoid modulo operations in hot loop.\r\n * @param {Array} points - Array of contour points {x, y}\r\n * @returns {Array} Simplified array of points\r\n */\r\nfunction simplifyChainApproxSimple(points) {\r\n    const n = points.length;\r\n    if (n <= 2) {\r\n        return points;\r\n    }\r\n\r\n    const simplifiedPoints = [];\r\n    \r\n    // Cache first and last points for wrap-around\r\n    const lastPoint = points[n - 1];\r\n    const firstPoint = points[0];\r\n    \r\n    // Check first point (prev = last, next = second)\r\n    let prevPoint = lastPoint;\r\n    let currentPoint = firstPoint;\r\n    let nextPoint = points[1];\r\n    \r\n    let dx1 = currentPoint.x - prevPoint.x;\r\n    let dy1 = currentPoint.y - prevPoint.y;\r\n    let dx2 = nextPoint.x - currentPoint.x;\r\n    let dy2 = nextPoint.y - currentPoint.y;\r\n    \r\n    if (dx1 * dy2 !== dy1 * dx2) {\r\n        simplifiedPoints.push(currentPoint);\r\n    }\r\n    \r\n    // Middle points (no wrap-around needed)\r\n    for (let i = 1; i < n - 1; i++) {\r\n        prevPoint = points[i - 1];\r\n        currentPoint = points[i];\r\n        nextPoint = points[i + 1];\r\n\r\n        dx1 = currentPoint.x - prevPoint.x;\r\n        dy1 = currentPoint.y - prevPoint.y;\r\n        dx2 = nextPoint.x - currentPoint.x;\r\n        dy2 = nextPoint.y - currentPoint.y;\r\n\r\n        if (dx1 * dy2 !== dy1 * dx2) {\r\n            simplifiedPoints.push(currentPoint);\r\n        }\r\n    }\r\n    \r\n    // Check last point (prev = second-to-last, next = first)\r\n    prevPoint = points[n - 2];\r\n    currentPoint = lastPoint;\r\n    nextPoint = firstPoint;\r\n    \r\n    dx1 = currentPoint.x - prevPoint.x;\r\n    dy1 = currentPoint.y - prevPoint.y;\r\n    dx2 = nextPoint.x - currentPoint.x;\r\n    dy2 = nextPoint.y - currentPoint.y;\r\n    \r\n    if (dx1 * dy2 !== dy1 * dx2) {\r\n        simplifiedPoints.push(currentPoint);\r\n    }\r\n\r\n    // Handle cases where all points are collinear (e.g., straight line)\r\n    if (simplifiedPoints.length === 0) {\r\n         if (n === 1) return [points[0]];\r\n         if (n === 2) return points;\r\n\r\n         // Find the point most distant from the first point\r\n         let maxDistSq = 0;\r\n         let farthestIdx = 1;\r\n         const p0x = firstPoint.x;\r\n         const p0y = firstPoint.y;\r\n         for (let i = 1; i < n; i++) {\r\n             const pi = points[i];\r\n             const dx = pi.x - p0x;\r\n             const dy = pi.y - p0y;\r\n             const distSq = dx * dx + dy * dy;\r\n             if (distSq > maxDistSq) {\r\n                 maxDistSq = distSq;\r\n                 farthestIdx = i;\r\n             }\r\n         }\r\n         return [firstPoint, points[farthestIdx]];\r\n    }\r\n\r\n    return simplifiedPoints;\r\n}\r\n\r\n\r\n// --- Helper functions (keep or adapt from original) ---\r\n\r\n/**\r\n * Calculates the area of a contour using the shoelace formula\r\n * @param {Array} points - Array of point coordinates {x, y}\r\n * @returns {number} Contour area\r\n */\r\nfunction calculateContourArea(points) {\r\n  let area = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 3) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n;\r\n    area += points[i].x * points[j].y;\r\n    area -= points[j].x * points[i].y;\r\n  }\r\n\r\n  return Math.abs(area) / 2;\r\n}\r\n\r\n/**\r\n * Calculates the bounding box of a contour\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {Object} Bounding box with minX, minY, maxX, maxY properties\r\n */\r\nfunction calculateBoundingBox(points) {\r\n  if (points.length === 0) {\r\n      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n  }\r\n  let minX = points[0].x;\r\n  let minY = points[0].y;\r\n  let maxX = points[0].x;\r\n  let maxY = points[0].y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      minX = Math.min(minX, point.x);\r\n      minY = Math.min(minY, point.y);\r\n      maxX = Math.max(maxX, point.x);\r\n      maxY = Math.max(maxY, point.y);\r\n  }\r\n\r\n  return { minX, minY, maxX, maxY };\r\n}\r\n\r\n\r\n// --- Functions below are no longer directly used by detectDocumentContour ---\r\n// --- but might be useful elsewhere or can be removed ---\r\n\r\n/**\r\n * Simplifies a contour using the Ramer-Douglas-Peucker algorithm\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} points - Array of point coordinates\r\n * @param {number} epsilon - Epsilon value for simplification\r\n * @returns {Array} Simplified contour points\r\n */\r\nexport function simplifyContour(points, epsilon = 1.0) {\r\n  // ... (keep existing implementation if needed elsewhere) ...\r\n   if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Find point with the maximum distance\r\n  let maxDistance = 0;\r\n  let index = 0;\r\n\r\n  const firstPoint = points[0];\r\n  const lastPoint = points[points.length - 1];\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\r\n\r\n    if (distance > maxDistance) {\r\n      maxDistance = distance;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  // If max distance is greater than epsilon, recursively simplify\r\n  if (maxDistance > epsilon) {\r\n    // Recursive simplification\r\n    const firstSegment = simplifyContour(points.slice(0, index + 1), epsilon);\r\n    const secondSegment = simplifyContour(points.slice(index), epsilon);\r\n\r\n    // Concatenate the two segments\r\n    return firstSegment.slice(0, -1).concat(secondSegment);\r\n  } else {\r\n    // Return just the endpoints\r\n    return [firstPoint, lastPoint];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the perpendicular distance from a point to a line\r\n * (Helper for RDP simplifyContour, keep if that function is kept)\r\n * @param {Object} point - Point to measure from\r\n * @param {Object} lineStart - Start point of the line\r\n * @param {Object} lineEnd - End point of the line\r\n * @returns {number} Perpendicular distance\r\n */\r\nfunction perpendicularDistance(point, lineStart, lineEnd) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   const dx = lineEnd.x - lineStart.x;\r\n  const dy = lineEnd.y - lineStart.y;\r\n\r\n  // Line length squared\r\n  const lineLengthSq = dx * dx + dy * dy;\r\n\r\n  if (lineLengthSq === 0) {\r\n    // Point to point distance if the line has zero length\r\n    return Math.sqrt(\r\n      Math.pow(point.x - lineStart.x, 2) +\r\n      Math.pow(point.y - lineStart.y, 2)\r\n    );\r\n  }\r\n\r\n   // Calculate the projection parameter t\r\n  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq;\r\n\r\n  let closestPointX, closestPointY;\r\n\r\n  if (t < 0) {\r\n    closestPointX = lineStart.x;\r\n    closestPointY = lineStart.y;\r\n  } else if (t > 1) {\r\n    closestPointX = lineEnd.x;\r\n    closestPointY = lineEnd.y;\r\n  } else {\r\n    closestPointX = lineStart.x + t * dx;\r\n    closestPointY = lineStart.y + t * dy;\r\n  }\r\n\r\n  // Calculate the distance from the point to the closest point on the line segment\r\n  const distDx = point.x - closestPointX;\r\n  const distDy = point.y - closestPointY;\r\n  return Math.sqrt(distDx * distDx + distDy * distDy);\r\n\r\n  /* // Original implementation using area formula (distance to infinite line)\r\n  const lineLength = Math.sqrt(lineLengthSq);\r\n  const area = Math.abs(dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);\r\n  return area / lineLength;\r\n  */\r\n}\r\n\r\n/**\r\n * Creates a polygon approximation of a contour using RDP.\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} contourPoints - Array of points {x, y}\r\n * @param {number} epsilon - Epsilon for polygon approximation (relative to perimeter)\r\n * @returns {Array} Array of polygon points\r\n */\r\nexport function approximatePolygon(contourPoints, epsilon = 0.02) {\r\n  // Calculate contour perimeter\r\n  const perimeter = calculateContourPerimeter(contourPoints);\r\n\r\n  // Calculate epsilon based on perimeter\r\n  const actualEpsilon = epsilon * perimeter;\r\n\r\n  // Simplify the contour using RDP\r\n  const simplifiedPoints = simplifyContour(contourPoints, actualEpsilon);\r\n\r\n  return simplifiedPoints;\r\n}\r\n\r\n/**\r\n * Calculates the perimeter of a contour\r\n * (Helper for RDP approximatePolygon, keep if that function is kept)\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {number} Contour perimeter\r\n */\r\nfunction calculateContourPerimeter(points) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   let perimeter = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 2) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n; // Wrap around for the last segment\r\n    const dx = points[i].x - points[j].x;\r\n    const dy = points[i].y - points[j].y;\r\n    perimeter += Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\n// Flood fill is no longer used for contour detection\r\n/*\r\nfunction floodFill(edges, labels, width, height, startX, startY, label) {\r\n  // ... (original floodFill implementation removed) ...\r\n}\r\n*/","/**\r\n * Pure JavaScript implementation for detecting corners of a document\r\n * Replaces OpenCV's corner detection and point finding logic\r\n */\r\n\r\nimport { approximatePolygon } from './contourDetection.js';\r\n\r\n/**\r\n * Calculate distance between two points\r\n * @param {Object} p1 - First point {x, y}\r\n * @param {Object} p2 - Second point {x, y}\r\n * @returns {number} Distance between points\r\n */\r\nexport function distance(p1, p2) {\r\n  return Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n}\r\n\r\n/**\r\n * Find the center point of a contour\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Center point {x, y}\r\n */\r\nfunction findCenter(points) {\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  \r\n  for (const point of points) {\r\n    sumX += point.x;\r\n    sumY += point.y;\r\n  }\r\n  \r\n  return {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length\r\n  };\r\n}\r\n\r\n/**\r\n * Find the four corners of a document contour\r\n * @param {Object} contour - Contour object with points property\r\n * @param {Object} options - Configuration options\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nexport function findCornerPoints(contour, options = {}) {\r\n  if (!contour || !contour.points || contour.points.length < 4) {\r\n    console.warn('Contour does not have enough points for corner detection');\r\n    return null;\r\n  }\r\n  \r\n  // Try to find a quadrilateral approximation of the contour\r\n  const epsilon = options.epsilon || 0.02;\r\n  const approximation = approximatePolygon(contour, epsilon);\r\n  \r\n  let corners;\r\n  \r\n  // If we get exactly 4 points, we can use them as corners\r\n  if (approximation && approximation.length === 4) {\r\n    // console.log('Found 4-point approximation, using as corners');\r\n    corners = orderCornerPoints(approximation);\r\n  } else {\r\n    // console.log(`Polygon approximation gave ${approximation ? approximation.length : 'null'} points, using coordinate extremes method`);\r\n    // Fallback: Use the coordinate extremes method on the original contour points\r\n    corners = findCornersByCoordinateExtremes(contour.points); \r\n  }\r\n  \r\n  // Ensure all corners were found\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n      console.warn('Failed to find all four corners.', corners);\r\n      // Return null or partial corners? Returning null might be safer downstream.\r\n      return null; \r\n  }\r\n\r\n  return corners;\r\n}\r\n\r\n/**\r\n * Find corners by finding points with min/max coordinate sums/differences.\r\n * This is an alternative heuristic for finding corners.\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nfunction findCornersByCoordinateExtremes(points) {\r\n  if (!points || points.length === 0) return null;\r\n\r\n  let topLeft = points[0];      // Min sum x + y\r\n  let topRight = points[0];     // Max diff x - y\r\n  let bottomRight = points[0];  // Max sum x + y\r\n  let bottomLeft = points[0];   // Min diff x - y\r\n\r\n  let minSum = topLeft.x + topLeft.y;\r\n  let maxDiff = topRight.x - topRight.y;\r\n  let maxSum = bottomRight.x + bottomRight.y;\r\n  let minDiff = bottomLeft.x - bottomLeft.y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    const point = points[i];\r\n    const sum = point.x + point.y;\r\n    const diff = point.x - point.y;\r\n\r\n    // Top-Left (min sum)\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      topLeft = point;\r\n    }\r\n    // Bottom-Right (max sum)\r\n    if (sum > maxSum) {\r\n      maxSum = sum;\r\n      bottomRight = point;\r\n    }\r\n    // Top-Right (max diff)\r\n    if (diff > maxDiff) {\r\n      maxDiff = diff;\r\n      topRight = point;\r\n    }\r\n    // Bottom-Left (min diff)\r\n    if (diff < minDiff) {\r\n      minDiff = diff;\r\n      bottomLeft = point;\r\n    }\r\n  }\r\n\r\n  return {\r\n    topLeft,\r\n    topRight,\r\n    bottomRight,\r\n    bottomLeft\r\n  };\r\n}\r\n\r\n/**\r\n * Orders 4 points in clockwise order starting from top-left\r\n * @param {Array} points - Array of 4 points to order\r\n * @returns {Object} Object with ordered points\r\n */\r\nfunction orderCornerPoints(points) {\r\n  if (points.length !== 4) {\r\n    console.warn(`Expected 4 points, got ${points.length}`);\r\n    return null;\r\n  }\r\n  \r\n  // Calculate centroid\r\n  const center = findCenter(points);\r\n  \r\n  // Sort the points by their angles relative to the center\r\n  const sortedPoints = [...points].sort((a, b) => {\r\n    const angleA = Math.atan2(a.y - center.y, a.x - center.x);\r\n    const angleB = Math.atan2(b.y - center.y, b.x - center.x);\r\n    return angleA - angleB;\r\n  });\r\n  \r\n  // Now find the top-left point (minimum sum of x and y)\r\n  let minSum = Infinity;\r\n  let minIndex = 0;\r\n  \r\n  for (let i = 0; i < 4; i++) {\r\n    const sum = sortedPoints[i].x + sortedPoints[i].y;\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      minIndex = i;\r\n    }\r\n  }\r\n  \r\n  // Reorder array to start with the top-left point\r\n  const orderedPoints = [\r\n    sortedPoints[minIndex],\r\n    sortedPoints[(minIndex + 1) % 4],\r\n    sortedPoints[(minIndex + 2) % 4],\r\n    sortedPoints[(minIndex + 3) % 4]\r\n  ];\r\n  \r\n  // Return as named corners\r\n  return {\r\n    topLeft: orderedPoints[0],\r\n    topRight: orderedPoints[1],\r\n    bottomRight: orderedPoints[2],\r\n    bottomLeft: orderedPoints[3]\r\n  };\r\n}","let wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @returns {Uint8Array}\n */\nexport function dilate(edges, width, height, kernel_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate(ptr0, len0, width, height, kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @param {number} kernel_size\n * @param {number} sigma\n * @param {boolean} l2_gradient\n * @param {boolean} apply_dilation\n * @param {number} dilation_kernel_size\n * @returns {Uint8Array}\n */\nexport function canny_edge_detector_full(grayscale, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.canny_edge_detector_full(ptr0, len0, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Applies double thresholding and hysteresis using a stack-based approach.\n * Optimized version with SIMD for threshold comparisons and better memory access patterns.\n * Follows OpenCV's logic more closely.\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Edge map as Vec<u8> (0: weak edge/potential, 1: non-edge, 2: strong edge)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Creates a binary edge image from the hysteresis edge map\n * SIMD-optimized version for converting edge map to binary\n *\n * # Arguments\n * * `edge_map` - Edge map from hysteresis thresholding (0, 1, 2 values)\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Uint8Array} edge_map\n * @returns {Uint8Array}\n */\nexport function edge_map_to_binary(edge_map) {\n    const ptr0 = passArray8ToWasm0(edge_map, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_map_to_binary(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined hysteresis thresholding and binary conversion\n * This is a convenience function that combines both steps for efficiency\n * Optimized to avoid intermediate allocations where possible\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding_binary(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding_binary(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function blur(grayscale, width, height, kernel_size, sigma) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.blur(ptr0, len0, width, height, kernel_size, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint16ArrayMemory0 = null;\n\nfunction getUint16ArrayMemory0() {\n    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {\n        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16ArrayMemory0;\n}\n\nfunction passArray16ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 2, 2) >>> 0;\n    getUint16ArrayMemory0().set(arg, ptr / 2);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * @param {Int16Array} dx\n * @param {Int16Array} dy\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_gradient\n * @returns {Float32Array}\n */\nexport function non_maximum_suppression(dx, dy, width, height, l2_gradient) {\n    const ptr0 = passArray16ToWasm0(dx, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(dy, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.non_maximum_suppression(ptr0, len0, ptr1, len1, width, height, l2_gradient);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\nlet cachedInt16ArrayMemory0 = null;\n\nfunction getInt16ArrayMemory0() {\n    if (cachedInt16ArrayMemory0 === null || cachedInt16ArrayMemory0.byteLength === 0) {\n        cachedInt16ArrayMemory0 = new Int16Array(wasm.memory.buffer);\n    }\n    return cachedInt16ArrayMemory0;\n}\n\nfunction getArrayI16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n/**\n * @param {Uint8Array} blurred\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function calculate_gradients(blurred, width, height) {\n    const ptr0 = passArray8ToWasm0(blurred, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_gradients(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat32ArrayMemory0 = null;\n    cachedInt16ArrayMemory0 = null;\n    cachedUint16ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('wasm_blur_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","/**\r\n * Pure JavaScript implementation of edge detection algorithms\r\n * Inspired by OpenCV's Canny edge detector\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport init, { \r\n  blur as wasmBlur, \r\n  calculate_gradients as wasmGradients, \r\n  dilate as wasmDilate, \r\n  non_maximum_suppression as wasmMaximumSuppression, \r\n  canny_edge_detector_full as wasmFullCanny,\r\n  hysteresis_thresholding as wasmHysteresis,\r\n  hysteresis_thresholding_binary as wasmHysteresisBinary\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize the wasm module\r\nlet wasmReadyPromise = null;\r\n\r\n/**\r\n * Initializes the WASM module if not already initialized\r\n * @returns {Promise}\r\n */\r\nexport function initializeWasm() {\r\n  if (!wasmReadyPromise) {\r\n    wasmReadyPromise = init();\r\n  }\r\n  return wasmReadyPromise;\r\n}\r\n\r\n/**\r\n * Converts ImageData to grayscale (separate from blur for consistency with jscanify)\r\n * @param {ImageData} imageData - Original image data\r\n * @returns {Uint8ClampedArray} Grayscale image data (1 channel)\r\n */\r\nexport function convertToGrayscale(imageData) {\r\n  const { width, height, data } = imageData;\r\n  const grayscale = new Uint8ClampedArray(width * height);\r\n  \r\n  // Convert to grayscale with integer math (faster than floating point)\r\n  // Use bit shifting for multiplication (>>8 is equivalent to /256)\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    // 54 (~0.2126*256), 183 (~0.7152*256), 19 (~0.0722*256)\r\n    grayscale[j] = (data[i] * 54 + data[i+1] * 183 + data[i+2] * 19) >> 8;\r\n  }\r\n  \r\n  return grayscale;\r\n}\r\n\r\n/**\r\n * Applies Gaussian blur to a grayscale image (matching jscanify's approach)\r\n * @param {Uint8ClampedArray} grayscale - Grayscale image data\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (should be 5 to match jscanify)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data\r\n */\r\nexport function gaussianBlurGrayscale(grayscale, width, height, kernelSize = 5, sigma = 0) {\r\n  // If sigma is 0, calculate it from kernel size (OpenCV default)\r\n  if (sigma === 0) {\r\n    sigma = 0.3 * ((kernelSize - 1) * 0.5 - 1) + 0.8;\r\n  }\r\n  \r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  \r\n  // Create and normalize Gaussian kernel once\r\n  const kernel = createGaussianKernel(kernelSize, sigma);\r\n  \r\n  // Preallocate arrays\r\n  const tempArray = new Uint8ClampedArray(width * height);\r\n  const blurred = new Uint8ClampedArray(width * height);\r\n  \r\n  // Horizontal pass - process rows in a single loop to improve cache locality\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel horizontally with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const xOffset = Math.min(width - 1, Math.max(0, x + k));\r\n        sum += grayscale[rowOffset + xOffset] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      tempArray[rowOffset + x] = sum;\r\n    }\r\n  }\r\n  \r\n  // Vertical pass - process columns with better memory access pattern\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel vertically with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const yOffset = Math.min(height - 1, Math.max(0, y + k));\r\n        sum += tempArray[yOffset * width + x] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      blurred[y * width + x] = Math.round(sum);\r\n    }\r\n  }\r\n  \r\n  return blurred;\r\n}\r\n\r\n/**\r\n * Legacy wrapper for backwards compatibility\r\n * @param {ImageData} imageData - Original image data\r\n * @param {number} sigma - Gaussian sigma parameter (standard deviation)\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data (1 channel)\r\n */\r\nexport function gaussianBlur(imageData, sigma = DEFAULTS.GAUSSIAN_SIGMA, forcedKernelSize = null) {\r\n  const grayscale = convertToGrayscale(imageData);\r\n  const kernelSize = forcedKernelSize || 5; // Default to 5 like jscanify\r\n  return gaussianBlurGrayscale(grayscale, imageData.width, imageData.height, kernelSize, sigma);\r\n}\r\n\r\n/**\r\n * Creates a 1D Gaussian kernel\r\n * @param {number} size - Kernel size (odd number)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Float32Array} Gaussian kernel\r\n */\r\nfunction createGaussianKernel(size, sigma) {\r\n  const kernel = new Float32Array(size);\r\n  const halfSize = Math.floor(size / 2);\r\n  \r\n  let sum = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const x = i - halfSize;\r\n    // Gaussian function: (1/(sigma*sqrt(2*PI))) * e^(-(x^2)/(2*sigma^2))\r\n    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));\r\n    sum += kernel[i];\r\n  }\r\n  \r\n  // Normalize kernel\r\n  for (let i = 0; i < size; i++) {\r\n    kernel[i] /= sum;\r\n  }\r\n  \r\n  return kernel;\r\n}\r\n\r\n/**\r\n * Calculates the gradients (dx, dy) using Sobel operators\r\n * @param {Uint8ClampedArray} blurred - Blurred grayscale image\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @returns {{dx: Int16Array, dy: Int16Array}} Object containing gradient arrays\r\n */\r\nfunction calculateGradients(blurred, width, height) {\r\n  // Use Int16Array to store gradients, allowing negative values\r\n  const dx = new Int16Array(width * height);\r\n  const dy = new Int16Array(width * height);\r\n  \r\n  // Find gradients by unrolling the Sobel operator loops\r\n  for (let y = 1; y < height - 1; y++) {\r\n    const rowOffset = y * width;\r\n    const prevRowOffset = (y - 1) * width;\r\n    const nextRowOffset = (y + 1) * width;\r\n\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const currentIdx = rowOffset + x;\r\n\r\n      // Get neighborhood pixels\r\n      const p0 = blurred[prevRowOffset + x - 1];\r\n      const p1 = blurred[prevRowOffset + x];\r\n      const p2 = blurred[prevRowOffset + x + 1];\r\n      const p3 = blurred[rowOffset + x - 1];\r\n      const p5 = blurred[rowOffset + x + 1];\r\n      const p6 = blurred[nextRowOffset + x - 1];\r\n      const p7 = blurred[nextRowOffset + x];\r\n      const p8 = blurred[nextRowOffset + x + 1];\r\n      \r\n      // Calculate Sobel gradients\r\n      const gx = (p2 - p0) + 2 * (p5 - p3) + (p8 - p6);\r\n      const gy = (p6 + 2 * p7 + p8) - (p0 + 2 * p1 + p2);\r\n      \r\n      dx[currentIdx] = gx;\r\n      dy[currentIdx] = gy;\r\n    }\r\n  }\r\n  \r\n  return { dx, dy };\r\n}\r\n\r\n\r\n/**\r\n * Applies non-maximum suppression to the gradient magnitude\r\n * @param {Int16Array} dx - Gradient in x-direction\r\n * @param {Int16Array} dy - Gradient in y-direction\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {boolean} L2gradient - Whether to use L2 norm for magnitude\r\n * @returns {Float32Array} Suppressed magnitude (using Float32 for precision)\r\n */\r\nfunction nonMaximumSuppression(dx, dy, width, height, L2gradient) {\r\n  // Use Float32Array for magnitude to preserve precision before thresholding\r\n  const magnitude = new Float32Array(width * height);\r\n  const suppressed = new Float32Array(width * height);\r\n  \r\n  // Calculate magnitude for all pixels first\r\n  for (let i = 0; i < dx.length; i++) {\r\n    const gx = dx[i];\r\n    const gy = dy[i];\r\n    if (L2gradient) {\r\n      magnitude[i] = Math.sqrt(gx * gx + gy * gy);\r\n    } else {\r\n      magnitude[i] = Math.abs(gx) + Math.abs(gy); // L1 norm\r\n    }\r\n  }\r\n  \r\n  // Perform non-maximum suppression\r\n  for (let y = 1; y < height - 1; y++) {\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = magnitude[idx];\r\n      \r\n      // Skip pixels with zero magnitude\r\n      if (mag === 0) {\r\n        suppressed[idx] = 0;\r\n        continue;\r\n      }\r\n      \r\n      const gx = dx[idx];\r\n      const gy = dy[idx];\r\n      \r\n      let neighbor1 = 0, neighbor2 = 0;\r\n      \r\n      // Determine neighbors based on gradient direction\r\n      // Use absolute values to determine dominant direction\r\n      const absGx = Math.abs(gx);\r\n      const absGy = Math.abs(gy);\r\n      \r\n      if (absGy > absGx * 2.4142) { // Vertical edge (angle near 90 or 270)\r\n        neighbor1 = magnitude[idx - width]; // top\r\n        neighbor2 = magnitude[idx + width]; // bottom\r\n      } else if (absGx > absGy * 2.4142) { // Horizontal edge (angle near 0 or 180)\r\n        neighbor1 = magnitude[idx - 1]; // left\r\n        neighbor2 = magnitude[idx + 1]; // right\r\n      } else { // Diagonal edge\r\n        // Determine diagonal direction based on signs of gx and gy\r\n        const s = (gx ^ gy) < 0 ? -1 : 1; // Check if signs are different\r\n        if (gy > 0) { // Gradient points down\r\n          neighbor1 = magnitude[(y - 1) * width + (x - s)]; // top-left/right\r\n          neighbor2 = magnitude[(y + 1) * width + (x + s)]; // bottom-right/left\r\n        } else { // Gradient points up\r\n          neighbor1 = magnitude[(y + 1) * width + (x - s)]; // bottom-left/right\r\n          neighbor2 = magnitude[(y - 1) * width + (x + s)]; // top-right/left\r\n        }\r\n        // Refined diagonal check (approximating OpenCV's logic)\r\n        // Check 45 degrees (top-right / bottom-left)\r\n        if ((gx > 0 && gy > 0) || (gx < 0 && gy < 0)) { // Quadrants 1 & 3\r\n             neighbor1 = magnitude[(y - 1) * width + (x + 1)]; // top-right\r\n             neighbor2 = magnitude[(y + 1) * width + (x - 1)]; // bottom-left\r\n        } else { // Quadrants 2 & 4 (135 degrees)\r\n             neighbor1 = magnitude[(y - 1) * width + (x - 1)]; // top-left\r\n             neighbor2 = magnitude[(y + 1) * width + (x + 1)]; // bottom-right\r\n        }\r\n      }\r\n      \r\n      // If the pixel's magnitude is greater than or equal to its neighbors\r\n      // along the gradient direction, keep it. Otherwise, suppress it.\r\n      if (mag >= neighbor1 && mag >= neighbor2) {\r\n        suppressed[idx] = mag;\r\n      } else {\r\n        suppressed[idx] = 0;\r\n      }\r\n    }\r\n  }\r\n  return suppressed;\r\n}\r\n\r\n\r\n/**\r\n * Applies double thresholding and hysteresis using a stack-based approach.\r\n * Follows OpenCV's logic more closely.\r\n * @param {Float32Array} suppressed - Suppressed magnitude (Float32Array)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} lowThreshold - Low threshold value\r\n * @param {number} highThreshold - High threshold value\r\n * @returns {Uint8Array} Edge map (0: non-edge, 2: edge pixel)\r\n */\r\nfunction hysteresisThresholding(suppressed, width, height, lowThreshold, highThreshold) {\r\n  // Map values: 0 = weak edge (potential), 1 = non-edge, 2 = strong edge\r\n  const edgeMap = new Uint8Array(width * height);\r\n  const stack = [];\r\n  \r\n  // First pass: Identify strong edges and potential weak edges\r\n  for (let y = 1; y < height - 1; y++) { // Iterate excluding borders\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = suppressed[idx];\r\n      \r\n      if (mag >= highThreshold) {\r\n        // Strong edge pixel\r\n        edgeMap[idx] = 2;\r\n        stack.push({ x, y });\r\n      } else if (mag >= lowThreshold) {\r\n        // Weak edge pixel (potential edge)\r\n        edgeMap[idx] = 0; // Mark as potential\r\n      } else {\r\n        // Non-edge pixel\r\n        edgeMap[idx] = 1; // Mark as non-edge\r\n      }\r\n    }\r\n  }\r\n  // Initialize borders as non-edge (value 1)\r\n   for (let x = 0; x < width; x++) {\r\n       edgeMap[x] = 1; // Top row\r\n       edgeMap[(height - 1) * width + x] = 1; // Bottom row\r\n   }\r\n   for (let y = 1; y < height - 1; y++) {\r\n       edgeMap[y * width] = 1; // Left column\r\n       edgeMap[y * width + width - 1] = 1; // Right column\r\n   }\r\n\r\n\r\n  // Second pass: Hysteresis - connect weak edges to strong edges\r\n  const dxNeighbors = [-1, 0, 1, -1, 1, -1, 0, 1];\r\n  const dyNeighbors = [-1, -1, -1, 0, 0, 1, 1, 1];\r\n  \r\n  while (stack.length > 0) {\r\n    const { x, y } = stack.pop();\r\n    \r\n    // Check all 8 neighbors\r\n    for (let i = 0; i < 8; i++) {\r\n      const nx = x + dxNeighbors[i];\r\n      const ny = y + dyNeighbors[i];\r\n      const nidx = ny * width + nx;\r\n      \r\n      // Check bounds (already handled by border initialization)\r\n      // If neighbor is a weak edge (value 0), promote it to strong (value 2) and add to stack\r\n      if (edgeMap[nidx] === 0) {\r\n        edgeMap[nidx] = 2; // Promote to strong edge\r\n        stack.push({ x: nx, y: ny });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Note: Pixels that were initially weak (0) but not connected remain 0.\r\n  // Pixels below lowThreshold remain 1. Only pixels marked 2 are considered final edges.\r\n  \r\n  return edgeMap; // Return the map with 0, 1, 2 values\r\n}\r\n\r\n/**\r\n * Applies morphological dilation to binary image using a separable (two-pass) approach.\r\n * This is much faster than a 2D kernel for square structuring elements.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (0 or 255)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (default 5 to match jscanify)\r\n * @returns {Uint8ClampedArray} Dilated edge image\r\n */\r\nexport function dilateEdges(edges, width, height, kernelSize = 5) {\r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  const temp = new Uint8ClampedArray(width * height);\r\n  const dilated = new Uint8ClampedArray(width * height);\r\n\r\n  // Horizontal pass\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    for (let x = 0; x < width; x++) {\r\n      let maxVal = 0;\r\n      // Find max in horizontal neighborhood\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const nx = x + k;\r\n        if (nx >= 0 && nx < width) {\r\n          const val = edges[rowOffset + nx];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      temp[rowOffset + x] = maxVal;\r\n    }\r\n  }\r\n\r\n  // Vertical pass\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let maxVal = 0;\r\n      // Find max in vertical neighborhood from temp array\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const ny = y + k;\r\n        if (ny >= 0 && ny < height) {\r\n          const val = temp[ny * width + x];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      dilated[y * width + x] = maxVal;\r\n    }\r\n  }\r\n  \r\n  return dilated;\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation matching jscanify's approach\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.lowThreshold=75] - Low threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.highThreshold=200] - High threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.sigma=0] - Gaussian blur sigma (0 means auto-calculate from kernel size)\r\n * @param {number} [options.kernelSize=5] - Gaussian kernel size (matching jscanify)\r\n * @param {boolean} [options.L2gradient=false] - Use L2 norm for gradient magnitude (like OpenCV default)\r\n * @param {boolean} [options.applyDilation=true] - Apply dilation after Canny (matching jscanify)\r\n * @param {number} [options.dilationKernelSize=5] - Dilation kernel size\r\n * @param {boolean} [options.useWasmBlur=false] - Use WASM for Gaussian blur\r\n * @param {boolean} [options.useWasmGradients=false] - Use WASM for gradient calculation\r\n * @param {boolean} [options.useWasmDilation=false] - Use WASM for dilation\r\n * @param {boolean} [options.useWasmNMS=false] - Use WASM for non-maximum suppression\r\n * @param {boolean} [options.useWasmHysteresis=false] - Use WASM for hysteresis thresholding\r\n * @param {boolean} [options.useWasmFullCanny=false] - Use the full WASM Canny implementation\r\n * @param {object} [options.debug={}] - Object to store intermediate results if provided\r\n * @param {boolean} [options.skipGrayscale=false] - Skip grayscale conversion (input is already grayscale Uint8ClampedArray)\r\n * @param {number} [options.width] - Image width (required if skipGrayscale is true)\r\n * @param {number} [options.height] - Image height (required if skipGrayscale is true)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetector(input, options = {}) {\r\n  // Timing table setup\r\n  const timings = [];\r\n  const tStart = performance.now();\r\n\r\n  // Handle both ImageData and pre-computed grayscale Uint8ClampedArray\r\n  const skipGrayscale = options.skipGrayscale || false;\r\n  let width, height, grayscale;\r\n  \r\n  if (skipGrayscale) {\r\n    // Input is already grayscale Uint8ClampedArray\r\n    width = options.width;\r\n    height = options.height;\r\n    grayscale = input;\r\n    if (options.debug) options.debug.grayscale = grayscale;\r\n  } else {\r\n    // Input is ImageData - extract dimensions and convert to grayscale\r\n    width = input.width;\r\n    height = input.height;\r\n    \r\n    let t0 = performance.now();\r\n    grayscale = convertToGrayscale(input);\r\n    let t1 = performance.now();\r\n    timings.push({ step: 'Grayscale', ms: (t1 - t0).toFixed(2) });\r\n    if (options.debug) options.debug.grayscale = grayscale;\r\n  }\r\n\r\n  let lowThreshold = options.lowThreshold !== undefined ? options.lowThreshold : 75;\r\n  let highThreshold = options.highThreshold !== undefined ? options.highThreshold : 200;\r\n  const kernelSize = options.kernelSize || 5; // Match jscanify's 5x5 kernel\r\n  const sigma = options.sigma || 0; // Let the blur function calculate sigma\r\n  const L2gradient = options.L2gradient === undefined ? false : options.L2gradient;\r\n  const applyDilation = options.applyDilation !== undefined ? options.applyDilation : true;\r\n  const dilationKernelSize = options.dilationKernelSize || 5;\r\n  const useWasmBlur = true;\r\n  const useWasmGradients = false; \r\n  const useWasmDilation = true;\r\n  const useWasmNMS = true;\r\n  const useWasmHysteresis = options.useWasmHysteresis !== undefined ? options.useWasmHysteresis : false;\r\n  const useWasmFullCanny = false;\r\n\r\n  // Ensure high threshold is greater than low threshold\r\n  if (lowThreshold >= highThreshold) {\r\n      console.warn(`Canny Edge Detector: lowThreshold (${lowThreshold}) should be lower than highThreshold (${highThreshold}). Swapping them.`);\r\n      [lowThreshold, highThreshold] = [highThreshold, lowThreshold];\r\n  }\r\n\r\n  // Timing variables\r\n  let t0, t1;\r\n\r\n  // Step 2: Apply Gaussian blur (JS or WASM)\r\n  let blurred;\r\n  t0 = performance.now();\r\n  if (useWasmBlur) {\r\n    try {\r\n      await initializeWasm(); // Ensure wasm is initialized\r\n      blurred = wasmBlur(grayscale, width, height, kernelSize, sigma);\r\n    } catch (e) {\r\n      blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n    }\r\n  } else {\r\n    blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gaussian Blur', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) {\r\n    options.debug.blurred = blurred;\r\n  }\r\n\r\n  // Step 3: Compute gradients (dx, dy)\r\n  t0 = performance.now();\r\n  let dx, dy;\r\n  if (useWasmGradients) {\r\n    try {\r\n      await initializeWasm(); // Ensure wasm is initialized\r\n      const gradientResult = wasmGradients(blurred, width, height);\r\n      dx = new Int16Array(gradientResult.gx);\r\n      dy = new Int16Array(gradientResult.gy);\r\n    } catch (e) {\r\n      const gradients = calculateGradients(blurred, width, height);\r\n      dx = gradients.dx;\r\n      dy = gradients.dy;\r\n    }\r\n  } else {\r\n    const gradients = calculateGradients(blurred, width, height);\r\n    dx = gradients.dx;\r\n    dy = gradients.dy;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gradients', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 4: Apply non-maximum suppression\r\n  t0 = performance.now();\r\n  let suppressed;\r\n  if (useWasmNMS) {\r\n    try {\r\n      await initializeWasm();\r\n      suppressed = await wasmMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    } catch (e) {\r\n      suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    }\r\n  } else {\r\n    suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Non-Max Suppression', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 5: Apply double thresholding and hysteresis\r\n  t0 = performance.now();\r\n  const finalLowThreshold = L2gradient ? lowThreshold * lowThreshold : lowThreshold;\r\n  const finalHighThreshold = L2gradient ? highThreshold * highThreshold : highThreshold;\r\n  \r\n  let edgeMap;\r\n  if (useWasmHysteresis) {\r\n    try {\r\n      await initializeWasm();\r\n      edgeMap = wasmHysteresis(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    } catch (e) {\r\n      console.warn(\"WASM hysteresis failed, falling back to JS:\", e);\r\n      edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    }\r\n  } else {\r\n    edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n  }\r\n  \r\n  t1 = performance.now();\r\n  timings.push({ step: 'Hysteresis', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 6: Create binary image (0 or 255)\r\n  t0 = performance.now();\r\n  const cannyEdges = new Uint8ClampedArray(width * height);\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    cannyEdges[i] = edgeMap[i] === 2 ? 255 : 0;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Binary Image', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 7: Apply dilation if requested (matching jscanify)\r\n  t0 = performance.now();\r\n  let finalEdges = cannyEdges;\r\n  if (applyDilation) {\r\n    if (useWasmDilation) {\r\n      try {\r\n        await initializeWasm(); // Ensure wasm is initialized\r\n        finalEdges = wasmDilate(cannyEdges, width, height, dilationKernelSize);\r\n      } catch (e) {\r\n        finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n      }\r\n    } else {\r\n      finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n    }\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Dilation', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.dx = dx; // Int16Array\r\n    options.debug.dy = dy; // Int16Array\r\n    // Calculate magnitude separately for debugging if needed\r\n     const magnitude = new Float32Array(width * height);\r\n     for (let i = 0; i < dx.length; i++) {\r\n         const gx = dx[i]; const gy = dy[i];\r\n         magnitude[i] = L2gradient ? Math.sqrt(gx * gx + gy * gy) : Math.abs(gx) + Math.abs(gy);\r\n     }\r\n     options.debug.magnitude = magnitude; // Float32Array (raw magnitude)\r\n    options.debug.suppressed = suppressed; // Float32Array (after NMS)\r\n    options.debug.edgeMap = edgeMap; // Uint8Array (0, 1, 2 values from hysteresis)\r\n    options.debug.cannyEdges = cannyEdges; // Uint8ClampedArray (0 or 255, before dilation)\r\n    options.debug.finalEdges = finalEdges; // Uint8ClampedArray (0 or 255, after dilation if applied)\r\n  }\r\n  \r\n  // Always store timings in debug object (create minimal one if needed)\r\n  if (options.debug) {\r\n    options.debug.timings = timings;\r\n  } else if (!options.debug) {\r\n    // Create a minimal debug object just for timings if none provided\r\n    options.debug = { timings: timings };\r\n  }\r\n\r\n  const tEnd = performance.now();\r\n  timings.unshift({ step: 'Edge Detection Total', ms: (tEnd - tStart).toFixed(2) });\r\n  // Timings available via options.debug.timings\r\n\r\n  return finalEdges; // Return the final binary edge image\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation using WASM, for comparison or direct use\r\n * This function is intended to match the performance and output of the JS cannyEdgeDetector,\r\n * but runs entirely in WASM for potentially faster execution.\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options (same as cannyEdgeDetector)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetectorWasm(imageData, options = {}) {\r\n  // Directly call the WASM canny_edge_detector_full function\r\n  let result;\r\n  try {\r\n    await initializeWasm(); // Ensure wasm is initialized\r\n    console.log('Using WASM Full Canny');\r\n    result = wasmFullCanny(imageData.data, imageData.width, imageData.height, options.lowThreshold, options.highThreshold, options.sigma, options.kernelSize, options.L2gradient, options.applyDilation, options.dilationKernelSize);\r\n  } catch (e) {\r\n    console.error(\"WASM full Canny failed:\", e);\r\n    throw e; // Rethrow to let the caller handle the error\r\n  }\r\n  \r\n  // Convert result to Uint8ClampedArray (if not already)\r\n  const edges = new Uint8ClampedArray(result);\r\n  \r\n  return edges;\r\n}","/**\r\n * scanic\r\n * JavaScript document scanner without OpenCV dependency\r\n * MIT License\r\n */\r\n\r\n\r\nimport { detectDocumentContour } from './contourDetection.js';\r\nimport { findCornerPoints } from './cornerDetection.js';\r\nimport { cannyEdgeDetector, initializeWasm } from './edgeDetection.js';\r\n\r\n/**\r\n * Global initialization helper for convenience.\r\n */\r\nexport async function initialize() {\r\n  return await initializeWasm();\r\n}\r\n\r\n/**\r\n * Unified Scanner class for better state and configuration management.\r\n */\r\nexport class Scanner {\r\n  constructor(options = {}) {\r\n    this.defaultOptions = {\r\n      maxProcessingDimension: 800,\r\n      mode: 'detect',\r\n      output: 'canvas',\r\n      ...options\r\n    };\r\n    this.initialized = false;\r\n  }\r\n\r\n  /**\r\n   * Warm up the scanner (load WASM, etc.)\r\n   */\r\n  async initialize() {\r\n    if (this.initialized) return;\r\n    await initializeWasm();\r\n    this.initialized = true;\r\n  }\r\n\r\n  /**\r\n   * Scan an image for a document.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image \r\n   * @param {Object} options Override default options\r\n   */\r\n  async scan(image, options = {}) {\r\n    if (!this.initialized) await this.initialize();\r\n    const combinedOptions = { ...this.defaultOptions, ...options };\r\n    return await scanDocument(image, combinedOptions);\r\n  }\r\n\r\n  /**\r\n   * Extract a document from an image using manual corners.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image \r\n   * @param {Object} corners \r\n   * @param {Object} options \r\n   */\r\n  async extract(image, corners, options = {}) {\r\n    if (!this.initialized) await this.initialize();\r\n    const combinedOptions = { ...this.defaultOptions, ...options };\r\n    return await extractDocument(image, corners, combinedOptions);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Prepares image, downscales, and converts to grayscale in a single operation.\r\n * Uses OffscreenCanvas and CSS filters for maximum performance.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image - Input image\r\n * @param {number} maxDimension - Maximum dimension for processing (default 800)\r\n * @returns {Promise<Object>} { grayscaleData, scaleFactor, originalDimensions, scaledDimensions }\r\n */\r\nasync function prepareScaleAndGrayscale(image, maxDimension = 800) {\r\n  let originalWidth, originalHeight;\r\n  \r\n  // Robust check for ImageData without relying on global ImageData class\r\n  const isImageData = image && typeof image.width === 'number' && typeof image.height === 'number' && image.data;\r\n\r\n  // Get original dimensions\r\n  if (isImageData) {\r\n    originalWidth = image.width;\r\n    originalHeight = image.height;\r\n  } else if (image) {\r\n    originalWidth = image.width || image.naturalWidth;\r\n    originalHeight = image.height || image.naturalHeight;\r\n  } else {\r\n    throw new Error('No image provided');\r\n  }\r\n  \r\n  const maxCurrentDimension = Math.max(originalWidth, originalHeight);\r\n  \r\n  // Calculate target dimensions\r\n  let targetWidth, targetHeight, scaleFactor;\r\n  \r\n  if (maxCurrentDimension <= maxDimension) {\r\n    targetWidth = originalWidth;\r\n    targetHeight = originalHeight;\r\n    scaleFactor = 1;\r\n  } else {\r\n    const scale = maxDimension / maxCurrentDimension;\r\n    targetWidth = Math.round(originalWidth * scale);\r\n    targetHeight = Math.round(originalHeight * scale);\r\n    scaleFactor = 1 / scale;\r\n  }\r\n  \r\n  // Use OffscreenCanvas if available (faster, no DOM interaction)\r\n  const useOffscreen = typeof OffscreenCanvas !== 'undefined';\r\n  const canvas = useOffscreen \r\n    ? new OffscreenCanvas(targetWidth, targetHeight)\r\n    : document.createElement('canvas');\r\n  \r\n  if (!useOffscreen) {\r\n    canvas.width = targetWidth;\r\n    canvas.height = targetHeight;\r\n  }\r\n  \r\n  const ctx = canvas.getContext('2d', { willReadFrequently: true });\r\n  \r\n  // Apply grayscale filter during draw - GPU accelerated!\r\n  ctx.filter = 'grayscale(1)';\r\n  ctx.imageSmoothingEnabled = true;\r\n  ctx.imageSmoothingQuality = 'medium';\r\n  \r\n  if (isImageData) {\r\n    // For ImageData, need to put on temp canvas first\r\n    const tempCanvas = useOffscreen\r\n      ? new OffscreenCanvas(originalWidth, originalHeight)\r\n      : document.createElement('canvas');\r\n    if (!useOffscreen) {\r\n      tempCanvas.width = originalWidth;\r\n      tempCanvas.height = originalHeight;\r\n    }\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    tempCtx.putImageData(image, 0, 0);\r\n    ctx.drawImage(tempCanvas, 0, 0, originalWidth, originalHeight, 0, 0, targetWidth, targetHeight);\r\n  } else {\r\n    // Direct draw with scaling + grayscale filter\r\n    ctx.drawImage(image, 0, 0, originalWidth, originalHeight, 0, 0, targetWidth, targetHeight);\r\n  }\r\n  \r\n  // Get the grayscale image data\r\n  const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);\r\n  \r\n  // Extract single-channel grayscale (R=G=B after filter, so just take R)\r\n  const grayscaleData = new Uint8ClampedArray(targetWidth * targetHeight);\r\n  const data = imageData.data;\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    grayscaleData[j] = data[i]; // R channel (same as G and B after grayscale filter)\r\n  }\r\n  \r\n  return {\r\n    grayscaleData,\r\n    imageData, // Keep full RGBA for debug visualization\r\n    scaleFactor,\r\n    originalDimensions: { width: originalWidth, height: originalHeight },\r\n    scaledDimensions: { width: targetWidth, height: targetHeight }\r\n  };\r\n}\r\n\r\n// Internal function to detect document in image\r\n// Now accepts pre-computed grayscale data (from prepareScaleAndGrayscale)\r\nasync function detectDocumentInternal(grayscaleData, width, height, scaleFactor, options = {}) {\r\n  // Always create a debug object to collect timings (even if not in debug mode)\r\n  const debugInfo = options.debug ? {} : { _timingsOnly: true };\r\n  const timings = [];\r\n  \r\n  if (debugInfo && !debugInfo._timingsOnly) {\r\n    debugInfo.preprocessing = {\r\n      scaledDimensions: { width, height },\r\n      scaleFactor,\r\n      maxProcessingDimension: options.maxProcessingDimension || 800\r\n    };\r\n  }\r\n  \r\n  // Run edge detection on pre-computed grayscale data (skip grayscale conversion)\r\n  const edges = await cannyEdgeDetector(grayscaleData, {\r\n    width,\r\n    height,\r\n    lowThreshold: options.lowThreshold || 75,   // Match OpenCV values\r\n    highThreshold: options.highThreshold || 200, // Match OpenCV values\r\n    dilationKernelSize: options.dilationKernelSize || 3, // Match OpenCV value \r\n    dilationIterations: options.dilationIterations || 1,\r\n    debug: debugInfo,\r\n    skipGrayscale: true, // Skip grayscale - already done in prep\r\n    useWasmBlur: true,\r\n  });\r\n  \r\n  // Extract edge detection timings (skip the 'Total' entry)\r\n  if (debugInfo.timings) {\r\n    debugInfo.timings.forEach(t => {\r\n      if (t.step !== 'Edge Detection Total') timings.push(t);\r\n    });\r\n  }\r\n  \r\n  // Detect contours from edges\r\n  let t0 = performance.now();\r\n  const contours = detectDocumentContour(edges, {\r\n    minArea: (options.minArea || 1000) / (scaleFactor * scaleFactor), // Adjust minArea for scaled image\r\n    debug: debugInfo,\r\n    width: width,     \r\n    height: height    \r\n  });\r\n  timings.push({ step: 'Find Contours', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (!contours || contours.length === 0) {\r\n    console.log('No document detected');\r\n    return {\r\n      success: false,\r\n      message: 'No document detected',\r\n      debug: debugInfo._timingsOnly ? null : debugInfo,\r\n      timings: timings\r\n    };\r\n  }\r\n  \r\n  // Get the largest contour which is likely the document\r\n  const documentContour = contours[0]; \r\n  \r\n  // Find corner points on the scaled image\r\n  t0 = performance.now();\r\n  const cornerPoints = findCornerPoints(documentContour, { \r\n      epsilon: options.epsilon // Pass epsilon for approximation\r\n  });\r\n  timings.push({ step: 'Corner Detection', ms: (performance.now() - t0).toFixed(2) });\r\n  \r\n  // Scale corner points back to original image size\r\n  let finalCorners = cornerPoints;\r\n  if (scaleFactor !== 1) {\r\n    finalCorners = {\r\n      topLeft: { x: cornerPoints.topLeft.x * scaleFactor, y: cornerPoints.topLeft.y * scaleFactor },\r\n      topRight: { x: cornerPoints.topRight.x * scaleFactor, y: cornerPoints.topRight.y * scaleFactor },\r\n      bottomRight: { x: cornerPoints.bottomRight.x * scaleFactor, y: cornerPoints.bottomRight.y * scaleFactor },\r\n      bottomLeft: { x: cornerPoints.bottomLeft.x * scaleFactor, y: cornerPoints.bottomLeft.y * scaleFactor },\r\n    };\r\n  }\r\n  \r\n  // Return the result, scaling the contour points back up as well\r\n  return {\r\n    success: true,\r\n    contour: documentContour,\r\n    corners: finalCorners,\r\n    debug: debugInfo._timingsOnly ? null : debugInfo,\r\n    timings: timings\r\n  };\r\n}\r\n\r\n// --- Perspective transform helpers (internal use only) ---\r\nfunction getPerspectiveTransform(srcPoints, dstPoints) {\r\n  // Helper to build the system of equations\r\n  function buildMatrix(points) {\r\n    const matrix = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      const [x, y] = points[i];\r\n      matrix.push([x, y, 1, 0, 0, 0, -x * dstPoints[i][0], -y * dstPoints[i][0]]);\r\n      matrix.push([0, 0, 0, x, y, 1, -x * dstPoints[i][1], -y * dstPoints[i][1]]);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  const A = buildMatrix(srcPoints);\r\n  const b = [\r\n    dstPoints[0][0], dstPoints[0][1],\r\n    dstPoints[1][0], dstPoints[1][1],\r\n    dstPoints[2][0], dstPoints[2][1],\r\n    dstPoints[3][0], dstPoints[3][1]\r\n  ];\r\n\r\n  // Solve Ah = b for h (h is 8x1, last element is 1)\r\n  // Use Gaussian elimination or Cramer's rule for 8x8\r\n  // For simplicity, use numeric.js if available, else implement basic solver\r\n  function solve(A, b) {\r\n    // Gaussian elimination for 8x8\r\n    const m = A.length;\r\n    const n = A[0].length;\r\n    const M = A.map(row => row.slice());\r\n    const B = b.slice();\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      // Find max row\r\n      let maxRow = i;\r\n      for (let k = i + 1; k < m; k++) {\r\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\r\n      }\r\n      // Swap rows\r\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\r\n      [B[i], B[maxRow]] = [B[maxRow], B[i]];\r\n\r\n      // Eliminate\r\n      for (let k = i + 1; k < m; k++) {\r\n        const c = M[k][i] / M[i][i];\r\n        for (let j = i; j < n; j++) {\r\n          M[k][j] -= c * M[i][j];\r\n        }\r\n        B[k] -= c * B[i];\r\n      }\r\n    }\r\n\r\n    // Back substitution\r\n    const x = new Array(n);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      let sum = B[i];\r\n      for (let j = i + 1; j < n; j++) {\r\n        sum -= M[i][j] * x[j];\r\n      }\r\n      x[i] = sum / M[i][i];\r\n    }\r\n    return x;\r\n  }\r\n\r\n  const h = solve(A, b);\r\n  // h is [h0,h1,h2,h3,h4,h5,h6,h7], h8 = 1\r\n  const matrix = [\r\n    [h[0], h[1], h[2]],\r\n    [h[3], h[4], h[5]],\r\n    [h[6], h[7], 1]\r\n  ];\r\n  return matrix;\r\n}\r\n\r\n\r\n\r\n\r\nfunction unwarpImage(ctx, image, corners) {\r\n  // Get perspective transform matrix\r\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners;\r\n  // Compute output rectangle size\r\n  const widthA = Math.hypot(bottomRight.x - bottomLeft.x, bottomRight.y - bottomLeft.y);\r\n  const widthB = Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\r\n  const maxWidth = Math.round(Math.max(widthA, widthB));\r\n  const heightA = Math.hypot(topRight.x - bottomRight.x, topRight.y - bottomRight.y);\r\n  const heightB = Math.hypot(topLeft.x - bottomLeft.x, topLeft.y - bottomLeft.y);\r\n  const maxHeight = Math.round(Math.max(heightA, heightB));\r\n\r\n  // Set output canvas size\r\n  ctx.canvas.width = maxWidth;\r\n  ctx.canvas.height = maxHeight;\r\n\r\n  const srcPoints = [\r\n    [topLeft.x, topLeft.y],\r\n    [topRight.x, topRight.y],\r\n    [bottomRight.x, bottomRight.y],\r\n    [bottomLeft.x, bottomLeft.y]\r\n  ];\r\n  const dstPoints = [\r\n    [0, 0],\r\n    [maxWidth - 1, 0],\r\n    [maxWidth - 1, maxHeight - 1],\r\n    [0, maxHeight - 1]\r\n  ];\r\n  const perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);\r\n  warpTransform(ctx, image, perspectiveMatrix, maxWidth, maxHeight);\r\n}\r\n\r\nfunction invert3x3(m) {\r\n  // Invert a 3x3 matrix\r\n  const a = m[0][0], b = m[0][1], c = m[0][2];\r\n  const d = m[1][0], e = m[1][1], f = m[1][2];\r\n  const g = m[2][0], h = m[2][1], i = m[2][2];\r\n  const A = e * i - f * h;\r\n  const B = -(d * i - f * g);\r\n  const C = d * h - e * g;\r\n  const D = -(b * i - c * h);\r\n  const E = a * i - c * g;\r\n  const F = -(a * h - b * g);\r\n  const G = b * f - c * e;\r\n  const H = -(a * f - c * d);\r\n  const I = a * e - b * d;\r\n  const det = a * A + b * B + c * C;\r\n  if (det === 0) throw new Error('Singular matrix');\r\n  return [\r\n    [A / det, D / det, G / det],\r\n    [B / det, E / det, H / det],\r\n    [C / det, F / det, I / det]\r\n  ];\r\n}\r\n\r\nfunction warpTransform(ctx, image, matrix, outWidth, outHeight) {\r\n  // Triangle subdivision approach - uses GPU-accelerated affine transforms\r\n  // Split the quad into a grid, then draw each cell as 2 triangles with affine transforms\r\n  \r\n  const srcWidth = image.width || image.naturalWidth;\r\n  const srcHeight = image.height || image.naturalHeight;\r\n  \r\n  // Inverse matrix for mapping output coords to source coords\r\n  const inv = invert3x3(matrix);\r\n  \r\n  // Helper: map output point to source point using perspective transform\r\n  function mapPoint(x, y) {\r\n    const denom = inv[2][0] * x + inv[2][1] * y + inv[2][2];\r\n    return {\r\n      x: (inv[0][0] * x + inv[0][1] * y + inv[0][2]) / denom,\r\n      y: (inv[1][0] * x + inv[1][1] * y + inv[1][2]) / denom\r\n    };\r\n  }\r\n  \r\n  // Grid subdivisions - 64x64 = 8192 triangles\r\n  const gridX = 64;\r\n  const gridY = 64;\r\n  const cellW = outWidth / gridX;\r\n  const cellH = outHeight / gridY;\r\n  \r\n  // Build source canvas once\r\n  const srcCanvas = document.createElement('canvas');\r\n  srcCanvas.width = srcWidth;\r\n  srcCanvas.height = srcHeight;\r\n  const srcCtx = srcCanvas.getContext('2d');\r\n  srcCtx.drawImage(image, 0, 0, srcWidth, srcHeight);\r\n  \r\n  // High quality results\r\n  ctx.imageSmoothingEnabled = true;\r\n  ctx.imageSmoothingQuality = 'high';\r\n  \r\n  // Draw each grid cell as 2 triangles\r\n  ctx.save();\r\n  \r\n  for (let gy = 0; gy < gridY; gy++) {\r\n    for (let gx = 0; gx < gridX; gx++) {\r\n      // Destination quad corners (in output space)\r\n      const dx0 = gx * cellW;\r\n      const dy0 = gy * cellH;\r\n      const dx1 = (gx + 1) * cellW;\r\n      const dy1 = (gy + 1) * cellH;\r\n      \r\n      // Map to source quad corners\r\n      const s00 = mapPoint(dx0, dy0);\r\n      const s10 = mapPoint(dx1, dy0);\r\n      const s01 = mapPoint(dx0, dy1);\r\n      const s11 = mapPoint(dx1, dy1);\r\n      \r\n      // Draw 2 triangles per cell\r\n      // Triangle 1: top-left, top-right, bottom-left\r\n      drawTexturedTriangle(ctx, srcCanvas,\r\n        s00.x, s00.y, s10.x, s10.y, s01.x, s01.y,  // source triangle\r\n        dx0, dy0, dx1, dy0, dx0, dy1               // dest triangle\r\n      );\r\n      \r\n      // Triangle 2: top-right, bottom-right, bottom-left\r\n      drawTexturedTriangle(ctx, srcCanvas,\r\n        s10.x, s10.y, s11.x, s11.y, s01.x, s01.y,  // source triangle\r\n        dx1, dy0, dx1, dy1, dx0, dy1               // dest triangle\r\n      );\r\n    }\r\n  }\r\n  \r\n  ctx.restore();\r\n}\r\n\r\n// Draw a textured triangle using affine transform + clipping\r\nfunction drawTexturedTriangle(ctx, img,\r\n  sx0, sy0, sx1, sy1, sx2, sy2,  // source triangle coords\r\n  dx0, dy0, dx1, dy1, dx2, dy2   // dest triangle coords\r\n) {\r\n  // Compute affine transform that maps source triangle to dest triangle\r\n  const denom = (sx0 - sx2) * (sy1 - sy2) - (sx1 - sx2) * (sy0 - sy2);\r\n  if (Math.abs(denom) < 1e-10) return; \r\n  \r\n  const invDenom = 1 / denom;\r\n  const a = ((dx0 - dx2) * (sy1 - sy2) - (dx1 - dx2) * (sy0 - sy2)) * invDenom;\r\n  const b = ((dx1 - dx2) * (sx0 - sx2) - (dx0 - dx2) * (sx1 - sx2)) * invDenom;\r\n  const c = dx0 - a * sx0 - b * sy0;\r\n  \r\n  const d = ((dy0 - dy2) * (sy1 - sy2) - (dy1 - dy2) * (sy0 - sy2)) * invDenom;\r\n  const e = ((dy1 - dy2) * (sx0 - sx2) - (dy0 - dy2) * (sx1 - sx2)) * invDenom;\r\n  const f = dy0 - d * sx0 - e * sy0;\r\n  \r\n  ctx.save();\r\n  \r\n  // SEAM FIX: Robust Centroid-based Expansion\r\n  // We expand the clipping path by 1px in the direction of the triangle's center to ensure overlap.\r\n  const expand = 1.0; \r\n  const centerX = (dx0 + dx1 + dx2) / 3;\r\n  const centerY = (dy0 + dy1 + dy2) / 3;\r\n  \r\n  const grow = (x, y) => {\r\n    const vx = x - centerX;\r\n    const vy = y - centerY;\r\n    const len = Math.sqrt(vx * vx + vy * vy);\r\n    if (len < 1e-6) return { x, y };\r\n    return {\r\n      x: x + (vx / len) * expand,\r\n      y: y + (vy / len) * expand\r\n    };\r\n  };\r\n\r\n  const p0 = grow(dx0, dy0);\r\n  const p1 = grow(dx1, dy1);\r\n  const p2 = grow(dx2, dy2);\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(p0.x, p0.y);\r\n  ctx.lineTo(p1.x, p1.y);\r\n  ctx.lineTo(p2.x, p2.y);\r\n  ctx.closePath();\r\n  ctx.clip();\r\n  \r\n  ctx.setTransform(a, d, b, e, c, f);\r\n  ctx.drawImage(img, 0, 0);\r\n  ctx.restore();\r\n}\r\n\r\n\r\n/**\r\n * Extract document with manual corner points (no detection).\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} corners - Corner points object with topLeft, topRight, bottomRight, bottomLeft\r\n * @param {Object} options\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n * @returns {Promise<{output, corners, success, message}>}\r\n */\r\nexport async function extractDocument(image, corners, options = {}) {\r\n  const outputType = options.output || 'canvas';\r\n\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      success: false,\r\n      message: 'Invalid corner points provided'\r\n    };\r\n  }\r\n\r\n  try {\r\n    // Create result canvas and extract document\r\n    const resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, corners);\r\n\r\n    let output;\r\n    // Prepare output in requested format\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n\r\n    return {\r\n      output,\r\n      corners,\r\n      success: true,\r\n      message: 'Document extracted successfully'\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      output: null,\r\n      corners,\r\n      success: false,\r\n      message: `Extraction failed: ${error.message}`\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Main entry point for document scanning.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} options\r\n *   - mode: 'detect' | 'extract' (default: 'detect')\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n *   - debug: boolean\r\n *   - ...other detection options\r\n * @returns {Promise<{output, corners, contour, debug, success, message, timings}>}\r\n */\r\nexport async function scanDocument(image, options = {}) {\r\n  const timings = [];\r\n  const totalStart = performance.now();\r\n  \r\n  const mode = options.mode || 'detect';\r\n  const outputType = options.output || 'canvas';\r\n  const debug = !!options.debug;\r\n  const maxProcessingDimension = options.maxProcessingDimension || 800;\r\n\r\n  // Combined image preparation + downscaling + grayscale (OffscreenCanvas + CSS filter)\r\n  let t0 = performance.now();\r\n  const { grayscaleData, imageData, scaleFactor, originalDimensions, scaledDimensions } = \r\n    await prepareScaleAndGrayscale(image, maxProcessingDimension);\r\n  timings.push({ step: 'Image Prep + Scale + Gray', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  // Detect document (pass pre-computed grayscale data)\r\n  const detection = await detectDocumentInternal(\r\n    grayscaleData, \r\n    scaledDimensions.width, \r\n    scaledDimensions.height, \r\n    scaleFactor, \r\n    options\r\n  );\r\n  \r\n  // Merge detailed detection timings\r\n  if (detection.timings) {\r\n    detection.timings.forEach(t => timings.push(t));\r\n  }\r\n  \r\n  if (!detection.success) {\r\n    const totalEnd = performance.now();\r\n    timings.unshift({ step: 'Total', ms: (totalEnd - totalStart).toFixed(2) });\r\n    console.table(timings);\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      contour: null,\r\n      debug: detection.debug,\r\n      success: false,\r\n      message: detection.message || 'No document detected',\r\n      timings\r\n    };\r\n  }\r\n\r\n  let resultCanvas;\r\n  let output;\r\n\r\n  if (mode === 'detect') {\r\n    // Just return detection info, no image processing\r\n    output = null;\r\n  } else if (mode === 'extract') {\r\n    // Return only the cropped/warped document\r\n    t0 = performance.now();\r\n    resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, detection.corners);\r\n    timings.push({ step: 'Perspective Transform', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  // Prepare output in requested format (only if not detect mode)\r\n  if (mode !== 'detect' && resultCanvas) {\r\n    t0 = performance.now();\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n    timings.push({ step: 'Output Conversion', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  const totalEnd = performance.now();\r\n  timings.unshift({ step: 'Total', ms: (totalEnd - totalStart).toFixed(2) });\r\n  console.table(timings);\r\n\r\n  return {\r\n    output,\r\n    corners: detection.corners,\r\n    contour: detection.contour,\r\n    debug: detection.debug,\r\n    success: true,\r\n    message: 'Document detected',\r\n    timings\r\n  };\r\n}"],"names":["DEFAULTS","RETR_EXTERNAL","RETR_LIST","CHAIN_APPROX_SIMPLE","detectDocumentContour","edges","options","width","height","mode","method","minArea","paddedWidth","paddedHeight","labels","y","x","contours","nextContourId","currentPixelLabel","leftPixelLabel","startPoint","isOuter","initialDirection","contourId","points","traceContour","finalPoints","simplifyChainApproxSimple","adjustedPoints","p","contour","calculateContourArea","calculateBoundingBox","filteredContours","a","b","visited","currentX","currentY","startX","startY","prevDirection","count","maxSteps","dx","dy","searchDirection","found","i","nextX","nextY","checkDirection","checkX","checkY","visitedKey","nextIdx","n","simplifiedPoints","lastPoint","firstPoint","prevPoint","currentPoint","nextPoint","dx1","dy1","dx2","dy2","maxDistSq","farthestIdx","p0x","p0y","pi","distSq","area","j","minX","minY","maxX","maxY","point","simplifyContour","epsilon","maxDistance","index","distance","perpendicularDistance","firstSegment","secondSegment","lineStart","lineEnd","lineLengthSq","t","closestPointX","closestPointY","distDx","distDy","approximatePolygon","contourPoints","perimeter","calculateContourPerimeter","actualEpsilon","findCenter","sumX","sumY","findCornerPoints","approximation","corners","orderCornerPoints","findCornersByCoordinateExtremes","topLeft","topRight","bottomRight","bottomLeft","minSum","maxDiff","maxSum","minDiff","sum","diff","center","sortedPoints","angleA","angleB","minIndex","orderedPoints","wasm","cachedUint8ArrayMemory0","getUint8ArrayMemory0","WASM_VECTOR_LEN","passArray8ToWasm0","arg","malloc","ptr","getArrayU8FromWasm0","len","dilate","kernel_size","ptr0","len0","ret","v2","cachedFloat32ArrayMemory0","getFloat32ArrayMemory0","passArrayF32ToWasm0","hysteresis_thresholding","suppressed","low_threshold","high_threshold","blur","grayscale","sigma","cachedUint16ArrayMemory0","getUint16ArrayMemory0","passArray16ToWasm0","getArrayF32FromWasm0","non_maximum_suppression","l2_gradient","ptr1","len1","v3","__wbg_load","module","imports","e","bytes","instance","__wbg_get_imports","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","wasmReadyPromise","initializeWasm","init","convertToGrayscale","imageData","data","gaussianBlurGrayscale","kernelSize","halfKernel","kernel","createGaussianKernel","tempArray","blurred","rowOffset","k","xOffset","yOffset","size","halfSize","calculateGradients","prevRowOffset","nextRowOffset","currentIdx","p0","p1","p2","p3","p5","p6","p7","p8","gx","gy","nonMaximumSuppression","L2gradient","magnitude","idx","mag","neighbor1","neighbor2","absGx","absGy","s","hysteresisThresholding","lowThreshold","highThreshold","edgeMap","stack","dxNeighbors","dyNeighbors","nx","ny","nidx","dilateEdges","temp","dilated","maxVal","val","cannyEdgeDetector","input","timings","tStart","skipGrayscale","t0","t1","applyDilation","dilationKernelSize","useWasmHysteresis","wasmBlur","gradients","wasmMaximumSuppression","finalLowThreshold","finalHighThreshold","wasmHysteresis","cannyEdges","finalEdges","wasmDilate","tEnd","initialize","Scanner","image","combinedOptions","scanDocument","extractDocument","prepareScaleAndGrayscale","maxDimension","originalWidth","originalHeight","isImageData","maxCurrentDimension","targetWidth","targetHeight","scaleFactor","scale","useOffscreen","canvas","ctx","tempCanvas","grayscaleData","detectDocumentInternal","debugInfo","documentContour","cornerPoints","finalCorners","getPerspectiveTransform","srcPoints","dstPoints","buildMatrix","matrix","A","solve","m","M","row","B","maxRow","c","h","unwarpImage","widthA","widthB","maxWidth","heightA","heightB","maxHeight","perspectiveMatrix","warpTransform","invert3x3","d","f","g","C","D","E","F","G","H","I","det","outWidth","outHeight","srcWidth","srcHeight","inv","mapPoint","denom","gridX","gridY","cellW","cellH","srcCanvas","dx0","dy0","s00","s10","s01","s11","drawTexturedTriangle","img","sx0","sy0","sx1","sy1","sx2","sy2","invDenom","expand","centerX","centerY","grow","vx","vy","outputType","resultCanvas","output","error","totalStart","maxProcessingDimension","originalDimensions","scaledDimensions","detection","totalEnd"],"mappings":"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"}