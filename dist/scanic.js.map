{"version":3,"file":"scanic.js","sources":["../src/constants.js","../src/contourDetection.js","../src/cornerDetection.js","../wasm_blur/pkg/wasm_blur.js","../src/edgeDetection.js","../src/index.js"],"sourcesContent":["/**\r\n * Constants used throughout the library\r\n */\r\n\r\nexport const VERSION = '1.0.0';\r\n\r\nexport const DEFAULTS = {\r\n  // Edge detection params\r\n  GAUSSIAN_SIGMA: 1.1,\r\n  LOW_THRESHOLD: 50,\r\n  HIGH_THRESHOLD: 150,\r\n  \r\n  // Contour detection params\r\n  MIN_CONTOUR_AREA: 1000,\r\n  MIN_CONTOUR_POINTS: 10,\r\n  \r\n  // Debug options\r\n  DEBUG_OVERLAY_OPACITY: 0.7\r\n};","/**\r\n * Pure JavaScript implementation of contour detection algorithms\r\n * Based on Suzuki, S. and Abe, K. (1985). Topological structural analysis of digitized binary images by border following.\r\n * Replaces the previous flood-fill based connected components analysis.\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\n\r\n// Constants for different retrieval modes (subset of OpenCV)\r\nconst RETR_EXTERNAL = 0;\r\nconst RETR_LIST = 1;\r\n// Constants for different approximation methods (subset of OpenCV)\r\nconst CHAIN_APPROX_NONE = 1;\r\nconst CHAIN_APPROX_SIMPLE = 2;\r\n\r\n// Deltas for 8-connectivity neighborhood checks (0-7 clockwise from top)\r\n// Corresponds to OpenCV's chain code directions\r\nconst deltas = [\r\n  { dx:  0, dy: -1 }, // 0: Top\r\n  { dx:  1, dy: -1 }, // 1: Top-right\r\n  { dx:  1, dy:  0 }, // 2: Right\r\n  { dx:  1, dy:  1 }, // 3: Bottom-right\r\n  { dx:  0, dy:  1 }, // 4: Bottom\r\n  { dx: -1, dy:  1 }, // 5: Bottom-left\r\n  { dx: -1, dy:  0 }, // 6: Left\r\n  { dx: -1, dy: -1 }  // 7: Top-left\r\n];\r\n\r\n/**\r\n * Detects contours in a binary edge image using Suzuki's border following algorithm.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (pixels > 0 are foreground)\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.width] - Image width (required if not square)\r\n * @param {number} [options.height] - Image height (required if not square)\r\n * @param {number} [options.mode=RETR_LIST] - Contour retrieval mode (RETR_EXTERNAL or RETR_LIST)\r\n * @param {number} [options.method=CHAIN_APPROX_SIMPLE] - Contour approximation method (CHAIN_APPROX_NONE or CHAIN_APPROX_SIMPLE)\r\n * @param {number} [options.minArea=DEFAULTS.MIN_CONTOUR_AREA] - Minimum contour area filter (applied after detection)\r\n * @param {Object} [options.debug] - Optional debug object to store intermediate results\r\n * @returns {Array} Array of contours, each contour is an array of points {x, y}. Sorted by area (largest first).\r\n */\r\nexport function detectDocumentContour(edges, options = {}) {\r\n  const width = options.width || Math.sqrt(edges.length);\r\n  const height = options.height || edges.length / width;\r\n  const mode = options.mode !== undefined ? options.mode : RETR_LIST;\r\n  const method = options.method !== undefined ? options.method : CHAIN_APPROX_SIMPLE;\r\n  const minArea = options.minArea || DEFAULTS.MIN_CONTOUR_AREA;\r\n\r\n  // Create a padded label map to simplify boundary checks.\r\n  // 0: background\r\n  // 1: foreground (unlabeled)\r\n  // >= 2: contour ID (2, 3, ...)\r\n  const paddedWidth = width + 2;\r\n  const paddedHeight = height + 2;\r\n  const labels = new Int32Array(paddedWidth * paddedHeight); // Initialized to 0\r\n\r\n  // Copy edges data to the label map, mapping foreground pixels to 1\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (edges[y * width + x] > 0) {\r\n        labels[(y + 1) * paddedWidth + (x + 1)] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  const contours = [];\r\n  let nextContourId = 2; // Start labeling contours from 2\r\n\r\n  // Raster scan\r\n  for (let y = 1; y <= height; y++) {\r\n    for (let x = 1; x <= width; x++) {\r\n      const currentPixelLabel = labels[y * paddedWidth + x];\r\n      const leftPixelLabel = labels[y * paddedWidth + (x - 1)];\r\n\r\n      let startPoint = null;\r\n      let isOuter = false;\r\n      let initialDirection = -1;\r\n\r\n      if (currentPixelLabel === 1 && leftPixelLabel === 0) {\r\n        // Found the start of an outer contour boundary (NBD = 1 in Suzuki's terms)\r\n        isOuter = true;\r\n        startPoint = { x: x, y: y };\r\n        initialDirection = 2; // Start searching right\r\n        // if (options.debug) console.log(`Outer contour start at (${x-1}, ${y-1})`);\r\n      } else if (currentPixelLabel === 0 && leftPixelLabel >= 1 && leftPixelLabel !== -1) {\r\n         // Found the start of a hole contour boundary (NBD >= 2 in Suzuki's terms)\r\n         // Check if the left pixel is already part of a traced contour border\r\n         // If leftPixelLabel is > 1, it might be already traced. If it's 1, it's an unlabeled foreground pixel.\r\n         // We only start tracing if the left pixel is unlabeled foreground (1).\r\n         if (leftPixelLabel === 1) {\r\n             isOuter = false;\r\n             startPoint = { x: x - 1, y: y };\r\n             initialDirection = 6; // Start searching left\r\n            //  if (options.debug) console.log(`Hole contour start at (${x-1-1}, ${y-1})`);\r\n         }\r\n      }\r\n\r\n\r\n      if (startPoint) {\r\n        // If mode is RETR_EXTERNAL, only process outer contours\r\n        if (mode === RETR_EXTERNAL && !isOuter) {\r\n          // Mark the starting pixel of the hole so we don't process it again\r\n          // Use a special marker (-1) to distinguish from contour IDs\r\n           labels[startPoint.y * paddedWidth + startPoint.x] = -1;\r\n           continue;\r\n        }\r\n\r\n        const contourId = nextContourId++;\r\n        const points = traceContour(labels, paddedWidth, paddedHeight, startPoint, initialDirection, contourId);\r\n\r\n        if (points && points.length > 0) {\r\n            let finalPoints = points;\r\n            if (method === CHAIN_APPROX_SIMPLE) {\r\n                finalPoints = simplifyChainApproxSimple(points);\r\n            }\r\n\r\n            // Adjust points to original image coordinates (remove padding offset)\r\n            const adjustedPoints = finalPoints.map(p => ({ x: p.x - 1, y: p.y - 1 }));\r\n\r\n            if (adjustedPoints.length >= (method === CHAIN_APPROX_SIMPLE ? 4 : DEFAULTS.MIN_CONTOUR_POINTS)) { // Need at least 4 points for a simple polygon approx\r\n                const contour = {\r\n                    id: contourId,\r\n                    points: adjustedPoints,\r\n                    isOuter: isOuter,\r\n                    // Calculate area and bounding box later if needed for filtering/sorting\r\n                };\r\n                contours.push(contour);\r\n            }\r\n        } else {\r\n             // Handle single point contours or errors if necessary\r\n             // Mark the start point if trace failed or resulted in no points\r\n             if (labels[startPoint.y * paddedWidth + startPoint.x] === 1) {\r\n                 labels[startPoint.y * paddedWidth + startPoint.x] = contourId; // Mark as visited\r\n             }\r\n        }\r\n      } else if (currentPixelLabel >= 1 && leftPixelLabel >= 1 && currentPixelLabel !== leftPixelLabel) {\r\n          // Handle merging contours or complex topology if needed (not implemented for RETR_LIST/EXTERNAL)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Calculate area and bounding box for filtering and sorting\r\n  contours.forEach(contour => {\r\n    contour.area = calculateContourArea(contour.points);\r\n    contour.boundingBox = calculateBoundingBox(contour.points);\r\n  });\r\n\r\n  // Filter by minimum area\r\n  const filteredContours = contours.filter(contour => contour.area >= minArea);\r\n\r\n  // Sort contours by area (largest first)\r\n  filteredContours.sort((a, b) => b.area - a.area);\r\n\r\n  // console.log(`Found ${contours.length} contours before filtering, ${filteredContours.length} after filtering.`);\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.labels = labels; // Store the final label map\r\n    options.debug.rawContours = contours; // Store contours before filtering/sorting\r\n    options.debug.finalContours = filteredContours;\r\n    // console.log('Contour detection debug info stored');\r\n  }\r\n  return filteredContours // Return only the points array per contour\r\n}\r\n\r\n/**\r\n * Traces a contour boundary using border following.\r\n * Optimized to minimize object allocations.\r\n * @param {Int32Array} labels - The label map (modified during tracing)\r\n * @param {number} width - Padded width of the label map\r\n * @param {number} height - Padded height of the label map\r\n * @param {Object} startPoint - Starting point {x, y} in padded coordinates\r\n * @param {number} initialDirection - Initial search direction (0-7)\r\n * @param {number} contourId - The ID to label this contour with\r\n * @returns {Array} Array of points {x, y} in padded coordinates, or null if error\r\n */\r\nfunction traceContour(labels, width, height, startPoint, initialDirection, contourId) {\r\n    const points = [];\r\n    // Use Set with numeric keys (y * width + x) - much faster than string keys\r\n    const visited = new Set();\r\n    \r\n    // Avoid object creation in hot loop - use primitive coordinates\r\n    let currentX = startPoint.x;\r\n    let currentY = startPoint.y;\r\n    const startX = currentX;\r\n    const startY = currentY;\r\n    \r\n    let prevDirection = -1; // Store the direction from which we arrived at currentPoint\r\n\r\n    // Mark the starting pixel with the contour ID\r\n    labels[startY * width + startX] = contourId;\r\n\r\n    let count = 0; // Safety break\r\n    const maxSteps = width * height; // Max possible steps\r\n    \r\n    // Pre-extract delta values for faster access in hot loop\r\n    const dx = [0, 1, 1, 1, 0, -1, -1, -1];\r\n    const dy = [-1, -1, 0, 1, 1, 1, 0, -1];\r\n\r\n    while (count++ < maxSteps) {\r\n        // Determine the direction to start searching from (relative to the direction we came from)\r\n        // In Suzuki's paper, this is based on the chain code of the previous step.\r\n        // Simplified: Start searching from the direction after the one that led us here.\r\n        // If we arrived from direction `d`, the next pixel must be in `(d+1)%8` to `(d+7)%8`.\r\n        // Let's adapt OpenCV's logic: search starts from (prevDirection + 2) % 8 clockwise.\r\n        // If it's the first step, prevDirection is unknown, use initialDirection logic.\r\n\r\n        let searchDirection;\r\n        if (prevDirection === -1) {\r\n            // First step: Use initialDirection logic (e.g., start right for outer, left for inner)\r\n            // The initial search should find the *first* pixel of the contour boundary clockwise.\r\n            // Let's refine the initial search based on OpenCV's approach:\r\n            // Find the first non-zero pixel starting from `initialDirection` clockwise.\r\n            let found = false;\r\n            for (let i = 0; i < 8; i++) {\r\n                searchDirection = (initialDirection + i) & 7; // Faster than % 8\r\n                const nextX = currentX + dx[searchDirection];\r\n                const nextY = currentY + dy[searchDirection];\r\n                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && labels[nextY * width + nextX] > 0) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) return null; // Should not happen if startPoint is valid\r\n\r\n        } else {\r\n            // Subsequent steps: Start search from (prevDirection + 2) % 8 clockwise\r\n             searchDirection = (prevDirection + 2) & 7;\r\n        }\r\n\r\n\r\n        let nextX = -1;\r\n        let nextY = -1;\r\n        let nextDirection = -1;\r\n\r\n        // Search clockwise for the next boundary pixel\r\n        for (let i = 0; i < 8; i++) {\r\n            const checkDirection = (searchDirection + i) & 7;\r\n            const checkX = currentX + dx[checkDirection];\r\n            const checkY = currentY + dy[checkDirection];\r\n\r\n            // Check bounds (should be within padded area)\r\n            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {\r\n                if (labels[checkY * width + checkX] > 0) { // Found a foreground pixel (labeled or unlabeled)\r\n                    nextX = checkX;\r\n                    nextY = checkY;\r\n                    // The direction *from* currentPoint *to* nextPoint is checkDirection\r\n                    nextDirection = checkDirection;\r\n                    // The direction *from* which we will arrive *at* nextPoint is (checkDirection + 4) % 8\r\n                    prevDirection = (checkDirection + 4) & 7;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextX === -1) {\r\n            // Should not happen in a well-formed contour, maybe isolated pixel?\r\n             if (points.length === 0) { // If it's just the start point\r\n                 points.push({ x: currentX, y: currentY }); // Add the single point\r\n             }\r\n            console.warn(`Contour tracing stopped unexpectedly at (${currentX-1}, ${currentY-1}) for contour ${contourId}`);\r\n            break;\r\n        }\r\n\r\n        // Add the *current* point to the list before moving\r\n        // Use numeric key for Set (much faster than string concatenation)\r\n        const visitedKey = currentY * width + currentX;\r\n        if (visited.has(visitedKey)) {\r\n            // Duplicate point detected - return to avoid infinite loops\r\n            return points;\r\n        }\r\n        points.push({ x: currentX, y: currentY });\r\n        visited.add(visitedKey);\r\n\r\n        // Mark the next pixel if it's unlabeled\r\n        const nextIdx = nextY * width + nextX;\r\n        if (labels[nextIdx] === 1) {\r\n            labels[nextIdx] = contourId;\r\n        }\r\n\r\n        // Move to the next point\r\n        currentX = nextX;\r\n        currentY = nextY;\r\n\r\n        // Check if we returned to the start point\r\n        if (currentX === startX && currentY === startY) {\r\n            // Check if we came from the same direction as the initial step search ended.\r\n            // This is complex, let's use a simpler check: if we are back at start, we are done.\r\n            // OpenCV has more sophisticated checks involving i4 == i0 && i3 == i1.\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (count >= maxSteps) {\r\n        console.warn(`Contour tracing exceeded max steps for contour ${contourId}`);\r\n        return null; // Indicate potential error\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\n/**\r\n * Simplifies a contour polygon using CHAIN_APPROX_SIMPLE.\r\n * Removes intermediate points that lie on the straight line segment between their neighbors.\r\n * Optimized to avoid modulo operations in hot loop.\r\n * @param {Array} points - Array of contour points {x, y}\r\n * @returns {Array} Simplified array of points\r\n */\r\nfunction simplifyChainApproxSimple(points) {\r\n    const n = points.length;\r\n    if (n <= 2) {\r\n        return points;\r\n    }\r\n\r\n    const simplifiedPoints = [];\r\n    \r\n    // Cache first and last points for wrap-around\r\n    const lastPoint = points[n - 1];\r\n    const firstPoint = points[0];\r\n    \r\n    // Check first point (prev = last, next = second)\r\n    let prevPoint = lastPoint;\r\n    let currentPoint = firstPoint;\r\n    let nextPoint = points[1];\r\n    \r\n    let dx1 = currentPoint.x - prevPoint.x;\r\n    let dy1 = currentPoint.y - prevPoint.y;\r\n    let dx2 = nextPoint.x - currentPoint.x;\r\n    let dy2 = nextPoint.y - currentPoint.y;\r\n    \r\n    if (dx1 * dy2 !== dy1 * dx2) {\r\n        simplifiedPoints.push(currentPoint);\r\n    }\r\n    \r\n    // Middle points (no wrap-around needed)\r\n    for (let i = 1; i < n - 1; i++) {\r\n        prevPoint = points[i - 1];\r\n        currentPoint = points[i];\r\n        nextPoint = points[i + 1];\r\n\r\n        dx1 = currentPoint.x - prevPoint.x;\r\n        dy1 = currentPoint.y - prevPoint.y;\r\n        dx2 = nextPoint.x - currentPoint.x;\r\n        dy2 = nextPoint.y - currentPoint.y;\r\n\r\n        if (dx1 * dy2 !== dy1 * dx2) {\r\n            simplifiedPoints.push(currentPoint);\r\n        }\r\n    }\r\n    \r\n    // Check last point (prev = second-to-last, next = first)\r\n    prevPoint = points[n - 2];\r\n    currentPoint = lastPoint;\r\n    nextPoint = firstPoint;\r\n    \r\n    dx1 = currentPoint.x - prevPoint.x;\r\n    dy1 = currentPoint.y - prevPoint.y;\r\n    dx2 = nextPoint.x - currentPoint.x;\r\n    dy2 = nextPoint.y - currentPoint.y;\r\n    \r\n    if (dx1 * dy2 !== dy1 * dx2) {\r\n        simplifiedPoints.push(currentPoint);\r\n    }\r\n\r\n    // Handle cases where all points are collinear (e.g., straight line)\r\n    if (simplifiedPoints.length === 0) {\r\n         if (n === 1) return [points[0]];\r\n         if (n === 2) return points;\r\n\r\n         // Find the point most distant from the first point\r\n         let maxDistSq = 0;\r\n         let farthestIdx = 1;\r\n         const p0x = firstPoint.x;\r\n         const p0y = firstPoint.y;\r\n         for (let i = 1; i < n; i++) {\r\n             const pi = points[i];\r\n             const dx = pi.x - p0x;\r\n             const dy = pi.y - p0y;\r\n             const distSq = dx * dx + dy * dy;\r\n             if (distSq > maxDistSq) {\r\n                 maxDistSq = distSq;\r\n                 farthestIdx = i;\r\n             }\r\n         }\r\n         return [firstPoint, points[farthestIdx]];\r\n    }\r\n\r\n    return simplifiedPoints;\r\n}\r\n\r\n\r\n// --- Helper functions (keep or adapt from original) ---\r\n\r\n/**\r\n * Calculates the area of a contour using the shoelace formula\r\n * @param {Array} points - Array of point coordinates {x, y}\r\n * @returns {number} Contour area\r\n */\r\nfunction calculateContourArea(points) {\r\n  let area = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 3) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n;\r\n    area += points[i].x * points[j].y;\r\n    area -= points[j].x * points[i].y;\r\n  }\r\n\r\n  return Math.abs(area) / 2;\r\n}\r\n\r\n/**\r\n * Calculates the bounding box of a contour\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {Object} Bounding box with minX, minY, maxX, maxY properties\r\n */\r\nfunction calculateBoundingBox(points) {\r\n  if (points.length === 0) {\r\n      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n  }\r\n  let minX = points[0].x;\r\n  let minY = points[0].y;\r\n  let maxX = points[0].x;\r\n  let maxY = points[0].y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      minX = Math.min(minX, point.x);\r\n      minY = Math.min(minY, point.y);\r\n      maxX = Math.max(maxX, point.x);\r\n      maxY = Math.max(maxY, point.y);\r\n  }\r\n\r\n  return { minX, minY, maxX, maxY };\r\n}\r\n\r\n\r\n// --- Functions below are no longer directly used by detectDocumentContour ---\r\n// --- but might be useful elsewhere or can be removed ---\r\n\r\n/**\r\n * Simplifies a contour using the Ramer-Douglas-Peucker algorithm\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} points - Array of point coordinates\r\n * @param {number} epsilon - Epsilon value for simplification\r\n * @returns {Array} Simplified contour points\r\n */\r\nexport function simplifyContour(points, epsilon = 1.0) {\r\n  // ... (keep existing implementation if needed elsewhere) ...\r\n   if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Find point with the maximum distance\r\n  let maxDistance = 0;\r\n  let index = 0;\r\n\r\n  const firstPoint = points[0];\r\n  const lastPoint = points[points.length - 1];\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\r\n\r\n    if (distance > maxDistance) {\r\n      maxDistance = distance;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  // If max distance is greater than epsilon, recursively simplify\r\n  if (maxDistance > epsilon) {\r\n    // Recursive simplification\r\n    const firstSegment = simplifyContour(points.slice(0, index + 1), epsilon);\r\n    const secondSegment = simplifyContour(points.slice(index), epsilon);\r\n\r\n    // Concatenate the two segments\r\n    return firstSegment.slice(0, -1).concat(secondSegment);\r\n  } else {\r\n    // Return just the endpoints\r\n    return [firstPoint, lastPoint];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the perpendicular distance from a point to a line\r\n * (Helper for RDP simplifyContour, keep if that function is kept)\r\n * @param {Object} point - Point to measure from\r\n * @param {Object} lineStart - Start point of the line\r\n * @param {Object} lineEnd - End point of the line\r\n * @returns {number} Perpendicular distance\r\n */\r\nfunction perpendicularDistance(point, lineStart, lineEnd) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   const dx = lineEnd.x - lineStart.x;\r\n  const dy = lineEnd.y - lineStart.y;\r\n\r\n  // Line length squared\r\n  const lineLengthSq = dx * dx + dy * dy;\r\n\r\n  if (lineLengthSq === 0) {\r\n    // Point to point distance if the line has zero length\r\n    return Math.sqrt(\r\n      Math.pow(point.x - lineStart.x, 2) +\r\n      Math.pow(point.y - lineStart.y, 2)\r\n    );\r\n  }\r\n\r\n   // Calculate the projection parameter t\r\n  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq;\r\n\r\n  let closestPointX, closestPointY;\r\n\r\n  if (t < 0) {\r\n    closestPointX = lineStart.x;\r\n    closestPointY = lineStart.y;\r\n  } else if (t > 1) {\r\n    closestPointX = lineEnd.x;\r\n    closestPointY = lineEnd.y;\r\n  } else {\r\n    closestPointX = lineStart.x + t * dx;\r\n    closestPointY = lineStart.y + t * dy;\r\n  }\r\n\r\n  // Calculate the distance from the point to the closest point on the line segment\r\n  const distDx = point.x - closestPointX;\r\n  const distDy = point.y - closestPointY;\r\n  return Math.sqrt(distDx * distDx + distDy * distDy);\r\n\r\n  /* // Original implementation using area formula (distance to infinite line)\r\n  const lineLength = Math.sqrt(lineLengthSq);\r\n  const area = Math.abs(dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);\r\n  return area / lineLength;\r\n  */\r\n}\r\n\r\n/**\r\n * Creates a polygon approximation of a contour using RDP.\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} contourPoints - Array of points {x, y}\r\n * @param {number} epsilon - Epsilon for polygon approximation (relative to perimeter)\r\n * @returns {Array} Array of polygon points\r\n */\r\nexport function approximatePolygon(contourPoints, epsilon = 0.02) {\r\n  // Calculate contour perimeter\r\n  const perimeter = calculateContourPerimeter(contourPoints);\r\n\r\n  // Calculate epsilon based on perimeter\r\n  const actualEpsilon = epsilon * perimeter;\r\n\r\n  // Simplify the contour using RDP\r\n  const simplifiedPoints = simplifyContour(contourPoints, actualEpsilon);\r\n\r\n  return simplifiedPoints;\r\n}\r\n\r\n/**\r\n * Calculates the perimeter of a contour\r\n * (Helper for RDP approximatePolygon, keep if that function is kept)\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {number} Contour perimeter\r\n */\r\nfunction calculateContourPerimeter(points) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   let perimeter = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 2) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n; // Wrap around for the last segment\r\n    const dx = points[i].x - points[j].x;\r\n    const dy = points[i].y - points[j].y;\r\n    perimeter += Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\n// Flood fill is no longer used for contour detection\r\n/*\r\nfunction floodFill(edges, labels, width, height, startX, startY, label) {\r\n  // ... (original floodFill implementation removed) ...\r\n}\r\n*/","/**\r\n * Pure JavaScript implementation for detecting corners of a document\r\n * Replaces OpenCV's corner detection and point finding logic\r\n */\r\n\r\nimport { approximatePolygon } from './contourDetection.js';\r\n\r\n/**\r\n * Calculate distance between two points\r\n * @param {Object} p1 - First point {x, y}\r\n * @param {Object} p2 - Second point {x, y}\r\n * @returns {number} Distance between points\r\n */\r\nexport function distance(p1, p2) {\r\n  return Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n}\r\n\r\n/**\r\n * Find the center point of a contour\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Center point {x, y}\r\n */\r\nfunction findCenter(points) {\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  \r\n  for (const point of points) {\r\n    sumX += point.x;\r\n    sumY += point.y;\r\n  }\r\n  \r\n  return {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length\r\n  };\r\n}\r\n\r\n/**\r\n * Find the four corners of a document contour\r\n * @param {Object} contour - Contour object with points property\r\n * @param {Object} options - Configuration options\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nexport function findCornerPoints(contour, options = {}) {\r\n  if (!contour || !contour.points || contour.points.length < 4) {\r\n    console.warn('Contour does not have enough points for corner detection');\r\n    return null;\r\n  }\r\n  \r\n  // Try to find a quadrilateral approximation of the contour\r\n  const epsilon = options.epsilon || 0.02;\r\n  const approximation = approximatePolygon(contour, epsilon);\r\n  \r\n  let corners;\r\n  \r\n  // If we get exactly 4 points, we can use them as corners\r\n  if (approximation && approximation.length === 4) {\r\n    // console.log('Found 4-point approximation, using as corners');\r\n    corners = orderCornerPoints(approximation);\r\n  } else {\r\n    // console.log(`Polygon approximation gave ${approximation ? approximation.length : 'null'} points, using coordinate extremes method`);\r\n    // Fallback: Use the coordinate extremes method on the original contour points\r\n    corners = findCornersByCoordinateExtremes(contour.points); \r\n  }\r\n  \r\n  // Ensure all corners were found\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n      console.warn('Failed to find all four corners.', corners);\r\n      // Return null or partial corners? Returning null might be safer downstream.\r\n      return null; \r\n  }\r\n\r\n  return corners;\r\n}\r\n\r\n/**\r\n * Find corners by finding points with min/max coordinate sums/differences.\r\n * This is an alternative heuristic for finding corners.\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nfunction findCornersByCoordinateExtremes(points) {\r\n  if (!points || points.length === 0) return null;\r\n\r\n  let topLeft = points[0];      // Min sum x + y\r\n  let topRight = points[0];     // Max diff x - y\r\n  let bottomRight = points[0];  // Max sum x + y\r\n  let bottomLeft = points[0];   // Min diff x - y\r\n\r\n  let minSum = topLeft.x + topLeft.y;\r\n  let maxDiff = topRight.x - topRight.y;\r\n  let maxSum = bottomRight.x + bottomRight.y;\r\n  let minDiff = bottomLeft.x - bottomLeft.y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    const point = points[i];\r\n    const sum = point.x + point.y;\r\n    const diff = point.x - point.y;\r\n\r\n    // Top-Left (min sum)\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      topLeft = point;\r\n    }\r\n    // Bottom-Right (max sum)\r\n    if (sum > maxSum) {\r\n      maxSum = sum;\r\n      bottomRight = point;\r\n    }\r\n    // Top-Right (max diff)\r\n    if (diff > maxDiff) {\r\n      maxDiff = diff;\r\n      topRight = point;\r\n    }\r\n    // Bottom-Left (min diff)\r\n    if (diff < minDiff) {\r\n      minDiff = diff;\r\n      bottomLeft = point;\r\n    }\r\n  }\r\n\r\n  return {\r\n    topLeft,\r\n    topRight,\r\n    bottomRight,\r\n    bottomLeft\r\n  };\r\n}\r\n\r\n/**\r\n * Orders 4 points in clockwise order starting from top-left\r\n * @param {Array} points - Array of 4 points to order\r\n * @returns {Object} Object with ordered points\r\n */\r\nfunction orderCornerPoints(points) {\r\n  if (points.length !== 4) {\r\n    console.warn(`Expected 4 points, got ${points.length}`);\r\n    return null;\r\n  }\r\n  \r\n  // Calculate centroid\r\n  const center = findCenter(points);\r\n  \r\n  // Sort the points by their angles relative to the center\r\n  const sortedPoints = [...points].sort((a, b) => {\r\n    const angleA = Math.atan2(a.y - center.y, a.x - center.x);\r\n    const angleB = Math.atan2(b.y - center.y, b.x - center.x);\r\n    return angleA - angleB;\r\n  });\r\n  \r\n  // Now find the top-left point (minimum sum of x and y)\r\n  let minSum = Infinity;\r\n  let minIndex = 0;\r\n  \r\n  for (let i = 0; i < 4; i++) {\r\n    const sum = sortedPoints[i].x + sortedPoints[i].y;\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      minIndex = i;\r\n    }\r\n  }\r\n  \r\n  // Reorder array to start with the top-left point\r\n  const orderedPoints = [\r\n    sortedPoints[minIndex],\r\n    sortedPoints[(minIndex + 1) % 4],\r\n    sortedPoints[(minIndex + 2) % 4],\r\n    sortedPoints[(minIndex + 3) % 4]\r\n  ];\r\n  \r\n  // Return as named corners\r\n  return {\r\n    topLeft: orderedPoints[0],\r\n    topRight: orderedPoints[1],\r\n    bottomRight: orderedPoints[2],\r\n    bottomLeft: orderedPoints[3]\r\n  };\r\n}","let wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @returns {Uint8Array}\n */\nexport function dilate(edges, width, height, kernel_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate(ptr0, len0, width, height, kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @param {number} kernel_size\n * @param {number} sigma\n * @param {boolean} l2_gradient\n * @param {boolean} apply_dilation\n * @param {number} dilation_kernel_size\n * @returns {Uint8Array}\n */\nexport function canny_edge_detector_full(grayscale, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.canny_edge_detector_full(ptr0, len0, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Applies double thresholding and hysteresis using a stack-based approach.\n * Optimized version with SIMD for threshold comparisons and better memory access patterns.\n * Follows OpenCV's logic more closely.\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Edge map as Vec<u8> (0: weak edge/potential, 1: non-edge, 2: strong edge)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Creates a binary edge image from the hysteresis edge map\n * SIMD-optimized version for converting edge map to binary\n *\n * # Arguments\n * * `edge_map` - Edge map from hysteresis thresholding (0, 1, 2 values)\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Uint8Array} edge_map\n * @returns {Uint8Array}\n */\nexport function edge_map_to_binary(edge_map) {\n    const ptr0 = passArray8ToWasm0(edge_map, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_map_to_binary(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined hysteresis thresholding and binary conversion\n * This is a convenience function that combines both steps for efficiency\n * Optimized to avoid intermediate allocations where possible\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding_binary(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding_binary(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function blur(grayscale, width, height, kernel_size, sigma) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.blur(ptr0, len0, width, height, kernel_size, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint16ArrayMemory0 = null;\n\nfunction getUint16ArrayMemory0() {\n    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {\n        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16ArrayMemory0;\n}\n\nfunction passArray16ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 2, 2) >>> 0;\n    getUint16ArrayMemory0().set(arg, ptr / 2);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * @param {Int16Array} dx\n * @param {Int16Array} dy\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_gradient\n * @returns {Float32Array}\n */\nexport function non_maximum_suppression(dx, dy, width, height, l2_gradient) {\n    const ptr0 = passArray16ToWasm0(dx, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(dy, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.non_maximum_suppression(ptr0, len0, ptr1, len1, width, height, l2_gradient);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\nlet cachedInt16ArrayMemory0 = null;\n\nfunction getInt16ArrayMemory0() {\n    if (cachedInt16ArrayMemory0 === null || cachedInt16ArrayMemory0.byteLength === 0) {\n        cachedInt16ArrayMemory0 = new Int16Array(wasm.memory.buffer);\n    }\n    return cachedInt16ArrayMemory0;\n}\n\nfunction getArrayI16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n/**\n * @param {Uint8Array} blurred\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function calculate_gradients(blurred, width, height) {\n    const ptr0 = passArray8ToWasm0(blurred, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_gradients(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat32ArrayMemory0 = null;\n    cachedInt16ArrayMemory0 = null;\n    cachedUint16ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('wasm_blur_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","/**\r\n * Pure JavaScript implementation of edge detection algorithms\r\n * Inspired by OpenCV's Canny edge detector\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport init, { \r\n  blur as wasmBlur, \r\n  calculate_gradients as wasmGradients, \r\n  dilate as wasmDilate, \r\n  non_maximum_suppression as wasmMaximumSuppression, \r\n  canny_edge_detector_full as wasmFullCanny,\r\n  hysteresis_thresholding as wasmHysteresis,\r\n  hysteresis_thresholding_binary as wasmHysteresisBinary\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize the wasm module\r\nlet wasmReadyPromise = null;\r\n\r\n/**\r\n * Initializes the WASM module if not already initialized\r\n * @returns {Promise}\r\n */\r\nexport function initializeWasm() {\r\n  if (!wasmReadyPromise) {\r\n    wasmReadyPromise = init();\r\n  }\r\n  return wasmReadyPromise;\r\n}\r\n\r\n/**\r\n * Converts ImageData to grayscale (separate from blur for consistency with jscanify)\r\n * @param {ImageData} imageData - Original image data\r\n * @returns {Uint8ClampedArray} Grayscale image data (1 channel)\r\n */\r\nexport function convertToGrayscale(imageData) {\r\n  const { width, height, data } = imageData;\r\n  const grayscale = new Uint8ClampedArray(width * height);\r\n  \r\n  // Convert to grayscale with integer math (faster than floating point)\r\n  // Use bit shifting for multiplication (>>8 is equivalent to /256)\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    // 54 (~0.2126*256), 183 (~0.7152*256), 19 (~0.0722*256)\r\n    grayscale[j] = (data[i] * 54 + data[i+1] * 183 + data[i+2] * 19) >> 8;\r\n  }\r\n  \r\n  return grayscale;\r\n}\r\n\r\n/**\r\n * Applies Gaussian blur to a grayscale image (matching jscanify's approach)\r\n * @param {Uint8ClampedArray} grayscale - Grayscale image data\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (should be 5 to match jscanify)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data\r\n */\r\nexport function gaussianBlurGrayscale(grayscale, width, height, kernelSize = 5, sigma = 0) {\r\n  // If sigma is 0, calculate it from kernel size (OpenCV default)\r\n  if (sigma === 0) {\r\n    sigma = 0.3 * ((kernelSize - 1) * 0.5 - 1) + 0.8;\r\n  }\r\n  \r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  \r\n  // Create and normalize Gaussian kernel once\r\n  const kernel = createGaussianKernel(kernelSize, sigma);\r\n  \r\n  // Preallocate arrays\r\n  const tempArray = new Uint8ClampedArray(width * height);\r\n  const blurred = new Uint8ClampedArray(width * height);\r\n  \r\n  // Horizontal pass - process rows in a single loop to improve cache locality\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel horizontally with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const xOffset = Math.min(width - 1, Math.max(0, x + k));\r\n        sum += grayscale[rowOffset + xOffset] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      tempArray[rowOffset + x] = sum;\r\n    }\r\n  }\r\n  \r\n  // Vertical pass - process columns with better memory access pattern\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel vertically with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const yOffset = Math.min(height - 1, Math.max(0, y + k));\r\n        sum += tempArray[yOffset * width + x] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      blurred[y * width + x] = Math.round(sum);\r\n    }\r\n  }\r\n  \r\n  return blurred;\r\n}\r\n\r\n/**\r\n * Legacy wrapper for backwards compatibility\r\n * @param {ImageData} imageData - Original image data\r\n * @param {number} sigma - Gaussian sigma parameter (standard deviation)\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data (1 channel)\r\n */\r\nexport function gaussianBlur(imageData, sigma = DEFAULTS.GAUSSIAN_SIGMA, forcedKernelSize = null) {\r\n  const grayscale = convertToGrayscale(imageData);\r\n  const kernelSize = forcedKernelSize || 5; // Default to 5 like jscanify\r\n  return gaussianBlurGrayscale(grayscale, imageData.width, imageData.height, kernelSize, sigma);\r\n}\r\n\r\n/**\r\n * Creates a 1D Gaussian kernel\r\n * @param {number} size - Kernel size (odd number)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Float32Array} Gaussian kernel\r\n */\r\nfunction createGaussianKernel(size, sigma) {\r\n  const kernel = new Float32Array(size);\r\n  const halfSize = Math.floor(size / 2);\r\n  \r\n  let sum = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const x = i - halfSize;\r\n    // Gaussian function: (1/(sigma*sqrt(2*PI))) * e^(-(x^2)/(2*sigma^2))\r\n    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));\r\n    sum += kernel[i];\r\n  }\r\n  \r\n  // Normalize kernel\r\n  for (let i = 0; i < size; i++) {\r\n    kernel[i] /= sum;\r\n  }\r\n  \r\n  return kernel;\r\n}\r\n\r\n/**\r\n * Calculates the gradients (dx, dy) using Sobel operators\r\n * @param {Uint8ClampedArray} blurred - Blurred grayscale image\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @returns {{dx: Int16Array, dy: Int16Array}} Object containing gradient arrays\r\n */\r\nfunction calculateGradients(blurred, width, height) {\r\n  // Use Int16Array to store gradients, allowing negative values\r\n  const dx = new Int16Array(width * height);\r\n  const dy = new Int16Array(width * height);\r\n  \r\n  // Find gradients by unrolling the Sobel operator loops\r\n  for (let y = 1; y < height - 1; y++) {\r\n    const rowOffset = y * width;\r\n    const prevRowOffset = (y - 1) * width;\r\n    const nextRowOffset = (y + 1) * width;\r\n\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const currentIdx = rowOffset + x;\r\n\r\n      // Get neighborhood pixels\r\n      const p0 = blurred[prevRowOffset + x - 1];\r\n      const p1 = blurred[prevRowOffset + x];\r\n      const p2 = blurred[prevRowOffset + x + 1];\r\n      const p3 = blurred[rowOffset + x - 1];\r\n      const p5 = blurred[rowOffset + x + 1];\r\n      const p6 = blurred[nextRowOffset + x - 1];\r\n      const p7 = blurred[nextRowOffset + x];\r\n      const p8 = blurred[nextRowOffset + x + 1];\r\n      \r\n      // Calculate Sobel gradients\r\n      const gx = (p2 - p0) + 2 * (p5 - p3) + (p8 - p6);\r\n      const gy = (p6 + 2 * p7 + p8) - (p0 + 2 * p1 + p2);\r\n      \r\n      dx[currentIdx] = gx;\r\n      dy[currentIdx] = gy;\r\n    }\r\n  }\r\n  \r\n  return { dx, dy };\r\n}\r\n\r\n\r\n/**\r\n * Applies non-maximum suppression to the gradient magnitude\r\n * @param {Int16Array} dx - Gradient in x-direction\r\n * @param {Int16Array} dy - Gradient in y-direction\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {boolean} L2gradient - Whether to use L2 norm for magnitude\r\n * @returns {Float32Array} Suppressed magnitude (using Float32 for precision)\r\n */\r\nfunction nonMaximumSuppression(dx, dy, width, height, L2gradient) {\r\n  // Use Float32Array for magnitude to preserve precision before thresholding\r\n  const magnitude = new Float32Array(width * height);\r\n  const suppressed = new Float32Array(width * height);\r\n  \r\n  // Calculate magnitude for all pixels first\r\n  for (let i = 0; i < dx.length; i++) {\r\n    const gx = dx[i];\r\n    const gy = dy[i];\r\n    if (L2gradient) {\r\n      magnitude[i] = Math.sqrt(gx * gx + gy * gy);\r\n    } else {\r\n      magnitude[i] = Math.abs(gx) + Math.abs(gy); // L1 norm\r\n    }\r\n  }\r\n  \r\n  // Perform non-maximum suppression\r\n  for (let y = 1; y < height - 1; y++) {\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = magnitude[idx];\r\n      \r\n      // Skip pixels with zero magnitude\r\n      if (mag === 0) {\r\n        suppressed[idx] = 0;\r\n        continue;\r\n      }\r\n      \r\n      const gx = dx[idx];\r\n      const gy = dy[idx];\r\n      \r\n      let neighbor1 = 0, neighbor2 = 0;\r\n      \r\n      // Determine neighbors based on gradient direction\r\n      // Use absolute values to determine dominant direction\r\n      const absGx = Math.abs(gx);\r\n      const absGy = Math.abs(gy);\r\n      \r\n      if (absGy > absGx * 2.4142) { // Vertical edge (angle near 90 or 270)\r\n        neighbor1 = magnitude[idx - width]; // top\r\n        neighbor2 = magnitude[idx + width]; // bottom\r\n      } else if (absGx > absGy * 2.4142) { // Horizontal edge (angle near 0 or 180)\r\n        neighbor1 = magnitude[idx - 1]; // left\r\n        neighbor2 = magnitude[idx + 1]; // right\r\n      } else { // Diagonal edge\r\n        // Determine diagonal direction based on signs of gx and gy\r\n        const s = (gx ^ gy) < 0 ? -1 : 1; // Check if signs are different\r\n        if (gy > 0) { // Gradient points down\r\n          neighbor1 = magnitude[(y - 1) * width + (x - s)]; // top-left/right\r\n          neighbor2 = magnitude[(y + 1) * width + (x + s)]; // bottom-right/left\r\n        } else { // Gradient points up\r\n          neighbor1 = magnitude[(y + 1) * width + (x - s)]; // bottom-left/right\r\n          neighbor2 = magnitude[(y - 1) * width + (x + s)]; // top-right/left\r\n        }\r\n        // Refined diagonal check (approximating OpenCV's logic)\r\n        // Check 45 degrees (top-right / bottom-left)\r\n        if ((gx > 0 && gy > 0) || (gx < 0 && gy < 0)) { // Quadrants 1 & 3\r\n             neighbor1 = magnitude[(y - 1) * width + (x + 1)]; // top-right\r\n             neighbor2 = magnitude[(y + 1) * width + (x - 1)]; // bottom-left\r\n        } else { // Quadrants 2 & 4 (135 degrees)\r\n             neighbor1 = magnitude[(y - 1) * width + (x - 1)]; // top-left\r\n             neighbor2 = magnitude[(y + 1) * width + (x + 1)]; // bottom-right\r\n        }\r\n      }\r\n      \r\n      // If the pixel's magnitude is greater than or equal to its neighbors\r\n      // along the gradient direction, keep it. Otherwise, suppress it.\r\n      if (mag >= neighbor1 && mag >= neighbor2) {\r\n        suppressed[idx] = mag;\r\n      } else {\r\n        suppressed[idx] = 0;\r\n      }\r\n    }\r\n  }\r\n  return suppressed;\r\n}\r\n\r\n\r\n/**\r\n * Applies double thresholding and hysteresis using a stack-based approach.\r\n * Follows OpenCV's logic more closely.\r\n * @param {Float32Array} suppressed - Suppressed magnitude (Float32Array)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} lowThreshold - Low threshold value\r\n * @param {number} highThreshold - High threshold value\r\n * @returns {Uint8Array} Edge map (0: non-edge, 2: edge pixel)\r\n */\r\nfunction hysteresisThresholding(suppressed, width, height, lowThreshold, highThreshold) {\r\n  // Map values: 0 = weak edge (potential), 1 = non-edge, 2 = strong edge\r\n  const edgeMap = new Uint8Array(width * height);\r\n  const stack = [];\r\n  \r\n  // First pass: Identify strong edges and potential weak edges\r\n  for (let y = 1; y < height - 1; y++) { // Iterate excluding borders\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = suppressed[idx];\r\n      \r\n      if (mag >= highThreshold) {\r\n        // Strong edge pixel\r\n        edgeMap[idx] = 2;\r\n        stack.push({ x, y });\r\n      } else if (mag >= lowThreshold) {\r\n        // Weak edge pixel (potential edge)\r\n        edgeMap[idx] = 0; // Mark as potential\r\n      } else {\r\n        // Non-edge pixel\r\n        edgeMap[idx] = 1; // Mark as non-edge\r\n      }\r\n    }\r\n  }\r\n  // Initialize borders as non-edge (value 1)\r\n   for (let x = 0; x < width; x++) {\r\n       edgeMap[x] = 1; // Top row\r\n       edgeMap[(height - 1) * width + x] = 1; // Bottom row\r\n   }\r\n   for (let y = 1; y < height - 1; y++) {\r\n       edgeMap[y * width] = 1; // Left column\r\n       edgeMap[y * width + width - 1] = 1; // Right column\r\n   }\r\n\r\n\r\n  // Second pass: Hysteresis - connect weak edges to strong edges\r\n  const dxNeighbors = [-1, 0, 1, -1, 1, -1, 0, 1];\r\n  const dyNeighbors = [-1, -1, -1, 0, 0, 1, 1, 1];\r\n  \r\n  while (stack.length > 0) {\r\n    const { x, y } = stack.pop();\r\n    \r\n    // Check all 8 neighbors\r\n    for (let i = 0; i < 8; i++) {\r\n      const nx = x + dxNeighbors[i];\r\n      const ny = y + dyNeighbors[i];\r\n      const nidx = ny * width + nx;\r\n      \r\n      // Check bounds (already handled by border initialization)\r\n      // If neighbor is a weak edge (value 0), promote it to strong (value 2) and add to stack\r\n      if (edgeMap[nidx] === 0) {\r\n        edgeMap[nidx] = 2; // Promote to strong edge\r\n        stack.push({ x: nx, y: ny });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Note: Pixels that were initially weak (0) but not connected remain 0.\r\n  // Pixels below lowThreshold remain 1. Only pixels marked 2 are considered final edges.\r\n  \r\n  return edgeMap; // Return the map with 0, 1, 2 values\r\n}\r\n\r\n/**\r\n * Applies morphological dilation to binary image using a separable (two-pass) approach.\r\n * This is much faster than a 2D kernel for square structuring elements.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (0 or 255)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (default 5 to match jscanify)\r\n * @returns {Uint8ClampedArray} Dilated edge image\r\n */\r\nexport function dilateEdges(edges, width, height, kernelSize = 5) {\r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  const temp = new Uint8ClampedArray(width * height);\r\n  const dilated = new Uint8ClampedArray(width * height);\r\n\r\n  // Horizontal pass\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    for (let x = 0; x < width; x++) {\r\n      let maxVal = 0;\r\n      // Find max in horizontal neighborhood\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const nx = x + k;\r\n        if (nx >= 0 && nx < width) {\r\n          const val = edges[rowOffset + nx];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      temp[rowOffset + x] = maxVal;\r\n    }\r\n  }\r\n\r\n  // Vertical pass\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let maxVal = 0;\r\n      // Find max in vertical neighborhood from temp array\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const ny = y + k;\r\n        if (ny >= 0 && ny < height) {\r\n          const val = temp[ny * width + x];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      dilated[y * width + x] = maxVal;\r\n    }\r\n  }\r\n  \r\n  return dilated;\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation matching jscanify's approach\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.lowThreshold=75] - Low threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.highThreshold=200] - High threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.sigma=0] - Gaussian blur sigma (0 means auto-calculate from kernel size)\r\n * @param {number} [options.kernelSize=5] - Gaussian kernel size (matching jscanify)\r\n * @param {boolean} [options.L2gradient=false] - Use L2 norm for gradient magnitude (like OpenCV default)\r\n * @param {boolean} [options.applyDilation=true] - Apply dilation after Canny (matching jscanify)\r\n * @param {number} [options.dilationKernelSize=5] - Dilation kernel size\r\n * @param {boolean} [options.useWasmBlur=false] - Use WASM for Gaussian blur\r\n * @param {boolean} [options.useWasmGradients=false] - Use WASM for gradient calculation\r\n * @param {boolean} [options.useWasmDilation=false] - Use WASM for dilation\r\n * @param {boolean} [options.useWasmNMS=false] - Use WASM for non-maximum suppression\r\n * @param {boolean} [options.useWasmHysteresis=false] - Use WASM for hysteresis thresholding\r\n * @param {boolean} [options.useWasmFullCanny=false] - Use the full WASM Canny implementation\r\n * @param {object} [options.debug={}] - Object to store intermediate results if provided\r\n * @param {boolean} [options.skipGrayscale=false] - Skip grayscale conversion (input is already grayscale Uint8ClampedArray)\r\n * @param {number} [options.width] - Image width (required if skipGrayscale is true)\r\n * @param {number} [options.height] - Image height (required if skipGrayscale is true)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetector(input, options = {}) {\r\n  // Timing table setup\r\n  const timings = [];\r\n  const tStart = performance.now();\r\n\r\n  // Handle both ImageData and pre-computed grayscale Uint8ClampedArray\r\n  const skipGrayscale = options.skipGrayscale || false;\r\n  let width, height, grayscale;\r\n  \r\n  if (skipGrayscale) {\r\n    // Input is already grayscale Uint8ClampedArray\r\n    width = options.width;\r\n    height = options.height;\r\n    grayscale = input;\r\n    if (options.debug) options.debug.grayscale = grayscale;\r\n  } else {\r\n    // Input is ImageData - extract dimensions and convert to grayscale\r\n    width = input.width;\r\n    height = input.height;\r\n    \r\n    let t0 = performance.now();\r\n    grayscale = convertToGrayscale(input);\r\n    let t1 = performance.now();\r\n    timings.push({ step: 'Grayscale', ms: (t1 - t0).toFixed(2) });\r\n    if (options.debug) options.debug.grayscale = grayscale;\r\n  }\r\n\r\n  let lowThreshold = options.lowThreshold !== undefined ? options.lowThreshold : 75;\r\n  let highThreshold = options.highThreshold !== undefined ? options.highThreshold : 200;\r\n  const kernelSize = options.kernelSize || 5; // Match jscanify's 5x5 kernel\r\n  const sigma = options.sigma || 0; // Let the blur function calculate sigma\r\n  const L2gradient = options.L2gradient === undefined ? false : options.L2gradient;\r\n  const applyDilation = options.applyDilation !== undefined ? options.applyDilation : true;\r\n  const dilationKernelSize = options.dilationKernelSize || 5;\r\n  const useWasmBlur = true;\r\n  const useWasmGradients = false; \r\n  const useWasmDilation = true;\r\n  const useWasmNMS = true;\r\n  const useWasmHysteresis = options.useWasmHysteresis !== undefined ? options.useWasmHysteresis : false;\r\n  const useWasmFullCanny = false;\r\n\r\n  // Ensure high threshold is greater than low threshold\r\n  if (lowThreshold >= highThreshold) {\r\n      console.warn(`Canny Edge Detector: lowThreshold (${lowThreshold}) should be lower than highThreshold (${highThreshold}). Swapping them.`);\r\n      [lowThreshold, highThreshold] = [highThreshold, lowThreshold];\r\n  }\r\n\r\n  // Timing variables\r\n  let t0, t1;\r\n\r\n  // Step 2: Apply Gaussian blur (JS or WASM)\r\n  let blurred;\r\n  t0 = performance.now();\r\n  if (useWasmBlur) {\r\n    try {\r\n      await initializeWasm(); // Ensure wasm is initialized\r\n      blurred = wasmBlur(grayscale, width, height, kernelSize, sigma);\r\n    } catch (e) {\r\n      blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n    }\r\n  } else {\r\n    blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gaussian Blur', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) {\r\n    options.debug.blurred = blurred;\r\n  }\r\n\r\n  // Step 3: Compute gradients (dx, dy)\r\n  t0 = performance.now();\r\n  let dx, dy;\r\n  if (useWasmGradients) {\r\n    try {\r\n      await initializeWasm(); // Ensure wasm is initialized\r\n      const gradientResult = wasmGradients(blurred, width, height);\r\n      dx = new Int16Array(gradientResult.gx);\r\n      dy = new Int16Array(gradientResult.gy);\r\n    } catch (e) {\r\n      const gradients = calculateGradients(blurred, width, height);\r\n      dx = gradients.dx;\r\n      dy = gradients.dy;\r\n    }\r\n  } else {\r\n    const gradients = calculateGradients(blurred, width, height);\r\n    dx = gradients.dx;\r\n    dy = gradients.dy;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gradients', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 4: Apply non-maximum suppression\r\n  t0 = performance.now();\r\n  let suppressed;\r\n  if (useWasmNMS) {\r\n    try {\r\n      await initializeWasm();\r\n      suppressed = await wasmMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    } catch (e) {\r\n      suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    }\r\n  } else {\r\n    suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Non-Max Suppression', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 5: Apply double thresholding and hysteresis\r\n  t0 = performance.now();\r\n  const finalLowThreshold = L2gradient ? lowThreshold * lowThreshold : lowThreshold;\r\n  const finalHighThreshold = L2gradient ? highThreshold * highThreshold : highThreshold;\r\n  \r\n  let edgeMap;\r\n  if (useWasmHysteresis) {\r\n    try {\r\n      await initializeWasm();\r\n      edgeMap = wasmHysteresis(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    } catch (e) {\r\n      console.warn(\"WASM hysteresis failed, falling back to JS:\", e);\r\n      edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    }\r\n  } else {\r\n    edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n  }\r\n  \r\n  t1 = performance.now();\r\n  timings.push({ step: 'Hysteresis', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 6: Create binary image (0 or 255)\r\n  t0 = performance.now();\r\n  const cannyEdges = new Uint8ClampedArray(width * height);\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    cannyEdges[i] = edgeMap[i] === 2 ? 255 : 0;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Binary Image', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 7: Apply dilation if requested (matching jscanify)\r\n  t0 = performance.now();\r\n  let finalEdges = cannyEdges;\r\n  if (applyDilation) {\r\n    if (useWasmDilation) {\r\n      try {\r\n        await initializeWasm(); // Ensure wasm is initialized\r\n        finalEdges = wasmDilate(cannyEdges, width, height, dilationKernelSize);\r\n      } catch (e) {\r\n        finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n      }\r\n    } else {\r\n      finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n    }\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Dilation', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.dx = dx; // Int16Array\r\n    options.debug.dy = dy; // Int16Array\r\n    // Calculate magnitude separately for debugging if needed\r\n     const magnitude = new Float32Array(width * height);\r\n     for (let i = 0; i < dx.length; i++) {\r\n         const gx = dx[i]; const gy = dy[i];\r\n         magnitude[i] = L2gradient ? Math.sqrt(gx * gx + gy * gy) : Math.abs(gx) + Math.abs(gy);\r\n     }\r\n     options.debug.magnitude = magnitude; // Float32Array (raw magnitude)\r\n    options.debug.suppressed = suppressed; // Float32Array (after NMS)\r\n    options.debug.edgeMap = edgeMap; // Uint8Array (0, 1, 2 values from hysteresis)\r\n    options.debug.cannyEdges = cannyEdges; // Uint8ClampedArray (0 or 255, before dilation)\r\n    options.debug.finalEdges = finalEdges; // Uint8ClampedArray (0 or 255, after dilation if applied)\r\n  }\r\n  \r\n  // Always store timings in debug object (create minimal one if needed)\r\n  if (options.debug) {\r\n    options.debug.timings = timings;\r\n  } else if (!options.debug) {\r\n    // Create a minimal debug object just for timings if none provided\r\n    options.debug = { timings: timings };\r\n  }\r\n\r\n  const tEnd = performance.now();\r\n  timings.unshift({ step: 'Edge Detection Total', ms: (tEnd - tStart).toFixed(2) });\r\n  // Timings available via options.debug.timings\r\n\r\n  return finalEdges; // Return the final binary edge image\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation using WASM, for comparison or direct use\r\n * This function is intended to match the performance and output of the JS cannyEdgeDetector,\r\n * but runs entirely in WASM for potentially faster execution.\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options (same as cannyEdgeDetector)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetectorWasm(imageData, options = {}) {\r\n  // Directly call the WASM canny_edge_detector_full function\r\n  let result;\r\n  try {\r\n    await initializeWasm(); // Ensure wasm is initialized\r\n    console.log('Using WASM Full Canny');\r\n    result = wasmFullCanny(imageData.data, imageData.width, imageData.height, options.lowThreshold, options.highThreshold, options.sigma, options.kernelSize, options.L2gradient, options.applyDilation, options.dilationKernelSize);\r\n  } catch (e) {\r\n    console.error(\"WASM full Canny failed:\", e);\r\n    throw e; // Rethrow to let the caller handle the error\r\n  }\r\n  \r\n  // Convert result to Uint8ClampedArray (if not already)\r\n  const edges = new Uint8ClampedArray(result);\r\n  \r\n  return edges;\r\n}","/**\r\n * scanic\r\n * JavaScript document scanner without OpenCV dependency\r\n * MIT License\r\n */\r\n\r\n\r\nimport { detectDocumentContour } from './contourDetection.js';\r\nimport { findCornerPoints } from './cornerDetection.js';\r\nimport { cannyEdgeDetector, initializeWasm } from './edgeDetection.js';\r\n\r\n/**\r\n * Global initialization helper for convenience.\r\n */\r\nexport async function initialize() {\r\n  return await initializeWasm();\r\n}\r\n\r\n/**\r\n * Unified Scanner class for better state and configuration management.\r\n */\r\nexport class Scanner {\r\n  constructor(options = {}) {\r\n    this.defaultOptions = {\r\n      maxProcessingDimension: 800,\r\n      mode: 'detect',\r\n      output: 'canvas',\r\n      ...options\r\n    };\r\n    this.initialized = false;\r\n  }\r\n\r\n  /**\r\n   * Warm up the scanner (load WASM, etc.)\r\n   */\r\n  async initialize() {\r\n    if (this.initialized) return;\r\n    await initializeWasm();\r\n    this.initialized = true;\r\n  }\r\n\r\n  /**\r\n   * Scan an image for a document.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image \r\n   * @param {Object} options Override default options\r\n   */\r\n  async scan(image, options = {}) {\r\n    if (!this.initialized) await this.initialize();\r\n    const combinedOptions = { ...this.defaultOptions, ...options };\r\n    return await scanDocument(image, combinedOptions);\r\n  }\r\n\r\n  /**\r\n   * Extract a document from an image using manual corners.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image \r\n   * @param {Object} corners \r\n   * @param {Object} options \r\n   */\r\n  async extract(image, corners, options = {}) {\r\n    if (!this.initialized) await this.initialize();\r\n    const combinedOptions = { ...this.defaultOptions, ...options };\r\n    return await extractDocument(image, corners, combinedOptions);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Prepares image, downscales, and converts to grayscale in a single operation.\r\n * Uses OffscreenCanvas and CSS filters for maximum performance.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image - Input image\r\n * @param {number} maxDimension - Maximum dimension for processing (default 800)\r\n * @returns {Promise<Object>} { grayscaleData, scaleFactor, originalDimensions, scaledDimensions }\r\n */\r\nasync function prepareScaleAndGrayscale(image, maxDimension = 800) {\r\n  let originalWidth, originalHeight;\r\n  \r\n  // Robust check for ImageData without relying on global ImageData class\r\n  const isImageData = image && typeof image.width === 'number' && typeof image.height === 'number' && image.data;\r\n\r\n  // Get original dimensions\r\n  if (isImageData) {\r\n    originalWidth = image.width;\r\n    originalHeight = image.height;\r\n  } else if (image) {\r\n    originalWidth = image.width || image.naturalWidth;\r\n    originalHeight = image.height || image.naturalHeight;\r\n  } else {\r\n    throw new Error('No image provided');\r\n  }\r\n  \r\n  const maxCurrentDimension = Math.max(originalWidth, originalHeight);\r\n  \r\n  // Calculate target dimensions\r\n  let targetWidth, targetHeight, scaleFactor;\r\n  \r\n  if (maxCurrentDimension <= maxDimension) {\r\n    targetWidth = originalWidth;\r\n    targetHeight = originalHeight;\r\n    scaleFactor = 1;\r\n  } else {\r\n    const scale = maxDimension / maxCurrentDimension;\r\n    targetWidth = Math.round(originalWidth * scale);\r\n    targetHeight = Math.round(originalHeight * scale);\r\n    scaleFactor = 1 / scale;\r\n  }\r\n  \r\n  // Use OffscreenCanvas if available (faster, no DOM interaction)\r\n  const useOffscreen = typeof OffscreenCanvas !== 'undefined';\r\n  const canvas = useOffscreen \r\n    ? new OffscreenCanvas(targetWidth, targetHeight)\r\n    : document.createElement('canvas');\r\n  \r\n  if (!useOffscreen) {\r\n    canvas.width = targetWidth;\r\n    canvas.height = targetHeight;\r\n  }\r\n  \r\n  const ctx = canvas.getContext('2d', { willReadFrequently: true });\r\n  \r\n  // Apply grayscale filter during draw - GPU accelerated!\r\n  ctx.filter = 'grayscale(1)';\r\n  ctx.imageSmoothingEnabled = true;\r\n  ctx.imageSmoothingQuality = 'medium';\r\n  \r\n  if (isImageData) {\r\n    // For ImageData, need to put on temp canvas first\r\n    const tempCanvas = useOffscreen\r\n      ? new OffscreenCanvas(originalWidth, originalHeight)\r\n      : document.createElement('canvas');\r\n    if (!useOffscreen) {\r\n      tempCanvas.width = originalWidth;\r\n      tempCanvas.height = originalHeight;\r\n    }\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    tempCtx.putImageData(image, 0, 0);\r\n    ctx.drawImage(tempCanvas, 0, 0, originalWidth, originalHeight, 0, 0, targetWidth, targetHeight);\r\n  } else {\r\n    // Direct draw with scaling + grayscale filter\r\n    ctx.drawImage(image, 0, 0, originalWidth, originalHeight, 0, 0, targetWidth, targetHeight);\r\n  }\r\n  \r\n  // Get the grayscale image data\r\n  const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);\r\n  \r\n  // Extract single-channel grayscale (R=G=B after filter, so just take R)\r\n  const grayscaleData = new Uint8ClampedArray(targetWidth * targetHeight);\r\n  const data = imageData.data;\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    grayscaleData[j] = data[i]; // R channel (same as G and B after grayscale filter)\r\n  }\r\n  \r\n  return {\r\n    grayscaleData,\r\n    imageData, // Keep full RGBA for debug visualization\r\n    scaleFactor,\r\n    originalDimensions: { width: originalWidth, height: originalHeight },\r\n    scaledDimensions: { width: targetWidth, height: targetHeight }\r\n  };\r\n}\r\n\r\n// Internal function to detect document in image\r\n// Now accepts pre-computed grayscale data (from prepareScaleAndGrayscale)\r\nasync function detectDocumentInternal(grayscaleData, width, height, scaleFactor, options = {}) {\r\n  // Always create a debug object to collect timings (even if not in debug mode)\r\n  const debugInfo = options.debug ? {} : { _timingsOnly: true };\r\n  const timings = [];\r\n  \r\n  if (debugInfo && !debugInfo._timingsOnly) {\r\n    debugInfo.preprocessing = {\r\n      scaledDimensions: { width, height },\r\n      scaleFactor,\r\n      maxProcessingDimension: options.maxProcessingDimension || 800\r\n    };\r\n  }\r\n  \r\n  // Run edge detection on pre-computed grayscale data (skip grayscale conversion)\r\n  const edges = await cannyEdgeDetector(grayscaleData, {\r\n    width,\r\n    height,\r\n    lowThreshold: options.lowThreshold || 75,   // Match OpenCV values\r\n    highThreshold: options.highThreshold || 200, // Match OpenCV values\r\n    dilationKernelSize: options.dilationKernelSize || 3, // Match OpenCV value \r\n    dilationIterations: options.dilationIterations || 1,\r\n    debug: debugInfo,\r\n    skipGrayscale: true, // Skip grayscale - already done in prep\r\n    useWasmBlur: true,\r\n  });\r\n  \r\n  // Extract edge detection timings (skip the 'Total' entry)\r\n  if (debugInfo.timings) {\r\n    debugInfo.timings.forEach(t => {\r\n      if (t.step !== 'Edge Detection Total') timings.push(t);\r\n    });\r\n  }\r\n  \r\n  // Detect contours from edges\r\n  let t0 = performance.now();\r\n  const contours = detectDocumentContour(edges, {\r\n    minArea: (options.minArea || 1000) / (scaleFactor * scaleFactor), // Adjust minArea for scaled image\r\n    debug: debugInfo,\r\n    width: width,     \r\n    height: height    \r\n  });\r\n  timings.push({ step: 'Find Contours', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (!contours || contours.length === 0) {\r\n    console.log('No document detected');\r\n    return {\r\n      success: false,\r\n      message: 'No document detected',\r\n      debug: debugInfo._timingsOnly ? null : debugInfo,\r\n      timings: timings\r\n    };\r\n  }\r\n  \r\n  // Get the largest contour which is likely the document\r\n  const documentContour = contours[0]; \r\n  \r\n  // Find corner points on the scaled image\r\n  t0 = performance.now();\r\n  const cornerPoints = findCornerPoints(documentContour, { \r\n      epsilon: options.epsilon // Pass epsilon for approximation\r\n  });\r\n  timings.push({ step: 'Corner Detection', ms: (performance.now() - t0).toFixed(2) });\r\n  \r\n  // Scale corner points back to original image size\r\n  let finalCorners = cornerPoints;\r\n  if (scaleFactor !== 1) {\r\n    finalCorners = {\r\n      topLeft: { x: cornerPoints.topLeft.x * scaleFactor, y: cornerPoints.topLeft.y * scaleFactor },\r\n      topRight: { x: cornerPoints.topRight.x * scaleFactor, y: cornerPoints.topRight.y * scaleFactor },\r\n      bottomRight: { x: cornerPoints.bottomRight.x * scaleFactor, y: cornerPoints.bottomRight.y * scaleFactor },\r\n      bottomLeft: { x: cornerPoints.bottomLeft.x * scaleFactor, y: cornerPoints.bottomLeft.y * scaleFactor },\r\n    };\r\n  }\r\n  \r\n  // Return the result, scaling the contour points back up as well\r\n  return {\r\n    success: true,\r\n    contour: documentContour,\r\n    corners: finalCorners,\r\n    debug: debugInfo._timingsOnly ? null : debugInfo,\r\n    timings: timings\r\n  };\r\n}\r\n\r\n// --- Perspective transform helpers (internal use only) ---\r\nfunction getPerspectiveTransform(srcPoints, dstPoints) {\r\n  // Helper to build the system of equations\r\n  function buildMatrix(points) {\r\n    const matrix = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      const [x, y] = points[i];\r\n      matrix.push([x, y, 1, 0, 0, 0, -x * dstPoints[i][0], -y * dstPoints[i][0]]);\r\n      matrix.push([0, 0, 0, x, y, 1, -x * dstPoints[i][1], -y * dstPoints[i][1]]);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  const A = buildMatrix(srcPoints);\r\n  const b = [\r\n    dstPoints[0][0], dstPoints[0][1],\r\n    dstPoints[1][0], dstPoints[1][1],\r\n    dstPoints[2][0], dstPoints[2][1],\r\n    dstPoints[3][0], dstPoints[3][1]\r\n  ];\r\n\r\n  // Solve Ah = b for h (h is 8x1, last element is 1)\r\n  // Use Gaussian elimination or Cramer's rule for 8x8\r\n  // For simplicity, use numeric.js if available, else implement basic solver\r\n  function solve(A, b) {\r\n    // Gaussian elimination for 8x8\r\n    const m = A.length;\r\n    const n = A[0].length;\r\n    const M = A.map(row => row.slice());\r\n    const B = b.slice();\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      // Find max row\r\n      let maxRow = i;\r\n      for (let k = i + 1; k < m; k++) {\r\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\r\n      }\r\n      // Swap rows\r\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\r\n      [B[i], B[maxRow]] = [B[maxRow], B[i]];\r\n\r\n      // Eliminate\r\n      for (let k = i + 1; k < m; k++) {\r\n        const c = M[k][i] / M[i][i];\r\n        for (let j = i; j < n; j++) {\r\n          M[k][j] -= c * M[i][j];\r\n        }\r\n        B[k] -= c * B[i];\r\n      }\r\n    }\r\n\r\n    // Back substitution\r\n    const x = new Array(n);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      let sum = B[i];\r\n      for (let j = i + 1; j < n; j++) {\r\n        sum -= M[i][j] * x[j];\r\n      }\r\n      x[i] = sum / M[i][i];\r\n    }\r\n    return x;\r\n  }\r\n\r\n  const h = solve(A, b);\r\n  // h is [h0,h1,h2,h3,h4,h5,h6,h7], h8 = 1\r\n  const matrix = [\r\n    [h[0], h[1], h[2]],\r\n    [h[3], h[4], h[5]],\r\n    [h[6], h[7], 1]\r\n  ];\r\n  return matrix;\r\n}\r\n\r\n\r\n\r\n\r\nfunction unwarpImage(ctx, image, corners) {\r\n  // Get perspective transform matrix\r\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners;\r\n  // Compute output rectangle size\r\n  const widthA = Math.hypot(bottomRight.x - bottomLeft.x, bottomRight.y - bottomLeft.y);\r\n  const widthB = Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\r\n  const maxWidth = Math.round(Math.max(widthA, widthB));\r\n  const heightA = Math.hypot(topRight.x - bottomRight.x, topRight.y - bottomRight.y);\r\n  const heightB = Math.hypot(topLeft.x - bottomLeft.x, topLeft.y - bottomLeft.y);\r\n  const maxHeight = Math.round(Math.max(heightA, heightB));\r\n\r\n  // Set output canvas size\r\n  ctx.canvas.width = maxWidth;\r\n  ctx.canvas.height = maxHeight;\r\n\r\n  const srcPoints = [\r\n    [topLeft.x, topLeft.y],\r\n    [topRight.x, topRight.y],\r\n    [bottomRight.x, bottomRight.y],\r\n    [bottomLeft.x, bottomLeft.y]\r\n  ];\r\n  const dstPoints = [\r\n    [0, 0],\r\n    [maxWidth - 1, 0],\r\n    [maxWidth - 1, maxHeight - 1],\r\n    [0, maxHeight - 1]\r\n  ];\r\n  const perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);\r\n  warpTransform(ctx, image, perspectiveMatrix, maxWidth, maxHeight);\r\n}\r\n\r\nfunction invert3x3(m) {\r\n  // Invert a 3x3 matrix\r\n  const a = m[0][0], b = m[0][1], c = m[0][2];\r\n  const d = m[1][0], e = m[1][1], f = m[1][2];\r\n  const g = m[2][0], h = m[2][1], i = m[2][2];\r\n  const A = e * i - f * h;\r\n  const B = -(d * i - f * g);\r\n  const C = d * h - e * g;\r\n  const D = -(b * i - c * h);\r\n  const E = a * i - c * g;\r\n  const F = -(a * h - b * g);\r\n  const G = b * f - c * e;\r\n  const H = -(a * f - c * d);\r\n  const I = a * e - b * d;\r\n  const det = a * A + b * B + c * C;\r\n  if (det === 0) throw new Error('Singular matrix');\r\n  return [\r\n    [A / det, D / det, G / det],\r\n    [B / det, E / det, H / det],\r\n    [C / det, F / det, I / det]\r\n  ];\r\n}\r\n\r\nfunction warpTransform(ctx, image, matrix, outWidth, outHeight) {\r\n  // Triangle subdivision approach - uses GPU-accelerated affine transforms\r\n  // Split the quad into a grid, then draw each cell as 2 triangles with affine transforms\r\n  \r\n  const srcWidth = image.width || image.naturalWidth;\r\n  const srcHeight = image.height || image.naturalHeight;\r\n  \r\n  // Inverse matrix for mapping output coords to source coords\r\n  const inv = invert3x3(matrix);\r\n  \r\n  // Helper: map output point to source point using perspective transform\r\n  function mapPoint(x, y) {\r\n    const denom = inv[2][0] * x + inv[2][1] * y + inv[2][2];\r\n    return {\r\n      x: (inv[0][0] * x + inv[0][1] * y + inv[0][2]) / denom,\r\n      y: (inv[1][0] * x + inv[1][1] * y + inv[1][2]) / denom\r\n    };\r\n  }\r\n  \r\n  // Grid subdivisions - 64x64 = 8192 triangles\r\n  const gridX = 64;\r\n  const gridY = 64;\r\n  const cellW = outWidth / gridX;\r\n  const cellH = outHeight / gridY;\r\n  \r\n  // Build source canvas once\r\n  const srcCanvas = document.createElement('canvas');\r\n  srcCanvas.width = srcWidth;\r\n  srcCanvas.height = srcHeight;\r\n  const srcCtx = srcCanvas.getContext('2d');\r\n  srcCtx.drawImage(image, 0, 0, srcWidth, srcHeight);\r\n  \r\n  // High quality results\r\n  ctx.imageSmoothingEnabled = true;\r\n  ctx.imageSmoothingQuality = 'high';\r\n  \r\n  // Draw each grid cell as 2 triangles\r\n  ctx.save();\r\n  \r\n  for (let gy = 0; gy < gridY; gy++) {\r\n    for (let gx = 0; gx < gridX; gx++) {\r\n      // Destination quad corners (in output space)\r\n      const dx0 = gx * cellW;\r\n      const dy0 = gy * cellH;\r\n      const dx1 = (gx + 1) * cellW;\r\n      const dy1 = (gy + 1) * cellH;\r\n      \r\n      // Map to source quad corners\r\n      const s00 = mapPoint(dx0, dy0);\r\n      const s10 = mapPoint(dx1, dy0);\r\n      const s01 = mapPoint(dx0, dy1);\r\n      const s11 = mapPoint(dx1, dy1);\r\n      \r\n      // Draw 2 triangles per cell\r\n      // Triangle 1: top-left, top-right, bottom-left\r\n      drawTexturedTriangle(ctx, srcCanvas,\r\n        s00.x, s00.y, s10.x, s10.y, s01.x, s01.y,  // source triangle\r\n        dx0, dy0, dx1, dy0, dx0, dy1               // dest triangle\r\n      );\r\n      \r\n      // Triangle 2: top-right, bottom-right, bottom-left\r\n      drawTexturedTriangle(ctx, srcCanvas,\r\n        s10.x, s10.y, s11.x, s11.y, s01.x, s01.y,  // source triangle\r\n        dx1, dy0, dx1, dy1, dx0, dy1               // dest triangle\r\n      );\r\n    }\r\n  }\r\n  \r\n  ctx.restore();\r\n}\r\n\r\n// Draw a textured triangle using affine transform + clipping\r\nfunction drawTexturedTriangle(ctx, img,\r\n  sx0, sy0, sx1, sy1, sx2, sy2,  // source triangle coords\r\n  dx0, dy0, dx1, dy1, dx2, dy2   // dest triangle coords\r\n) {\r\n  // Compute affine transform that maps source triangle to dest triangle\r\n  const denom = (sx0 - sx2) * (sy1 - sy2) - (sx1 - sx2) * (sy0 - sy2);\r\n  if (Math.abs(denom) < 1e-10) return; \r\n  \r\n  const invDenom = 1 / denom;\r\n  const a = ((dx0 - dx2) * (sy1 - sy2) - (dx1 - dx2) * (sy0 - sy2)) * invDenom;\r\n  const b = ((dx1 - dx2) * (sx0 - sx2) - (dx0 - dx2) * (sx1 - sx2)) * invDenom;\r\n  const c = dx0 - a * sx0 - b * sy0;\r\n  \r\n  const d = ((dy0 - dy2) * (sy1 - sy2) - (dy1 - dy2) * (sy0 - sy2)) * invDenom;\r\n  const e = ((dy1 - dy2) * (sx0 - sx2) - (dy0 - dy2) * (sx1 - sx2)) * invDenom;\r\n  const f = dy0 - d * sx0 - e * sy0;\r\n  \r\n  ctx.save();\r\n  \r\n  // SEAM FIX: Robust Centroid-based Expansion\r\n  // We expand the clipping path by 1px in the direction of the triangle's center to ensure overlap.\r\n  const expand = 1.0; \r\n  const centerX = (dx0 + dx1 + dx2) / 3;\r\n  const centerY = (dy0 + dy1 + dy2) / 3;\r\n  \r\n  const grow = (x, y) => {\r\n    const vx = x - centerX;\r\n    const vy = y - centerY;\r\n    const len = Math.sqrt(vx * vx + vy * vy);\r\n    if (len < 1e-6) return { x, y };\r\n    return {\r\n      x: x + (vx / len) * expand,\r\n      y: y + (vy / len) * expand\r\n    };\r\n  };\r\n\r\n  const p0 = grow(dx0, dy0);\r\n  const p1 = grow(dx1, dy1);\r\n  const p2 = grow(dx2, dy2);\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(p0.x, p0.y);\r\n  ctx.lineTo(p1.x, p1.y);\r\n  ctx.lineTo(p2.x, p2.y);\r\n  ctx.closePath();\r\n  ctx.clip();\r\n  \r\n  ctx.setTransform(a, d, b, e, c, f);\r\n  ctx.drawImage(img, 0, 0);\r\n  ctx.restore();\r\n}\r\n\r\n\r\n/**\r\n * Extract document with manual corner points (no detection).\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} corners - Corner points object with topLeft, topRight, bottomRight, bottomLeft\r\n * @param {Object} options\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n * @returns {Promise<{output, corners, success, message}>}\r\n */\r\nexport async function extractDocument(image, corners, options = {}) {\r\n  const outputType = options.output || 'canvas';\r\n\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      success: false,\r\n      message: 'Invalid corner points provided'\r\n    };\r\n  }\r\n\r\n  try {\r\n    // Create result canvas and extract document\r\n    const resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, corners);\r\n\r\n    let output;\r\n    // Prepare output in requested format\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n\r\n    return {\r\n      output,\r\n      corners,\r\n      success: true,\r\n      message: 'Document extracted successfully'\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      output: null,\r\n      corners,\r\n      success: false,\r\n      message: `Extraction failed: ${error.message}`\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Main entry point for document scanning.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} options\r\n *   - mode: 'detect' | 'extract' (default: 'detect')\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n *   - debug: boolean\r\n *   - ...other detection options\r\n * @returns {Promise<{output, corners, contour, debug, success, message, timings}>}\r\n */\r\nexport async function scanDocument(image, options = {}) {\r\n  const timings = [];\r\n  const totalStart = performance.now();\r\n  \r\n  const mode = options.mode || 'detect';\r\n  const outputType = options.output || 'canvas';\r\n  const debug = !!options.debug;\r\n  const maxProcessingDimension = options.maxProcessingDimension || 800;\r\n\r\n  // Combined image preparation + downscaling + grayscale (OffscreenCanvas + CSS filter)\r\n  let t0 = performance.now();\r\n  const { grayscaleData, imageData, scaleFactor, originalDimensions, scaledDimensions } = \r\n    await prepareScaleAndGrayscale(image, maxProcessingDimension);\r\n  timings.push({ step: 'Image Prep + Scale + Gray', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  // Detect document (pass pre-computed grayscale data)\r\n  const detection = await detectDocumentInternal(\r\n    grayscaleData, \r\n    scaledDimensions.width, \r\n    scaledDimensions.height, \r\n    scaleFactor, \r\n    options\r\n  );\r\n  \r\n  // Merge detailed detection timings\r\n  if (detection.timings) {\r\n    detection.timings.forEach(t => timings.push(t));\r\n  }\r\n  \r\n  if (!detection.success) {\r\n    const totalEnd = performance.now();\r\n    timings.unshift({ step: 'Total', ms: (totalEnd - totalStart).toFixed(2) });\r\n    console.table(timings);\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      contour: null,\r\n      debug: detection.debug,\r\n      success: false,\r\n      message: detection.message || 'No document detected',\r\n      timings\r\n    };\r\n  }\r\n\r\n  let resultCanvas;\r\n  let output;\r\n\r\n  if (mode === 'detect') {\r\n    // Just return detection info, no image processing\r\n    output = null;\r\n  } else if (mode === 'extract') {\r\n    // Return only the cropped/warped document\r\n    t0 = performance.now();\r\n    resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, detection.corners);\r\n    timings.push({ step: 'Perspective Transform', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  // Prepare output in requested format (only if not detect mode)\r\n  if (mode !== 'detect' && resultCanvas) {\r\n    t0 = performance.now();\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n    timings.push({ step: 'Output Conversion', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  const totalEnd = performance.now();\r\n  timings.unshift({ step: 'Total', ms: (totalEnd - totalStart).toFixed(2) });\r\n  console.table(timings);\r\n\r\n  return {\r\n    output,\r\n    corners: detection.corners,\r\n    contour: detection.contour,\r\n    debug: detection.debug,\r\n    success: true,\r\n    message: 'Document detected',\r\n    timings\r\n  };\r\n}"],"names":["DEFAULTS","RETR_EXTERNAL","RETR_LIST","CHAIN_APPROX_SIMPLE","detectDocumentContour","edges","options","width","height","mode","method","minArea","paddedWidth","paddedHeight","labels","y","x","contours","nextContourId","currentPixelLabel","leftPixelLabel","startPoint","isOuter","initialDirection","contourId","points","traceContour","finalPoints","simplifyChainApproxSimple","adjustedPoints","p","contour","calculateContourArea","calculateBoundingBox","filteredContours","a","b","visited","currentX","currentY","startX","startY","prevDirection","count","maxSteps","dx","dy","searchDirection","found","i","nextX","nextY","checkDirection","checkX","checkY","visitedKey","nextIdx","n","simplifiedPoints","lastPoint","firstPoint","prevPoint","currentPoint","nextPoint","dx1","dy1","dx2","dy2","maxDistSq","farthestIdx","p0x","p0y","pi","distSq","area","j","minX","minY","maxX","maxY","point","simplifyContour","epsilon","maxDistance","index","distance","perpendicularDistance","firstSegment","secondSegment","lineStart","lineEnd","lineLengthSq","t","closestPointX","closestPointY","distDx","distDy","approximatePolygon","contourPoints","perimeter","calculateContourPerimeter","actualEpsilon","findCenter","sumX","sumY","findCornerPoints","approximation","corners","orderCornerPoints","findCornersByCoordinateExtremes","topLeft","topRight","bottomRight","bottomLeft","minSum","maxDiff","maxSum","minDiff","sum","diff","center","sortedPoints","angleA","angleB","minIndex","orderedPoints","wasm","cachedUint8ArrayMemory0","getUint8ArrayMemory0","WASM_VECTOR_LEN","passArray8ToWasm0","arg","malloc","ptr","getArrayU8FromWasm0","len","dilate","kernel_size","ptr0","len0","ret","v2","cachedFloat32ArrayMemory0","getFloat32ArrayMemory0","passArrayF32ToWasm0","hysteresis_thresholding","suppressed","low_threshold","high_threshold","blur","grayscale","sigma","cachedUint16ArrayMemory0","getUint16ArrayMemory0","passArray16ToWasm0","getArrayF32FromWasm0","non_maximum_suppression","l2_gradient","ptr1","len1","v3","__wbg_load","module","imports","e","bytes","instance","__wbg_get_imports","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","wasmReadyPromise","initializeWasm","init","convertToGrayscale","imageData","data","gaussianBlurGrayscale","kernelSize","halfKernel","kernel","createGaussianKernel","tempArray","blurred","rowOffset","k","xOffset","yOffset","size","halfSize","calculateGradients","prevRowOffset","nextRowOffset","currentIdx","p0","p1","p2","p3","p5","p6","p7","p8","gx","gy","nonMaximumSuppression","L2gradient","magnitude","idx","mag","neighbor1","neighbor2","absGx","absGy","s","hysteresisThresholding","lowThreshold","highThreshold","edgeMap","stack","dxNeighbors","dyNeighbors","nx","ny","nidx","dilateEdges","temp","dilated","maxVal","val","cannyEdgeDetector","input","timings","tStart","skipGrayscale","t0","t1","applyDilation","dilationKernelSize","useWasmHysteresis","wasmBlur","gradients","wasmMaximumSuppression","finalLowThreshold","finalHighThreshold","wasmHysteresis","cannyEdges","finalEdges","wasmDilate","tEnd","initialize","Scanner","image","combinedOptions","scanDocument","extractDocument","prepareScaleAndGrayscale","maxDimension","originalWidth","originalHeight","isImageData","maxCurrentDimension","targetWidth","targetHeight","scaleFactor","scale","useOffscreen","canvas","ctx","tempCanvas","grayscaleData","detectDocumentInternal","debugInfo","documentContour","cornerPoints","finalCorners","getPerspectiveTransform","srcPoints","dstPoints","buildMatrix","matrix","A","solve","m","M","row","B","maxRow","c","h","unwarpImage","widthA","widthB","maxWidth","heightA","heightB","maxHeight","perspectiveMatrix","warpTransform","invert3x3","d","f","g","C","E","F","G","H","I","det","outWidth","outHeight","srcWidth","srcHeight","inv","mapPoint","denom","gridX","gridY","cellW","cellH","srcCanvas","dx0","dy0","s00","s10","s01","s11","drawTexturedTriangle","img","sx0","sy0","sx1","sy1","sx2","sy2","invDenom","expand","centerX","centerY","grow","vx","vy","outputType","resultCanvas","output","error","totalStart","maxProcessingDimension","originalDimensions","scaledDimensions","detection","totalEnd"],"mappings":"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"}