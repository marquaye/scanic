const Z = {
  // Contour detection params
  MIN_CONTOUR_AREA: 1e3,
  MIN_CONTOUR_POINTS: 10
}, $ = 0, AA = 1, K = 2;
function IA(I, A = {}) {
  const g = A.width || Math.sqrt(I.length), C = A.height || I.length / g, t = A.mode !== void 0 ? A.mode : AA, Q = A.method !== void 0 ? A.method : K, B = A.minArea || Z.MIN_CONTOUR_AREA, i = g + 2, o = C + 2, E = new Int32Array(i * o);
  for (let n = 0; n < C; n++)
    for (let y = 0; y < g; y++)
      I[n * g + y] > 0 && (E[(n + 1) * i + (y + 1)] = 1);
  const s = [];
  let a = 2;
  for (let n = 1; n <= C; n++)
    for (let y = 1; y <= g; y++) {
      const c = E[n * i + y], w = E[n * i + (y - 1)];
      let D = null, h = !1, r = -1;
      if (c === 1 && w === 0 ? (h = !0, D = { x: y, y: n }, r = 2) : c === 0 && w >= 1 && w !== -1 && w === 1 && (h = !1, D = { x: y - 1, y: n }, r = 6), D) {
        if (t === $ && !h) {
          E[D.y * i + D.x] = -1;
          continue;
        }
        const N = a++, F = gA(E, i, o, D, r, N);
        if (F && F.length > 0) {
          let J = F;
          Q === K && (J = BA(F));
          const f = J.map((G) => ({ x: G.x - 1, y: G.y - 1 }));
          if (f.length >= (Q === K ? 4 : Z.MIN_CONTOUR_POINTS)) {
            const G = {
              id: N,
              points: f,
              isOuter: h
              // Calculate area and bounding box later if needed for filtering/sorting
            };
            s.push(G);
          }
        } else
          E[D.y * i + D.x] === 1 && (E[D.y * i + D.x] = N);
      }
    }
  s.forEach((n) => {
    n.area = QA(n.points), n.boundingBox = CA(n.points);
  });
  const e = s.filter((n) => n.area >= B);
  return e.sort((n, y) => y.area - n.area), A.debug && (A.debug.labels = E, A.debug.rawContours = s, A.debug.finalContours = e), e;
}
function gA(I, A, g, C, t, Q) {
  const B = [], i = /* @__PURE__ */ new Set();
  let o = C.x, E = C.y;
  const s = o, a = E;
  let e = -1;
  I[a * A + s] = Q;
  let n = 0;
  const y = A * g, c = [0, 1, 1, 1, 0, -1, -1, -1], w = [-1, -1, 0, 1, 1, 1, 0, -1];
  for (; n++ < y; ) {
    let D;
    if (e === -1) {
      let J = !1;
      for (let f = 0; f < 8; f++) {
        D = t + f & 7;
        const G = o + c[D], k = E + w[D];
        if (G >= 0 && G < A && k >= 0 && k < g && I[k * A + G] > 0) {
          J = !0;
          break;
        }
      }
      if (!J) return null;
    } else
      D = e + 2 & 7;
    let h = -1, r = -1;
    for (let J = 0; J < 8; J++) {
      const f = D + J & 7, G = o + c[f], k = E + w[f];
      if (G >= 0 && G < A && k >= 0 && k < g && I[k * A + G] > 0) {
        h = G, r = k, e = f + 4 & 7;
        break;
      }
    }
    if (h === -1) {
      B.length === 0 && B.push({ x: o, y: E }), console.warn(`Contour tracing stopped unexpectedly at (${o - 1}, ${E - 1}) for contour ${Q}`);
      break;
    }
    const N = E * A + o;
    if (i.has(N))
      return B;
    B.push({ x: o, y: E }), i.add(N);
    const F = r * A + h;
    if (I[F] === 1 && (I[F] = Q), o = h, E = r, o === s && E === a)
      break;
  }
  return n >= y ? (console.warn(`Contour tracing exceeded max steps for contour ${Q}`), null) : B;
}
function BA(I) {
  const A = I.length;
  if (A <= 2)
    return I;
  const g = [], C = I[A - 1], t = I[0];
  let Q = C, B = t, i = I[1], o = B.x - Q.x, E = B.y - Q.y, s = i.x - B.x, a = i.y - B.y;
  o * a !== E * s && g.push(B);
  for (let e = 1; e < A - 1; e++)
    Q = I[e - 1], B = I[e], i = I[e + 1], o = B.x - Q.x, E = B.y - Q.y, s = i.x - B.x, a = i.y - B.y, o * a !== E * s && g.push(B);
  if (Q = I[A - 2], B = C, i = t, o = B.x - Q.x, E = B.y - Q.y, s = i.x - B.x, a = i.y - B.y, o * a !== E * s && g.push(B), g.length === 0) {
    if (A === 1) return [I[0]];
    if (A === 2) return I;
    let e = 0, n = 1;
    const y = t.x, c = t.y;
    for (let w = 1; w < A; w++) {
      const D = I[w], h = D.x - y, r = D.y - c, N = h * h + r * r;
      N > e && (e = N, n = w);
    }
    return [t, I[n]];
  }
  return g;
}
function QA(I) {
  let A = 0;
  const g = I.length;
  if (g < 3) return 0;
  for (let C = 0; C < g; C++) {
    const t = (C + 1) % g;
    A += I[C].x * I[t].y, A -= I[t].x * I[C].y;
  }
  return Math.abs(A) / 2;
}
function CA(I) {
  if (I.length === 0)
    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
  let A = I[0].x, g = I[0].y, C = I[0].x, t = I[0].y;
  for (let Q = 1; Q < I.length; Q++) {
    const B = I[Q];
    A = Math.min(A, B.x), g = Math.min(g, B.y), C = Math.max(C, B.x), t = Math.max(t, B.y);
  }
  return { minX: A, minY: g, maxX: C, maxY: t };
}
function T(I, A = 1) {
  if (I.length <= 2)
    return I;
  let g = 0, C = 0;
  const t = I[0], Q = I[I.length - 1];
  for (let B = 1; B < I.length - 1; B++) {
    const i = EA(I[B], t, Q);
    i > g && (g = i, C = B);
  }
  if (g > A) {
    const B = T(I.slice(0, C + 1), A), i = T(I.slice(C), A);
    return B.slice(0, -1).concat(i);
  } else
    return [t, Q];
}
function EA(I, A, g) {
  const C = g.x - A.x, t = g.y - A.y, Q = C * C + t * t;
  if (Q === 0)
    return Math.sqrt(
      Math.pow(I.x - A.x, 2) + Math.pow(I.y - A.y, 2)
    );
  const B = ((I.x - A.x) * C + (I.y - A.y) * t) / Q;
  let i, o;
  B < 0 ? (i = A.x, o = A.y) : B > 1 ? (i = g.x, o = g.y) : (i = A.x + B * C, o = A.y + B * t);
  const E = I.x - i, s = I.y - o;
  return Math.sqrt(E * E + s * s);
}
function iA(I, A = 0.02) {
  const g = tA(I), C = A * g;
  return T(I, C);
}
function tA(I) {
  let A = 0;
  const g = I.length;
  if (g < 2) return 0;
  for (let C = 0; C < g; C++) {
    const t = (C + 1) % g, Q = I[C].x - I[t].x, B = I[C].y - I[t].y;
    A += Math.sqrt(Q * Q + B * B);
  }
  return A;
}
function oA(I) {
  let A = 0, g = 0;
  for (const C of I)
    A += C.x, g += C.y;
  return {
    x: A / I.length,
    y: g / I.length
  };
}
function eA(I, A = {}) {
  if (!I || !I.points || I.points.length < 4)
    return console.warn("Contour does not have enough points for corner detection"), null;
  const g = A.epsilon || 0.02, C = iA(I, g);
  let t;
  return C && C.length === 4 ? t = aA(C) : t = sA(I.points), !t || !t.topLeft || !t.topRight || !t.bottomRight || !t.bottomLeft ? (console.warn("Failed to find all four corners.", t), null) : t;
}
function sA(I) {
  if (!I || I.length === 0) return null;
  let A = I[0], g = I[0], C = I[0], t = I[0], Q = A.x + A.y, B = g.x - g.y, i = C.x + C.y, o = t.x - t.y;
  for (let E = 1; E < I.length; E++) {
    const s = I[E], a = s.x + s.y, e = s.x - s.y;
    a < Q && (Q = a, A = s), a > i && (i = a, C = s), e > B && (B = e, g = s), e < o && (o = e, t = s);
  }
  return {
    topLeft: A,
    topRight: g,
    bottomRight: C,
    bottomLeft: t
  };
}
function aA(I) {
  if (I.length !== 4)
    return console.warn(`Expected 4 points, got ${I.length}`), null;
  const A = oA(I), g = [...I].sort((B, i) => {
    const o = Math.atan2(B.y - A.y, B.x - A.x), E = Math.atan2(i.y - A.y, i.x - A.x);
    return o - E;
  });
  let C = 1 / 0, t = 0;
  for (let B = 0; B < 4; B++) {
    const i = g[B].x + g[B].y;
    i < C && (C = i, t = B);
  }
  const Q = [
    g[t],
    g[(t + 1) % 4],
    g[(t + 2) % 4],
    g[(t + 3) % 4]
  ];
  return {
    topLeft: Q[0],
    topRight: Q[1],
    bottomRight: Q[2],
    bottomLeft: Q[3]
  };
}
let R, H = null;
function O() {
  return (H === null || H.byteLength === 0) && (H = new Uint8Array(R.memory.buffer)), H;
}
let M = 0;
function v(I, A) {
  const g = A(I.length * 1, 1) >>> 0;
  return O().set(I, g / 1), M = I.length, g;
}
function W(I, A) {
  return I = I >>> 0, O().subarray(I / 1, I / 1 + A);
}
function nA(I, A, g, C, t) {
  const Q = v(I, R.__wbindgen_malloc), B = M, i = R.blur(Q, B, A, g, C, t);
  var o = W(i[0], i[1]).slice();
  return R.__wbindgen_free(i[0], i[1] * 1, 1), o;
}
let d = null;
function V() {
  return (d === null || d.byteLength === 0) && (d = new Float32Array(R.memory.buffer)), d;
}
function cA(I, A) {
  const g = A(I.length * 4, 4) >>> 0;
  return V().set(I, g / 4), M = I.length, g;
}
function DA(I, A, g, C, t) {
  const Q = cA(I, R.__wbindgen_malloc), B = M, i = R.hysteresis_thresholding(Q, B, A, g, C, t);
  var o = W(i[0], i[1]).slice();
  return R.__wbindgen_free(i[0], i[1] * 1, 1), o;
}
function yA(I, A, g, C) {
  const t = v(I, R.__wbindgen_malloc), Q = M, B = R.dilate(t, Q, A, g, C);
  var i = W(B[0], B[1]).slice();
  return R.__wbindgen_free(B[0], B[1] * 1, 1), i;
}
let u = null;
function wA() {
  return (u === null || u.byteLength === 0) && (u = new Uint16Array(R.memory.buffer)), u;
}
function X(I, A) {
  const g = A(I.length * 2, 2) >>> 0;
  return wA().set(I, g / 2), M = I.length, g;
}
function rA(I, A) {
  return I = I >>> 0, V().subarray(I / 4, I / 4 + A);
}
function hA(I, A, g, C, t) {
  const Q = X(I, R.__wbindgen_malloc), B = M, i = X(A, R.__wbindgen_malloc), o = M, E = R.non_maximum_suppression(Q, B, i, o, g, C, t);
  var s = rA(E[0], E[1]).slice();
  return R.__wbindgen_free(E[0], E[1] * 4, 4), s;
}
async function NA(I, A) {
  if (typeof Response == "function" && I instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(I, A);
      } catch (C) {
        if (I.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", C);
        else
          throw C;
      }
    const g = await I.arrayBuffer();
    return await WebAssembly.instantiate(g, A);
  } else {
    const g = await WebAssembly.instantiate(I, A);
    return g instanceof WebAssembly.Instance ? { instance: g, module: I } : g;
  }
}
function GA() {
  const I = {};
  return I.wbg = {}, I.wbg.__wbindgen_init_externref_table = function() {
    const A = R.__wbindgen_export_0, g = A.grow(4);
    A.set(0, void 0), A.set(g + 0, void 0), A.set(g + 1, null), A.set(g + 2, !0), A.set(g + 3, !1);
  }, I;
}
function RA(I, A) {
  return R = I.exports, z.__wbindgen_wasm_module = A, d = null, u = null, H = null, R.__wbindgen_start(), R;
}
async function z(I) {
  if (R !== void 0) return R;
  typeof I < "u" && (Object.getPrototypeOf(I) === Object.prototype ? { module_or_path: I } = I : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof I > "u" && (I = new URL("data:application/wasm;base64,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KAIARw0BQYCbwAAgADYCAA8LIAIgA0F+cTYCBCABIABBAXI2AgQgACABaiAANgIACyAAQYACSQ0CIAEgABALQQAhAUGgm8AAQaCbwAAoAgBBAWsiADYCACAADQRB6JjAACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0Ggm8AAQf8fIAEgAUH/H00bNgIADwtBjJvAACABNgIAQYSbwABBhJvAACgCACAAaiIANgIAIAEgAEEBcjYCBEGIm8AAKAIAIAFGBEBBgJvAAEEANgIAQYibwABBADYCAAsgAEGYm8AAKAIAIgNNDQNBjJvAACgCACICRQ0DQQAhAEGEm8AAKAIAIgRBKUkNAkHgmMAAIQEDQCACIAEoAgAiBU8EQCACIAUgASgCBGpJDQQLIAEoAgghAQwACwALQYibwAAgATYCAEGAm8AAQYCbwAAoAgAgAGoiADYCACABIABBAXI2AgQgACABaiAANgIADwsCQEH4msAAKAIAIgJBASAAQQN2dCIDcUUEQEH4msAAIAIgA3I2AgAgAEH4AXFB8JjAAGoiACECDAELIABB+AFxIgBB8JjAAGohAiAAQfiYwABqKAIAIQALIAIgATYCCCAAIAE2AgwgASACNgIMIAEgADYCCA8LQeiYwAAoAgAiAQRAA0AgAEEBaiEAIAEoAggiAQ0ACwtBoJvAAEH/HyAAIABB/x9NGzYCACADIARPDQBBmJvAAEF/NgIACwu4BAEIfyMAQRBrIgMkACADIAE2AgQgAyAANgIAIANCoICAgA43AggCfwJAAkACQCACKAIQIgkEQCACKAIUIgANAQwCCyACKAIMIgBFDQEgAigCCCIBIABBA3QiAGohBCAAQQhrQQN2QQFqIQYgAigCACEAA0ACQCAAQQRqKAIAIgVFDQAgAygCACAAKAIAIAUgAygCBCgCDBEDAEUNAEEBDAULQQEgASgCACADIAFBBGooAgARAgANBBogAEEIaiEAIAQgAUEIaiIBRw0ACwwCCyAAQRhsIQogAEEBa0H/////AXFBAWohBiACKAIIIQQgAigCACEAA0ACQCAAQQRqKAIAIgFFDQAgAygCACAAKAIAIAEgAygCBCgCDBEDAEUNAEEBDAQLQQAhB0EAIQgCQAJAAkAgBSAJaiIBQQhqLwEAQQFrDgIBAgALIAFBCmovAQAhCAwB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DAELIAJBEGogACgCDCgCACIAQQhqKQIANwMAIAJBGGogAEEQaikCADcDACACIAApAgA3AwggASgCACABKAIEIAJBCGoQBgsgAkEgaiQAC2kBA38jAEEQayIBJAAgAUEEaiAAKAIAIgIgACgCBEEEIAJBAXQiAiACQQRNGyICQQRBBBARIAEoAgRBAUYEQCABKAIIIAEoAgwQLQALIAEoAgghAyAAIAI2AgAgACADNgIEIAFBEGokAAtpAQN/IwBBEGsiASQAIAFBBGogACgCACICIAAoAgRBBCACQQF0IgIgAkEETRsiAkEEQQgQESABKAIEQQFGBEAgASgCCCABKAIMEC0ACyABKAIIIQMgACACNgIAIAAgAzYCBCABQRBqJAALaQEDfyMAQRBrIgEkACABQQRqIAAoAgAiAiAAKAIEQQQgAkEBdCICIAJBBE0bIgJBAkECEBEgASgCBEEBRgRAIAEoAgggASgCDBAtAAsgASgCCCEDIAAgAjYCACAAIAM2AgQgAUEQaiQACxIAIwBBMGsiACQAIABBMGokAAtoAgF/AX4jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0Gkl8AANgIIIANCAjcCFCADQoCAgIAwIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhAmAAtHAQF/IAAoAgAgACgCCCIDayACSQRAIAAgAyACEBIgACgCCCEDCyACBEAgACgCBCADaiABIAL8CgAACyAAIAIgA2o2AghBAAtEAQJ/IAEoAgQhAiABKAIAIQNBCEEEEDUiAUUEQEEEQQgQOQALIAEgAjYCBCABIAM2AgAgAEGcksAANgIEIAAgATYCAAvGAgACQCAAIAJNBEAgACABTSABIAJLcg0BIwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkECNgIMIAJBmJbAADYCCCACQgI3AhQgAiACQQRqrUKAgICAMIQ3AyggAiACrUKAgICAMIQ3AyAgAiACQSBqNgIQIAJBCGogAxAmAAsjAEEwayIBJAAgASACNgIEIAEgADYCACABQQI2AgwgAUG8lsAANgIIIAFCAjcCFCABIAFBBGqtQoCAgIAwhDcDKCABIAGtQoCAgIAwhDcDICABIAFBIGo2AhAgAUEIaiADECYACyMAQTBrIgAkACAA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bGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAIgIEAAVAAAAnQgQAA0AAAAvARAAGAAAAGQBAAAJAAAABAAAAAwAAAAEAAAABQAAAAYAAAAHAAAAAAAAAAgAAAAEAAAACAAAAAkAAAAKAAAACwAAAAwAAAAQAAAABAAAAA0AAAAOAAAADwAAABAAAAAAAAAACAAAAAQAAAARAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZAAABAEQACoAAACxBAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplIDw9IHNpemUgKyBtYXhfb3ZlcmhlYWQAAAQBEAAqAAAAtwQAAA0AAAAEAAAADAAAAAQAAAASAAAAY2FwYWNpdHkgb3ZlcmZsb3cAAAC8CRAAEQAAAOMAEAAgAAAAHAAAAAUAAAAwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OXJhbmdlIGVuZCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACwChAAEAAAAMAKEAAiAAAAc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCAA9AoQABYAAAAKCxAADQAAAHJhbmdlIHN0YXJ0IGluZGV4IAAAKAsQABIAAADAChAAIgAAAGF0dGVtcHQgdG8gZGl2aWRlIGJ5IHplcm8AAABMCxAAGQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABwCxAAIAAAAJALEAASAAAAAAAAPwAAAL8AQdSXwAALAQEAfAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuOTIuMCAoZGVkNWMwNmNmIDIwMjUtMTItMDgpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuEzAuMi4xMDAgKDI0MDVlYzJiNCkAdA90YXJnZXRfZmVhdHVyZXMHKw9tdXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrB3NpbWQxMjgrC2J1bGstbWVtb3J5KwhzaWduLWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl", import.meta.url));
  const A = GA();
  (typeof I == "string" || typeof Request == "function" && I instanceof Request || typeof URL == "function" && I instanceof URL) && (I = fetch(I));
  const { instance: g, module: C } = await NA(await I, A);
  return RA(g, C);
}
let p = null;
function Y() {
  return p || (p = z()), p;
}
function JA(I) {
  const { width: A, height: g, data: C } = I, t = new Uint8ClampedArray(A * g);
  for (let Q = 0, B = 0; Q < C.length; Q += 4, B++)
    t[B] = C[Q] * 54 + C[Q + 1] * 183 + C[Q + 2] * 19 >> 8;
  return t;
}
function fA(I, A, g, C = 5, t = 0) {
  t === 0 && (t = 0.3 * ((C - 1) * 0.5 - 1) + 0.8);
  const Q = Math.floor(C / 2), B = lA(C, t), i = new Uint8ClampedArray(A * g), o = new Uint8ClampedArray(A * g);
  for (let E = 0; E < g; E++) {
    const s = E * A;
    for (let a = 0; a < A; a++) {
      let e = 0;
      for (let n = -Q; n <= Q; n++) {
        const y = Math.min(A - 1, Math.max(0, a + n));
        e += I[s + y] * B[Q + n];
      }
      i[s + a] = e;
    }
  }
  for (let E = 0; E < A; E++)
    for (let s = 0; s < g; s++) {
      let a = 0;
      for (let e = -Q; e <= Q; e++) {
        const n = Math.min(g - 1, Math.max(0, s + e));
        a += i[n * A + E] * B[Q + e];
      }
      o[s * A + E] = Math.round(a);
    }
  return o;
}
function lA(I, A) {
  const g = new Float32Array(I), C = Math.floor(I / 2);
  let t = 0;
  for (let Q = 0; Q < I; Q++) {
    const B = Q - C;
    g[Q] = Math.exp(-(B * B) / (2 * A * A)), t += g[Q];
  }
  for (let Q = 0; Q < I; Q++)
    g[Q] /= t;
  return g;
}
function FA(I, A, g) {
  const C = new Int16Array(A * g), t = new Int16Array(A * g);
  for (let Q = 1; Q < g - 1; Q++) {
    const B = Q * A, i = (Q - 1) * A, o = (Q + 1) * A;
    for (let E = 1; E < A - 1; E++) {
      const s = B + E, a = I[i + E - 1], e = I[i + E], n = I[i + E + 1], y = I[B + E - 1], c = I[B + E + 1], w = I[o + E - 1], D = I[o + E], h = I[o + E + 1], r = n - a + 2 * (c - y) + (h - w), N = w + 2 * D + h - (a + 2 * e + n);
      C[s] = r, t[s] = N;
    }
  }
  return { dx: C, dy: t };
}
function kA(I, A, g, C, t) {
  const Q = new Float32Array(g * C), B = new Float32Array(g * C);
  for (let i = 0; i < I.length; i++) {
    const o = I[i], E = A[i];
    t ? Q[i] = Math.sqrt(o * o + E * E) : Q[i] = Math.abs(o) + Math.abs(E);
  }
  for (let i = 1; i < C - 1; i++)
    for (let o = 1; o < g - 1; o++) {
      const E = i * g + o, s = Q[E];
      if (s === 0) {
        B[E] = 0;
        continue;
      }
      const a = I[E], e = A[E];
      let n = 0, y = 0;
      const c = Math.abs(a), w = Math.abs(e);
      if (w > c * 2.4142)
        n = Q[E - g], y = Q[E + g];
      else if (c > w * 2.4142)
        n = Q[E - 1], y = Q[E + 1];
      else {
        const D = (a ^ e) < 0 ? -1 : 1;
        e > 0 ? (n = Q[(i - 1) * g + (o - D)], y = Q[(i + 1) * g + (o + D)]) : (n = Q[(i + 1) * g + (o - D)], y = Q[(i - 1) * g + (o + D)]), a > 0 && e > 0 || a < 0 && e < 0 ? (n = Q[(i - 1) * g + (o + 1)], y = Q[(i + 1) * g + (o - 1)]) : (n = Q[(i - 1) * g + (o - 1)], y = Q[(i + 1) * g + (o + 1)]);
      }
      s >= n && s >= y ? B[E] = s : B[E] = 0;
    }
  return B;
}
function P(I, A, g, C, t) {
  const Q = new Uint8Array(A * g), B = [];
  for (let E = 1; E < g - 1; E++)
    for (let s = 1; s < A - 1; s++) {
      const a = E * A + s, e = I[a];
      e >= t ? (Q[a] = 2, B.push({ x: s, y: E })) : e >= C ? Q[a] = 0 : Q[a] = 1;
    }
  for (let E = 0; E < A; E++)
    Q[E] = 1, Q[(g - 1) * A + E] = 1;
  for (let E = 1; E < g - 1; E++)
    Q[E * A] = 1, Q[E * A + A - 1] = 1;
  const i = [-1, 0, 1, -1, 1, -1, 0, 1], o = [-1, -1, -1, 0, 0, 1, 1, 1];
  for (; B.length > 0; ) {
    const { x: E, y: s } = B.pop();
    for (let a = 0; a < 8; a++) {
      const e = E + i[a], n = s + o[a], y = n * A + e;
      Q[y] === 0 && (Q[y] = 2, B.push({ x: e, y: n }));
    }
  }
  return Q;
}
function SA(I, A, g, C = 5) {
  const t = Math.floor(C / 2), Q = new Uint8ClampedArray(A * g), B = new Uint8ClampedArray(A * g);
  for (let i = 0; i < g; i++) {
    const o = i * A;
    for (let E = 0; E < A; E++) {
      let s = 0;
      for (let a = -t; a <= t; a++) {
        const e = E + a;
        if (e >= 0 && e < A) {
          const n = I[o + e];
          n > s && (s = n);
        }
      }
      Q[o + E] = s;
    }
  }
  for (let i = 0; i < A; i++)
    for (let o = 0; o < g; o++) {
      let E = 0;
      for (let s = -t; s <= t; s++) {
        const a = o + s;
        if (a >= 0 && a < g) {
          const e = Q[a * A + i];
          e > E && (E = e);
        }
      }
      B[o * A + i] = E;
    }
  return B;
}
async function MA(I, A = {}) {
  const g = [], C = performance.now(), t = A.skipGrayscale || !1;
  let Q, B, i;
  if (t)
    Q = A.width, B = A.height, i = I, A.debug && (A.debug.grayscale = i);
  else {
    Q = I.width, B = I.height;
    let l = performance.now();
    i = JA(I);
    let S = performance.now();
    g.push({ step: "Grayscale", ms: (S - l).toFixed(2) }), A.debug && (A.debug.grayscale = i);
  }
  let o = A.lowThreshold !== void 0 ? A.lowThreshold : 75, E = A.highThreshold !== void 0 ? A.highThreshold : 200;
  const s = A.kernelSize || 5, a = A.sigma || 0, e = A.L2gradient === void 0 ? !1 : A.L2gradient, n = A.applyDilation !== void 0 ? A.applyDilation : !0, y = A.dilationKernelSize || 5, c = A.useWasmHysteresis !== void 0 ? A.useWasmHysteresis : !1;
  o >= E && (console.warn(`Canny Edge Detector: lowThreshold (${o}) should be lower than highThreshold (${E}). Swapping them.`), [o, E] = [E, o]);
  let w, D, h;
  w = performance.now();
  try {
    await Y(), h = nA(i, Q, B, s, a);
  } catch {
    h = fA(i, Q, B, s, a);
  }
  D = performance.now(), g.push({ step: "Gaussian Blur", ms: (D - w).toFixed(2) }), A.debug && (A.debug.blurred = h), w = performance.now();
  let r, N;
  {
    const l = FA(h, Q, B);
    r = l.dx, N = l.dy;
  }
  D = performance.now(), g.push({ step: "Gradients", ms: (D - w).toFixed(2) }), w = performance.now();
  let F;
  try {
    await Y(), F = await hA(r, N, Q, B, e);
  } catch {
    F = kA(r, N, Q, B, e);
  }
  D = performance.now(), g.push({ step: "Non-Max Suppression", ms: (D - w).toFixed(2) }), w = performance.now();
  const J = e ? o * o : o, f = e ? E * E : E;
  let G;
  if (c)
    try {
      await Y(), G = DA(F, Q, B, J, f);
    } catch (l) {
      console.warn("WASM hysteresis failed, falling back to JS:", l), G = P(F, Q, B, J, f);
    }
  else
    G = P(F, Q, B, J, f);
  D = performance.now(), g.push({ step: "Hysteresis", ms: (D - w).toFixed(2) }), w = performance.now();
  const k = new Uint8ClampedArray(Q * B);
  for (let l = 0; l < G.length; l++)
    k[l] = G[l] === 2 ? 255 : 0;
  D = performance.now(), g.push({ step: "Binary Image", ms: (D - w).toFixed(2) }), w = performance.now();
  let L = k;
  if (n)
    try {
      await Y(), L = yA(k, Q, B, y);
    } catch {
      L = SA(k, Q, B, y);
    }
  if (D = performance.now(), g.push({ step: "Dilation", ms: (D - w).toFixed(2) }), A.debug) {
    A.debug.dx = r, A.debug.dy = N;
    const l = new Float32Array(Q * B);
    for (let S = 0; S < r.length; S++) {
      const m = r[S], U = N[S];
      l[S] = e ? Math.sqrt(m * m + U * U) : Math.abs(m) + Math.abs(U);
    }
    A.debug.magnitude = l, A.debug.suppressed = F, A.debug.edgeMap = G, A.debug.cannyEdges = k, A.debug.finalEdges = L;
  }
  A.debug ? A.debug.timings = g : A.debug || (A.debug = { timings: g });
  const q = performance.now();
  return g.unshift({ step: "Edge Detection Total", ms: (q - C).toFixed(2) }), L;
}
async function qA() {
  return await Y();
}
class xA {
  constructor(A = {}) {
    this.defaultOptions = {
      maxProcessingDimension: 800,
      mode: "detect",
      output: "canvas",
      ...A
    }, this.initialized = !1;
  }
  /**
   * Warm up the scanner (load WASM, etc.)
   */
  async initialize() {
    this.initialized || (await Y(), this.initialized = !0);
  }
  /**
   * Scan an image for a document.
   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image 
   * @param {Object} options Override default options
   */
  async scan(A, g = {}) {
    this.initialized || await this.initialize();
    const C = { ...this.defaultOptions, ...g };
    return await uA(A, C);
  }
  /**
   * Extract a document from an image using manual corners.
   * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image 
   * @param {Object} corners 
   * @param {Object} options 
   */
  async extract(A, g, C = {}) {
    this.initialized || await this.initialize();
    const t = { ...this.defaultOptions, ...C };
    return await dA(A, g, t);
  }
}
async function LA(I, A = 800) {
  let g, C;
  const t = I && typeof I.width == "number" && typeof I.height == "number" && I.data;
  if (t)
    g = I.width, C = I.height;
  else if (I)
    g = I.width || I.naturalWidth, C = I.height || I.naturalHeight;
  else
    throw new Error("No image provided");
  const Q = Math.max(g, C);
  let B, i, o;
  if (Q <= A)
    B = g, i = C, o = 1;
  else {
    const c = A / Q;
    B = Math.round(g * c), i = Math.round(C * c), o = 1 / c;
  }
  const E = typeof OffscreenCanvas < "u", s = E ? new OffscreenCanvas(B, i) : document.createElement("canvas");
  E || (s.width = B, s.height = i);
  const a = s.getContext("2d", { willReadFrequently: !0 });
  if (a.filter = "grayscale(1)", a.imageSmoothingEnabled = !0, a.imageSmoothingQuality = "medium", t) {
    const c = E ? new OffscreenCanvas(g, C) : document.createElement("canvas");
    E || (c.width = g, c.height = C), c.getContext("2d").putImageData(I, 0, 0), a.drawImage(c, 0, 0, g, C, 0, 0, B, i);
  } else
    a.drawImage(I, 0, 0, g, C, 0, 0, B, i);
  const e = a.getImageData(0, 0, B, i), n = new Uint8ClampedArray(B * i), y = e.data;
  for (let c = 0, w = 0; c < y.length; c += 4, w++)
    n[w] = y[c];
  return {
    grayscaleData: n,
    imageData: e,
    // Keep full RGBA for debug visualization
    scaleFactor: o,
    originalDimensions: { width: g, height: C },
    scaledDimensions: { width: B, height: i }
  };
}
async function mA(I, A, g, C, t = {}) {
  const Q = t.debug ? {} : { _timingsOnly: !0 }, B = [];
  Q && !Q._timingsOnly && (Q.preprocessing = {
    scaledDimensions: { width: A, height: g },
    scaleFactor: C,
    maxProcessingDimension: t.maxProcessingDimension || 800
  });
  const i = await MA(I, {
    width: A,
    height: g,
    lowThreshold: t.lowThreshold || 75,
    // Match OpenCV values
    highThreshold: t.highThreshold || 200,
    // Match OpenCV values
    dilationKernelSize: t.dilationKernelSize || 3,
    // Match OpenCV value 
    dilationIterations: t.dilationIterations || 1,
    debug: Q,
    skipGrayscale: !0
  });
  Q.timings && Q.timings.forEach((n) => {
    n.step !== "Edge Detection Total" && B.push(n);
  });
  let o = performance.now();
  const E = IA(i, {
    minArea: (t.minArea || 1e3) / (C * C),
    // Adjust minArea for scaled image
    debug: Q,
    width: A,
    height: g
  });
  if (B.push({ step: "Find Contours", ms: (performance.now() - o).toFixed(2) }), !E || E.length === 0)
    return console.log("No document detected"), {
      success: !1,
      message: "No document detected",
      debug: Q._timingsOnly ? null : Q,
      timings: B
    };
  const s = E[0];
  o = performance.now();
  const a = eA(s, {
    epsilon: t.epsilon
    // Pass epsilon for approximation
  });
  B.push({ step: "Corner Detection", ms: (performance.now() - o).toFixed(2) });
  let e = a;
  return C !== 1 && (e = {
    topLeft: { x: a.topLeft.x * C, y: a.topLeft.y * C },
    topRight: { x: a.topRight.x * C, y: a.topRight.y * C },
    bottomRight: { x: a.bottomRight.x * C, y: a.bottomRight.y * C },
    bottomLeft: { x: a.bottomLeft.x * C, y: a.bottomLeft.y * C }
  }), {
    success: !0,
    contour: s,
    corners: e,
    debug: Q._timingsOnly ? null : Q,
    timings: B
  };
}
function UA(I, A) {
  function g(o) {
    const E = [];
    for (let s = 0; s < 4; s++) {
      const [a, e] = o[s];
      E.push([a, e, 1, 0, 0, 0, -a * A[s][0], -e * A[s][0]]), E.push([0, 0, 0, a, e, 1, -a * A[s][1], -e * A[s][1]]);
    }
    return E;
  }
  const C = g(I), t = [
    A[0][0],
    A[0][1],
    A[1][0],
    A[1][1],
    A[2][0],
    A[2][1],
    A[3][0],
    A[3][1]
  ];
  function Q(o, E) {
    const s = o.length, a = o[0].length, e = o.map((c) => c.slice()), n = E.slice();
    for (let c = 0; c < a; c++) {
      let w = c;
      for (let D = c + 1; D < s; D++)
        Math.abs(e[D][c]) > Math.abs(e[w][c]) && (w = D);
      [e[c], e[w]] = [e[w], e[c]], [n[c], n[w]] = [n[w], n[c]];
      for (let D = c + 1; D < s; D++) {
        const h = e[D][c] / e[c][c];
        for (let r = c; r < a; r++)
          e[D][r] -= h * e[c][r];
        n[D] -= h * n[c];
      }
    }
    const y = new Array(a);
    for (let c = a - 1; c >= 0; c--) {
      let w = n[c];
      for (let D = c + 1; D < a; D++)
        w -= e[c][D] * y[D];
      y[c] = w / e[c][c];
    }
    return y;
  }
  const B = Q(C, t);
  return [
    [B[0], B[1], B[2]],
    [B[3], B[4], B[5]],
    [B[6], B[7], 1]
  ];
}
function _(I, A, g) {
  const { topLeft: C, topRight: t, bottomRight: Q, bottomLeft: B } = g, i = Math.hypot(Q.x - B.x, Q.y - B.y), o = Math.hypot(t.x - C.x, t.y - C.y), E = Math.round(Math.max(i, o)), s = Math.hypot(t.x - Q.x, t.y - Q.y), a = Math.hypot(C.x - B.x, C.y - B.y), e = Math.round(Math.max(s, a));
  I.canvas.width = E, I.canvas.height = e;
  const n = [
    [C.x, C.y],
    [t.x, t.y],
    [Q.x, Q.y],
    [B.x, B.y]
  ], y = [
    [0, 0],
    [E - 1, 0],
    [E - 1, e - 1],
    [0, e - 1]
  ], c = UA(n, y);
  HA(I, A, c, E, e);
}
function YA(I) {
  const A = I[0][0], g = I[0][1], C = I[0][2], t = I[1][0], Q = I[1][1], B = I[1][2], i = I[2][0], o = I[2][1], E = I[2][2], s = Q * E - B * o, a = -(t * E - B * i), e = t * o - Q * i, n = -(g * E - C * o), y = A * E - C * i, c = -(A * o - g * i), w = g * B - C * Q, D = -(A * B - C * t), h = A * Q - g * t, r = A * s + g * a + C * e;
  if (r === 0) throw new Error("Singular matrix");
  return [
    [s / r, n / r, w / r],
    [a / r, y / r, D / r],
    [e / r, c / r, h / r]
  ];
}
function HA(I, A, g, C, t) {
  const Q = A.width || A.naturalWidth, B = A.height || A.naturalHeight, i = YA(g);
  function o(c, w) {
    const D = i[2][0] * c + i[2][1] * w + i[2][2];
    return {
      x: (i[0][0] * c + i[0][1] * w + i[0][2]) / D,
      y: (i[1][0] * c + i[1][1] * w + i[1][2]) / D
    };
  }
  const E = 64, s = 64, a = C / E, e = t / s, n = document.createElement("canvas");
  n.width = Q, n.height = B, n.getContext("2d").drawImage(A, 0, 0, Q, B), I.imageSmoothingEnabled = !0, I.imageSmoothingQuality = "high", I.save();
  for (let c = 0; c < s; c++)
    for (let w = 0; w < E; w++) {
      const D = w * a, h = c * e, r = (w + 1) * a, N = (c + 1) * e, F = o(D, h), J = o(r, h), f = o(D, N), G = o(r, N);
      j(
        I,
        n,
        F.x,
        F.y,
        J.x,
        J.y,
        f.x,
        f.y,
        // source triangle
        D,
        h,
        r,
        h,
        D,
        N
        // dest triangle
      ), j(
        I,
        n,
        J.x,
        J.y,
        G.x,
        G.y,
        f.x,
        f.y,
        // source triangle
        r,
        h,
        r,
        N,
        D,
        N
        // dest triangle
      );
    }
  I.restore();
}
function j(I, A, g, C, t, Q, B, i, o, E, s, a, e, n) {
  const y = (g - B) * (Q - i) - (t - B) * (C - i);
  if (Math.abs(y) < 1e-10) return;
  const c = 1 / y, w = ((o - e) * (Q - i) - (s - e) * (C - i)) * c, D = ((s - e) * (g - B) - (o - e) * (t - B)) * c, h = o - w * g - D * C, r = ((E - n) * (Q - i) - (a - n) * (C - i)) * c, N = ((a - n) * (g - B) - (E - n) * (t - B)) * c, F = E - r * g - N * C;
  I.save();
  const J = 1, f = (o + s + e) / 3, G = (E + a + n) / 3, k = (S, m) => {
    const U = S - f, x = m - G, b = Math.sqrt(U * U + x * x);
    return b < 1e-6 ? { x: S, y: m } : {
      x: S + U / b * J,
      y: m + x / b * J
    };
  }, L = k(o, E), q = k(s, a), l = k(e, n);
  I.beginPath(), I.moveTo(L.x, L.y), I.lineTo(q.x, q.y), I.lineTo(l.x, l.y), I.closePath(), I.clip(), I.setTransform(w, r, D, N, h, F), I.drawImage(A, 0, 0), I.restore();
}
async function dA(I, A, g = {}) {
  const C = g.output || "canvas";
  if (!A || !A.topLeft || !A.topRight || !A.bottomRight || !A.bottomLeft)
    return {
      output: null,
      corners: null,
      success: !1,
      message: "Invalid corner points provided"
    };
  try {
    const t = document.createElement("canvas"), Q = t.getContext("2d");
    _(Q, I, A);
    let B;
    return C === "canvas" ? B = t : C === "imagedata" ? B = t.getContext("2d").getImageData(0, 0, t.width, t.height) : C === "dataurl" ? B = t.toDataURL() : B = t, {
      output: B,
      corners: A,
      success: !0,
      message: "Document extracted successfully"
    };
  } catch (t) {
    return {
      output: null,
      corners: A,
      success: !1,
      message: `Extraction failed: ${t.message}`
    };
  }
}
async function uA(I, A = {}) {
  const g = [], C = performance.now(), t = A.mode || "detect", Q = A.output || "canvas";
  A.debug;
  const B = A.maxProcessingDimension || 800;
  let i = performance.now();
  const { grayscaleData: o, imageData: E, scaleFactor: s, originalDimensions: a, scaledDimensions: e } = await LA(I, B);
  g.push({ step: "Image Prep + Scale + Gray", ms: (performance.now() - i).toFixed(2) });
  const n = await mA(
    o,
    e.width,
    e.height,
    s,
    A
  );
  if (n.timings && n.timings.forEach((D) => g.push(D)), !n.success) {
    const D = performance.now();
    return g.unshift({ step: "Total", ms: (D - C).toFixed(2) }), console.table(g), {
      output: null,
      corners: null,
      contour: null,
      debug: n.debug,
      success: !1,
      message: n.message || "No document detected",
      timings: g
    };
  }
  let y, c;
  if (t === "detect")
    c = null;
  else if (t === "extract") {
    i = performance.now(), y = document.createElement("canvas");
    const D = y.getContext("2d");
    _(D, I, n.corners), g.push({ step: "Perspective Transform", ms: (performance.now() - i).toFixed(2) });
  }
  t !== "detect" && y && (i = performance.now(), Q === "canvas" ? c = y : Q === "imagedata" ? c = y.getContext("2d").getImageData(0, 0, y.width, y.height) : Q === "dataurl" ? c = y.toDataURL() : c = y, g.push({ step: "Output Conversion", ms: (performance.now() - i).toFixed(2) }));
  const w = performance.now();
  return g.unshift({ step: "Total", ms: (w - C).toFixed(2) }), console.table(g), {
    output: c,
    corners: n.corners,
    contour: n.contour,
    debug: n.debug,
    success: !0,
    message: "Document detected",
    timings: g
  };
}
export {
  xA as Scanner,
  dA as extractDocument,
  qA as initialize,
  uA as scanDocument
};
//# sourceMappingURL=scanic.js.map
